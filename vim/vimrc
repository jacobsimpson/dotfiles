
"let mapleader = ','
"let maplocalleader = ","

syntax on
filetype plugin indent off
set tabstop=4
" Sets how much indent for the >
set shiftwidth=4

" Somewhere around the neovim 0.2.1-dev transition, every time I save a go file,
" it resets my tabstop. So, this sets it back.
au BufWritePost *.go set tabstop=4

" Use 'shiftwidth' when using <Tab> in front of a line. By default it's used
" only for shift commands ("<", ">").
set smarttab

" This will affect CtrlP plugin, and exclude files from the listing.
set wildignore+=*.o,*.class,.svn,*.jar,*.gif,*.jpg,*.pyc,.git,*.so,*.zip,*.swp

" Ignore these directories for Ctrl-P
set wildignore+=*/bin/*,*/build/*,*/target/*,*/node_modules/*,*/lib/*

" Each new line will match code block
set autoindent
" Tabs will be changed to equivalent spaces,
" affects autoindent and shift (>) operator.
set expandtab

" Toggle the NERDTree side bar on and off.
nmap <leader>d :NERDTreeToggle<CR>

" Search recursively for files.
nnoremap <C-p> :<C-u>Unite -no-split -buffer-name=files -start-insert file_rec/async:!<cr>

" List the open buffers.
nnoremap <leader>b :<C-u>Unite -no-split -buffer-name=buffer  buffer<cr>

" Add incremental searching to vim.
set incsearch

" Set case insensitive searching.
set ignorecase
" If you include a capital letter in a search, vim switches to case sensitive searching.
set smartcase

" Jump to the next or previous line that has the same level or a lower
" level of indentation than the current line.
"
" exclusive (bool): true: Motion is exclusive
" false: Motion is inclusive
" fwd (bool): true: Go to next line
" false: Go to previous line
" lowerlevel (bool): true: Go to line with lower indentation level
" false: Go to line with the same indentation level
" skipblanks (bool): true: Skip blank lines
" false: Don't skip blank lines
function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
  let line = line('.')
  let column = col('.')
  let lastline = line('$')
  let indent = indent(line)
  let stepvalue = a:fwd ? 1 : -1
  while (line > 0 && line <= lastline)
    let line = line + stepvalue
    if ( ! a:lowerlevel && indent(line) == indent ||
          \ a:lowerlevel && indent(line) < indent)
      if (! a:skipblanks || strlen(getline(line)) > 0)
        if (a:exclusive)
          let line = line - stepvalue
        endif
        exe line
        exe "normal " column . "|"
        return
      endif
    endif
  endwhile
endfunction

" Moving back and forth between lines of same or lower indentation.
nnoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
nnoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
nnoremap <silent> [L :call NextIndent(0, 0, 1, 1)<CR>
nnoremap <silent> ]L :call NextIndent(0, 1, 1, 1)<CR>
vnoremap <silent> [l <Esc>:call NextIndent(0, 0, 0, 1)<CR>m'gv''
vnoremap <silent> ]l <Esc>:call NextIndent(0, 1, 0, 1)<CR>m'gv''
vnoremap <silent> [L <Esc>:call NextIndent(0, 0, 1, 1)<CR>m'gv''
vnoremap <silent> ]L <Esc>:call NextIndent(0, 1, 1, 1)<CR>m'gv''
onoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
onoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
onoremap <silent> [L :call NextIndent(1, 0, 1, 1)<CR>
onoremap <silent> ]L :call NextIndent(1, 1, 1, 1)<CR>

" This setting allows you to switch between buffers, leave unsaved changes
" in a buffer and have them still be there when you get back.
set hidden

au FileType lua vmap <C-_> :s#^#--#<CR>
au FileType lua nmap <C-_> :s#^#--#<CR>

" Maps the RE search key so it gets extended regular expressions by default.
"
" As it turns out, this is painful. It's always in the way, I often have to
" delete it for some reason.
"
"nnoremap / /\v
"vnoremap / /\v

" Set up the Go-Lang plugins. Copy-Paste from the
" Some Linux distributions set filetype in /etc/vimrc.
" Clear filetype flags before changing runtimepath to force Vim to reload them.
if exists("g:did_load_filetypes")
  filetype off
  filetype plugin indent off
endif
set runtimepath+=$GOROOT/misc/vim " replace $GOROOT with the output of: go env GOROOT
filetype plugin indent on
syntax on
autocmd FileType go compiler go

" When editing Makefiles...
function EnterMakefile()
    set noexpandtab
endfunction
function LeaveMakefile()
    set expandtab
endfunction

autocmd BufEnter,BufNew Makefile      call EnterMakefile()
autocmd BufEnter,BufNew makefile      call EnterMakefile()

autocmd BufLeave Makefile             call LeaveMakefile()
autocmd BufLeave makefile             call LeaveMakefile()



" When editing markdown files...
function EnterMarkdown()
    set conceallevel=0
endfunction
function LeaveMarkdown()
    set conceallevel=0
endfunction

autocmd BufEnter,BufNew *.md      call EnterMarkdown()
autocmd BufLeave        *.md      call LeaveMarkdown()

" Specify a directory for plugins
" - For Neovim: ~/.local/share/nvim/plugged
" - Avoid using standard Vim directory names like 'plugin'
call plug#begin('~/.vim/plugged')
    source ~/home-dir/vim/plugins.vim
call plug#end()

" Options for highlighting matching values of search.
"  Turn on highlighting.
set hlsearch
"  remap the space bar to toggle match highlighting off.
nnoremap <silent> ,/ :nohlsearch<Bar>:echo<CR>

" Required:
filetype plugin indent on

" Configure the whitespace plugin to auto strip trailing whitespace when the
" given file types are saved.
autocmd FileType ruby,python,javascript,html,c,cpp,text,vim,json,xml,sh,rs,coffee,groovy,scala,jproperties,toml,vue
      \  autocmd BufWritePre <buffer> StripWhitespace

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For conceal markers.
if has('conceal')
    set conceallevel=2 concealcursor=niv
endif

" You know when you are editing a file and you try to save it only to find out
" it is write restricted and you have to exit vim and re-run it with sudo root
" just so you can save changes?
" Do :w!! instead.
cmap w!! w !sudo tee > /dev/null %

" This will execute highlighted text as VimScript.
vmap <silent> <leader>r "xy:@x<CR>

" Navigating quickfix should get easier.
map <C-n> :cnext<CR>
map <C-m> :cprevious<CR>
nnoremap ,c :cclose<CR>

" Improved window navigation key strokes. Fewer keys makes a big
" difference for window navigation.
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
" NOTE: C-H is special. C-H is commonly used by terminals to send the
" backspace character. So, to make this work, I had to change iTerm to send
" the C-? character as backspace (Settings -> Profile -> Select Profile ->
" Keymap -> + (to add a new keymap) -> Backspace as C-?)
" http://vi.stackexchange.com/questions/3119/mapping-control-h-in-insert-mode-doesnt-work-it-always-works-like-backspace
"
" This works on Linux.
nnoremap <C-H> <C-W><C-H>
" This is for Mac.
" To make this work, I had to change iTerm to send
" the C-? character as backspace (Settings -> Profile -> Select Profile ->
" Keymap -> + (to add a new keymap) -> Backspace as C-?)
" http://vi.stackexchange.com/questions/3119/mapping-control-h-in-insert-mode-doesnt-work-it-always-works-like-backspace
nnoremap <Backspace> <C-W><C-H>

" The Goal:
" Improved windowing experience in Vim.
" 1. Really simple hotkeys for common actions.
"   - moving windows
"   - C-hjkl - not bad, but C-h maps to backspace in many terminal programs.
"              Also, on Mac OS X, it isn't mapped properly in the term progs.
"              https://github.com/neovim/neovim/issues/2048
"   - A-hjkl - not bad, but Mac uses Alt for Unicode chars be default.
" 2. Closing a buffer in a window should really pop back a buffer, like a
" stack. But the stack should be specific to that window.
" 3. Easy to change between a couple common arrangements.
"   - big window in the middle, one on each side, terminal type on the bottom.
"   - side by side diff of two things.
" 4. Pair navigation.
"   - navigate to the paired file.
"   - some kind of function or pattern for recognizing a pair.
"   - file to the unit test, that kind of thing.
"   - primary, secondary, tertiary pair.
"
" On a Mac, the default keyboard mapping doesn't pass the Alt key
" combinations, so this is a mapping of the Unicode characters it does pass.
noremap ê <C-W><C-J>
noremap ë <C-W><C-K>
noremap ì <C-W><C-L>
noremap è <C-W><C-H>
noremap <A-h> <C-W><C-H>
noremap <A-j> <C-W><C-J>
noremap <A-k> <C-W><C-k>
noremap <A-l> <C-W><C-l>

" Open new split panes to right and bottom, which feels more natural than
" Vim’s default:
set splitbelow
set splitright

" Makes the Airline status bar visible at all times.
set laststatus=2

" Keep visual selection after indenting or unindenting.
vnoremap < <gv
vnoremap > >gv
vmap <TAB> >
vmap <S-TAB> <
nmap <TAB> >>
nmap <S-TAB> <<
" When inserting, allow Shift-Tab to un-Tab.
inoremap <S-TAB> <C-D>

" Buffer navigation is extremely common, so there are some things I remapped
" to make that go faster. I hope.
map <silent> ,bd :bd<CR>
map <silent> ,bb :b#<CR>
map <silent> ,bp :bp<CR>
map <silent> ,bn :bn<CR>
" Allow the current buffer to be deleted without removing the window.
map <silent> ,bc :bp\|bd #<CR>

" Make the cursor at least this many lines away from the edge of the screen.
set scrolloff=3

" Make global substitutions the default.
" So, when you do:
"     :%s/abc/123/
" it will act like:
"     :%s/abc/123/g
set gdefault

" Marks in Vim can be used two ways. The ' takes you to the line of the mark,
" the ` takes you to the line and column of the mark. I nearly always want the
" line and column position, but I find the ' easier to use, so these commands
" reverse the keymaps.
" NOTE: There is a still a problem with this. These keys are not remapped when
" used in sequences like d'a (delete to mark a).
nnoremap ` '
nnoremap ' `
vnoremap ` '
vnoremap ' `

" These mappings should allow easily moving a line up or down.
nnoremap <Space>k   :<C-u>silent! move-2<CR>==
nnoremap <Space>j   :<C-u>silent! move+<CR>==
xnoremap <Space>k   :<C-u>silent! '<,'>move-2<CR>gv=gv
xnoremap <Space>j   :<C-u>silent! '<,'>move'>+<CR>gv=gv

" Keep the cursor at the column it was at after a move, like switching
" buffers.
set nostartofline

" Set the colors used when the cursor is on a matching paren.
hi MatchParen cterm=bold ctermbg=none ctermfg=Yellow

" When Vim is resized, make all the splits resize equally. Not a perfect
" solution (maintaining proportion would be perfect) but a sufficient
" solution.
augroup Misc
    autocmd!
    autocmd VimResized * exe "normal! \<c-w>="
augroup END

source ~/home-dir/vim/nvimrc

" Automatically save the file when the user does a build.
set autowrite

" This changes the default command line editor experience (the mode you enter
" with the : key) to use a command-line-editor window instead. It allows you
" to have an editing experience more in line with the other Vim windows.
"
" NOTE: This was an experiment that didn't work out. At first it seemed okay,
" but in daily usage, the following problems appeared:
" 1. If you start typing a command and press the up arrow, the partially typed
" command is NOT used to limit up arrow navigation to matches. Instead, up
" arrow just takes you one line up, to the previous command.
" 2. :pwd - output disappears off the screeen and isn't visible.
" 3. The command-line-editor, even at height of 1, causes all windows to
" resize each time you do a ':' command. It's kind of annoying, though
" ultimately livable.
"nnoremap : q::startinsert<cr>
"set cmdwinheight=1

" Configure Universal Text Linking plugin.
let g:utl_cfg_hdl_scm_http_system = 'silent !/usr/bin/open -a "/Applications/Google Chrome.app" "%u"'

" Remap the <leader>* key to do a search analogous to how vim searches when
" the * key is hit, but across different files.
nnoremap <leader>* :Ag "<cword>"<CR>
vnoremap <leader>* :<C-u>call VisualStarSearchSet('/')<CR>:execute 'noautocmd Ag ' . @/ . ''<CR>

" Make Ag easier to use.
nnoremap <silent> ,g :Ag <C-r><C-w><CR>
xnoremap <silent> ,g :<C-u>let cmd = "Ag " . functions#GetVisualSelection() <bar>
                        \ call histadd("cmd",cmd) <bar>

map <silent> ,r :e %<CR>

" This makes it so that when you are navigating up and down in a long line
" that wraps on the screen, you will move one display line, instead of one
" physical line (as determined by the hard line break.)
nmap j gj
nmap k gk

" This should give Emacs style navigation within the command line window.
cnoremap <C-a>  <Home>
cnoremap <C-b>  <Left>
cnoremap <C-f>  <Right>
cnoremap <C-d>  <Delete>
cnoremap <M-b>  <S-Left>
cnoremap <M-f>  <S-Right>
cnoremap <M-d>  <S-right><Delete>
cnoremap <Esc>b <S-Left>
cnoremap <Esc>f <S-Right>
cnoremap <Esc>d <S-right><Delete>
cnoremap <C-g>  <C-c>
cnoremap <C-y>  <C-r>"
