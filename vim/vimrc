
"let mapleader = ','
"let maplocalleader = ","

syntax on
filetype plugin indent off
set tabstop=4
" Sets how much indent for the >
set shiftwidth=4

" Somewhere around the neovim 0.2.1-dev transition, every time I save a go file,
" it resets my tabstop. So, this sets it back.
au BufWritePost *.go set tabstop=4

" Use 'shiftwidth' when using <Tab> in front of a line. By default it's used
" only for shift commands ("<", ">").
set smarttab

" This will affect CtrlP plugin, and exclude files from the listing.
set wildignore+=*.o,*.class,.svn,*.jar,*.gif,*.jpg,*.pyc,.git,*.so,*.zip,*.swp

" Ignore these directories for Ctrl-P
set wildignore+=*/bin/*,*/build/*,*/target/*,*/node_modules/*,*/lib/*

" Each new line will match code block
set autoindent
" Tabs will be changed to equivalent spaces,
" affects autoindent and shift (>) operator.
set expandtab

" Toggle the NERDTree side bar on and off.
nmap <leader>d :NERDTreeToggle<CR>

" Search recursively for files.
nnoremap <C-p> :<C-u>Unite -no-split -buffer-name=files -start-insert file_rec/async:!<cr>

" List the open buffers.
nnoremap <leader>b :<C-u>Unite -no-split -buffer-name=buffer  buffer<cr>

" Add incremental searching to vim.
set incsearch

" Set case insensitive searching.
set ignorecase
" If you include a capital letter in a search, vim switches to case sensitive searching.
set smartcase

" Close the current buffer without closing the current window.
map <silent> <Space>bd :b#<bar>bd#<CR>

" Jump to the next or previous line that has the same level or a lower
" level of indentation than the current line.
"
" exclusive (bool): true: Motion is exclusive
" false: Motion is inclusive
" fwd (bool): true: Go to next line
" false: Go to previous line
" lowerlevel (bool): true: Go to line with lower indentation level
" false: Go to line with the same indentation level
" skipblanks (bool): true: Skip blank lines
" false: Don't skip blank lines
function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
  let line = line('.')
  let column = col('.')
  let lastline = line('$')
  let indent = indent(line)
  let stepvalue = a:fwd ? 1 : -1
  while (line > 0 && line <= lastline)
    let line = line + stepvalue
    if ( ! a:lowerlevel && indent(line) == indent ||
          \ a:lowerlevel && indent(line) < indent)
      if (! a:skipblanks || strlen(getline(line)) > 0)
        if (a:exclusive)
          let line = line - stepvalue
        endif
        exe line
        exe "normal " column . "|"
        return
      endif
    endif
  endwhile
endfunction

" Moving back and forth between lines of same or lower indentation.
nnoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
nnoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
nnoremap <silent> [L :call NextIndent(0, 0, 1, 1)<CR>
nnoremap <silent> ]L :call NextIndent(0, 1, 1, 1)<CR>
vnoremap <silent> [l <Esc>:call NextIndent(0, 0, 0, 1)<CR>m'gv''
vnoremap <silent> ]l <Esc>:call NextIndent(0, 1, 0, 1)<CR>m'gv''
vnoremap <silent> [L <Esc>:call NextIndent(0, 0, 1, 1)<CR>m'gv''
vnoremap <silent> ]L <Esc>:call NextIndent(0, 1, 1, 1)<CR>m'gv''
onoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
onoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
onoremap <silent> [L :call NextIndent(1, 0, 1, 1)<CR>
onoremap <silent> ]L :call NextIndent(1, 1, 1, 1)<CR>

" Options for highlighting matching values of search.
"  Turn on highlighting.
set hlsearch
"  remap the space bar to toggle match highlighting off.
nnoremap <silent> <Space> :nohlsearch<Bar>:echo<CR>
"nnoremap <leader><space> :noh<cr>

" This setting allows you to switch between buffers, leave unsaved changes
" in a buffer and have them still be there when you get back.
set hidden

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Remap :make to ant for Java files.
function SetJavaCompilerAnt()
    set makeprg=ant
    " Things learned about efm.
    "   The pattern MUST consume the whole line, or it will just fail to match.
    "   .* regular expression is represented as %.%#
    "   :clist shows the matched lines. If no lines match, the whole output is displayed.
    "   although the docs indicate you can cat a bunch of syntax strings together, this doesn't actually work.
    set efm=\ %#[javac]\ %f:%l:%m
    set efm=\ %#[junit]\ %.at%m

    let &efm=' %#[javac] %f:%l:%m'
endfunction

function SetJavaCompilerGradle()
    set makeprg=gradle
    " Things learned about efm.
    "   The pattern MUST consume the whole line, or it will just fail to match.
    "   .* regular expression is represented as %.%#
    "   :clist shows the matched lines. If no lines match, the whole output is displayed.
    "   although the docs indicate you can cat a bunch of syntax strings together, this doesn't actually work.
    "   :compileJava/Users/jacobsimpson/src/code-retreat/java-ag/src/main/java/Main.java:4: error: ';' expec
    "
    set efm=\%E[ant:scalac]\ %f:%l:\ error:\ %m,\%W[ant:scalac]\ %f:%l:\ warning:\ %m,\%E%.%#:compile%\\w%#Java%f:%l:\ error:\ %m
    ",%-Z%p^,%-C%.%#,\%W%.%#:compile%\\w%#Java%f:%l:\ warning:\ %m,%-Z%p^,%-C%.%#,\%E%f:%l:\ error:\ %m,%-Z%p^,%-C%.%#, \%W%f:%l:\ warning:\ %m,%-Z%p^,%-C%.%#,\%E%f:\ %\\d%\\+:\ %m\ @\ line\ %l\\,\ column\ %c.,%-C%.%#,%Z%p^,\%E%>%f:\ %\\d%\\+:\ %m,%C\ @\ line\ %l\\,\ column\ %c.,%-C%.%#,%Z%p^,\%-G%.%#
    "

    autocmd BufWritePost *.java silent! !javafmt -i <afile>
endfunction

"" The autocmd lines conditionally remap the makeprg if you navigate to or open Java files.
autocmd BufEnter,BufNew *.java         call SetJavaCompilerGradle()
autocmd BufEnter,BufNew build.xml      call SetJavaCompilerAnt()
autocmd BufEnter,BufNew build.gradle   call SetJavaCompilerGradle()

au FileType java nmap ,m :make build<CR>
au FileType java nmap ,t :make test<CR>


au FileType lua vmap <C-_> :s#^#--#<CR>
au FileType lua nmap <C-_> :s#^#--#<CR>
au FileType go vmap <C-_> :s#^#//#<CR>
au FileType go nmap <C-_> :s#^#//#<CR>
au FileType vim vmap <C-_> :s#^#"#<CR>
au FileType vim nmap <C-_> :s#^#"#<CR>
au FileType java vmap <C-_> :s#^#//#<CR>
au FileType java nmap <C-_> :s#^#//#<CR>

" Maps the RE search key so it gets extended regular expressions by default.
"
" As it turns out, this is painful. It's always in the way, I often have to
" delete it for some reason.
"
"nnoremap / /\v
"vnoremap / /\v

" Set up the Go-Lang plugins. Copy-Paste from the
" Some Linux distributions set filetype in /etc/vimrc.
" Clear filetype flags before changing runtimepath to force Vim to reload them.
if exists("g:did_load_filetypes")
  filetype off
  filetype plugin indent off
endif
set runtimepath+=$GOROOT/misc/vim " replace $GOROOT with the output of: go env GOROOT
filetype plugin indent on
syntax on
autocmd FileType go compiler go

" When editing Makefiles...
function EnterMakefile()
    set noexpandtab
endfunction
function LeaveMakefile()
    set expandtab
endfunction

autocmd BufEnter,BufNew Makefile      call EnterMakefile()
autocmd BufEnter,BufNew makefile      call EnterMakefile()

autocmd BufLeave Makefile             call LeaveMakefile()
autocmd BufLeave makefile             call LeaveMakefile()



" When editing markdown files...
function EnterMarkdown()
    set conceallevel=0
endfunction
function LeaveMarkdown()
    set conceallevel=0
endfunction

autocmd BufEnter,BufNew *.md      call EnterMarkdown()
autocmd BufLeave        *.md      call LeaveMarkdown()

" ######################### NeoBundle Config
" Note: Skip initialization for vim-tiny or vim-small.
if 0 | endif

if has('vim_starting')
   if &compatible
     set nocompatible               " Be iMproved
   endif

   " Required:
   set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

" Required:
call neobundle#begin(expand('~/.vim/bundle/'))
    " Let NeoBundle manage NeoBundle
    " Required:
    NeoBundleFetch 'Shougo/neobundle.vim'

    source ~/home-dir/vim/plugins.vim
call neobundle#end()

" EasyMotion configuration.
let g:EasyMotion_do_mapping = 0 " Disable default mappings
let g:EasyMotion_leader_key = ','
nmap s <Plug>(easymotion-overwin-f)

" Required:
filetype plugin indent on

" Signify is a plugin that adds signs to the gutter indicating that there are
" local changes.
let g:signify_vcs_list = [ 'git', 'hg' ]
let g:signify_realtime = 1

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck

" Configure the whitespace plugin to auto strip trailing whitespace when the
" given file types are saved.
autocmd FileType java,ruby,python,javascript,html,c,cpp,text,vim,json,xml,sh,go,rs,coffee,groovy,scala,jproperties,toml,vue
      \  autocmd BufWritePre <buffer> StripWhitespace

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For conceal markers.
if has('conceal')
    set conceallevel=2 concealcursor=niv
endif

" You know when you are editing a file and you try to save it only to find out
" it is write restricted and you have to exit vim and re-run it with sudo root
" just so you can save changes?
" Do :w!! instead.
cmap w!! w !sudo tee > /dev/null %

" This will execute highlighted text as VimScript.
vmap <silent> <leader>r "xy:@x<CR>

" Remap the <leader>* key to do a search analogous to how vim searches when
" the * key is hit, but across different files.
nnoremap <leader>* :Ag "<cword>"<CR>
vnoremap <leader>* :<C-u>call VisualStarSearchSet('/')<CR>:execute 'noautocmd Ag ' . @/ . ''<CR>

" Select a color scheme.
color molokai

" Navigating quickfix should get easier.
map <C-n> :cnext<CR>
map <C-m> :cprevious<CR>
nnoremap ,c :cclose<CR>

" Improved window navigation key strokes. Fewer keys makes a big
" difference for window navigation.
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
" NOTE: C-H is special. C-H is commonly used by terminals to send the
" backspace character. So, to make this work, I had to change iTerm to send
" the C-? character as backspace (Settings -> Profile -> Select Profile ->
" Keymap -> + (to add a new keymap) -> Backspace as C-?)
" http://vi.stackexchange.com/questions/3119/mapping-control-h-in-insert-mode-doesnt-work-it-always-works-like-backspace
"
" This works on Linux.
nnoremap <C-H> <C-W><C-H>
" This is for Mac.
" To make this work, I had to change iTerm to send
" the C-? character as backspace (Settings -> Profile -> Select Profile ->
" Keymap -> + (to add a new keymap) -> Backspace as C-?)
" http://vi.stackexchange.com/questions/3119/mapping-control-h-in-insert-mode-doesnt-work-it-always-works-like-backspace
nnoremap <Backspace> <C-W><C-H>

" The Goal:
" Improved windowing experience in Vim.
" 1. Really simple hotkeys for common actions.
"   - moving windows
"   - C-hjkl - not bad, but C-h maps to backspace in many terminal programs.
"              Also, on Mac OS X, it isn't mapped properly in the term progs.
"              https://github.com/neovim/neovim/issues/2048
"   - A-hjkl - not bad, but Mac uses Alt for Unicode chars be default.
" 2. Closing a buffer in a window should really pop back a buffer, like a
" stack. But the stack should be specific to that window.
" 3. Easy to change between a couple common arrangements.
"   - big window in the middle, one on each side, terminal type on the bottom.
"   - side by side diff of two things.
" 4. Pair navigation.
"   - navigate to the paired file.
"   - some kind of function or pattern for recognizing a pair.
"   - file to the unit test, that kind of thing.
"   - primary, secondary, tertiary pair.
"
" On a Mac, the default keyboard mapping doesn't pass the Alt key
" combinations, so this is a mapping of the Unicode characters it does pass.
noremap ê <C-W><C-J>
noremap ë <C-W><C-K>
noremap ì <C-W><C-L>
noremap è <C-W><C-H>
noremap <A-h> <C-W><C-H>
noremap <A-j> <C-W><C-J>
noremap <A-k> <C-W><C-k>
noremap <A-l> <C-W><C-l>

" Open new split panes to right and bottom, which feels more natural than
" Vim’s default:
set splitbelow
set splitright

" Makes the Airline status bar visible at all times.
set laststatus=2

" Keep visual selection after indenting or unindenting.
vnoremap < <gv
vnoremap > >gv
vmap <TAB> >
vmap <S-TAB> <
nmap <TAB> >>
nmap <S-TAB> <<
" When inserting, allow Shift-Tab to un-Tab.
inoremap <S-TAB> <C-D>

" Allow the current buffer to be deleted without removing the window.
nmap <silent> ,bd :bp\|bd #<CR>

" Make the cursor at least this many lines away from the edge of the screen.
set scrolloff=3

" Make global substitutions the default.
" So, when you do:
"     :%s/abc/123/
" it will act like:
"     :%s/abc/123/g
set gdefault

" Marks in Vim can be used two ways. The ' takes you to the line of the mark,
" the ` takes you to the line and column of the mark. I nearly always want the
" line and column position, but I find the ' easier to use, so these commands
" reverse the keymaps.
" NOTE: There is a still a problem with this. These keys are not remapped when
" used in sequences like d'a (delete to mark a).
nnoremap ` '
nnoremap ' `
vnoremap ` '
vnoremap ' `

" These mappings should allow easily moving a line up or down.
nnoremap <Space>k   :<C-u>silent! move-2<CR>==
nnoremap <Space>j   :<C-u>silent! move+<CR>==
xnoremap <Space>k   :<C-u>silent! '<,'>move-2<CR>gv=gv
xnoremap <Space>j   :<C-u>silent! '<,'>move'>+<CR>gv=gv

" Keep the cursor at the column it was at after a move, like switching
" buffers.
set nostartofline

" Set the colors used when the cursor is on a matching paren.
hi MatchParen cterm=bold ctermbg=none ctermfg=Yellow

nmap <C-A-F> :%!python -m json.tool<CR>

" Experimental ...
" This changes the default command line editor experience (the mode you enter
" with the : key) to use a command-line-editor window instead. It allows you
" to have an editing experience more in line with the other Vim windows.
"nnoremap : q::startinsert<cr>
"set cmdwinheight=1

" When Vim is resized, make all the splits resize equally. Not a perfect
" solution (maintaining proportion would be perfect) but a sufficient
" solution.
augroup Misc
    autocmd!
    autocmd VimResized * exe "normal! \<c-w>="
augroup END

source ~/home-dir/vim/nvimrc

" This changes the default command line editor experience (the mode you enter
" with the : key) to use a command-line-editor window instead. It allows you
" to have an editing experience more in line with the other Vim windows.
"
" NOTE: This was an experiment that didn't work out. At first it seemed okay,
" but in daily usage, the following problems appeared:
" 1. If you start typing a command and press the up arrow, the partially typed
" command is NOT used to limit up arrow navigation to matches. Instead, up
" arrow just takes you one line up, to the previous command.
" 2. :pwd - output disappears off the screeen and isn't visible.
" 3. The command-line-editor, even at height of 1, causes all windows to
" resize each time you do a ':' command. It's kind of annoying, though
" ultimately livable.
"nnoremap : q::startinsert<cr>
"set cmdwinheight=1

" When Vim is resized, make all the splits resize equally. Not a perfect
" solution (maintaining proportion would be perfect) but a sufficient
" solution.
augroup Misc
    autocmd!
    autocmd VimResized * exe "normal! \<c-w>="
augroup END

" Configure Universal Text Linking plugin.
let g:utl_cfg_hdl_scm_http_system = 'silent !/usr/bin/open -a "/Applications/Google Chrome.app" "%u"'

" vim-go settings.

" Make the output of GoTest appear in a terminal window instead of in
" quickfix.
" -- with experimentation I found that this is not so useful. Although the
"  quick fix window is quirky and difficult to read, it stays visible, and is
"  navigable. The terminal window is nicer with respect to size, but it
"  doesn't have highlighting and disappears when I press a key.
"let g:go_term_enabled = 1

" Open new terminals in a horizontal split by default.
let g:go_term_mode = "split"

" Enable some keyboard shortcuts.
au FileType go nmap ,a :GoAlternate<CR>
au FileType go nmap ,b <Plug>(go-build)
au FileType go nmap ,c <Plug>(go-coverage)
au FileType go nmap ,e <Plug>(go-rename)
au FileType go nmap ,gb <Plug>(go-doc-browser)
au FileType go nmap ,gd <Plug>(go-doc)
au FileType go nmap ,i <Plug>(go-info)
au FileType go nmap ,m :GoBuild<CR>
au FileType go nmap ,q <Plug>(go-doc-split)
au FileType go nmap ,r <Plug>(go-run-split)
au FileType go nmap ,t :GoTest<CR>
au FileType go nmap ,t <Plug>(go-test)

" Improve the syntax highlighting defaults.
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_fields = 1
let g:go_highlight_types = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1

" Automatically fill in and fix the imports section on save.
"let g:go_fmt_command = "goimports"
" When `GoRun` is executed, the default will be to use a horizontal buffer.
let g:go_term_mode = "split"

" Disable concealing behavior (where Markdown link syntax is shorted to just
" the link name.
let g:vim_markdown_folding_disabled = 1
let g:vim_markdown_conceal = 0
let g:tex_conceal = ""
let g:vim_markdown_math = 1

" Enable Rust formatting on save.
let g:rustfmt_autosave = 1
