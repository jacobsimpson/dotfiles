<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>EmacsWiki: icicles-doc1.el</title><link rel="alternate" type="application/wiki" title="Edit this page" href="http://www.emacswiki.org/emacs?action=edit;id=icicles-doc1.el" /><link type="text/css" rel="stylesheet" href="/emacs/wiki.css" /><meta name="robots" content="INDEX,FOLLOW" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki" href="http://www.emacswiki.org/emacs?action=rss" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki: icicles-doc1.el" href="http://www.emacswiki.org/emacs?action=rss;rcidonly=icicles-doc1.el" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content"
      href="http://www.emacswiki.org/emacs/full.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content and diff"
      href="http://www.emacswiki.org/emacs/full-diff.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki including minor differences"
      href="http://www.emacswiki.org/emacs/minor-edits.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Changes for icicles-doc1.el only"
      href="http://www.emacswiki.org/emacs?action=rss;rcidonly=icicles-doc1.el" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2101513-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body class="http://www.emacswiki.org/emacs"><div class="header"><a class="logo" href="http://www.emacswiki.org/emacs/SiteMap"><img class="logo" src="/emacs_logo.png" alt="[Home]" /></a><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span>
<!-- Google CSE Search Box Begins  -->
<form class="tiny" action="http://www.google.com/cse" id="searchbox_004774160799092323420:6-ff2s0o6yi"><p>
<input type="hidden" name="cx" value="004774160799092323420:6-ff2s0o6yi" />
<input type="text" name="q" size="25" />
<input type="submit" name="sa" value="Search" />
</p></form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=searchbox_004774160799092323420%3A6-ff2s0o6yi"></script>
<!-- Google CSE Search Box Ends -->
<h1><a title="Click to search for references to this page" rel="nofollow" href="http://www.google.com/cse?cx=004774160799092323420:6-ff2s0o6yi&amp;q=%22icicles-doc1.el%22">icicles-doc1.el</a></h1></div><div class="wrapper"><div class="content browse"><p class="download"><a href="http://www.emacswiki.org/emacs/download/icicles-doc1.el">Download</a></p><pre class="code"><span class="linecomment">;;; icicles-doc1.el --- Minibuffer input completion and cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Filename: icicles-doc1.el</span>
<span class="linecomment">;; Description: Minibuffer completion and cycling.</span>
<span class="linecomment">;; Author: Drew Adams</span>
<span class="linecomment">;; Maintainer: Drew Adams</span>
<span class="linecomment">;; Copyright (C) 1996-2011, Drew Adams, all rights reserved.</span>
<span class="linecomment">;; Created: Tue Aug  1 14:21:16 1995</span>
<span class="linecomment">;; Version: 22.0</span>
<span class="linecomment">;; Last-Updated: Fri Jun  3 15:18:27 2011 (-0700)</span>
<span class="linecomment">;;           By: dradams</span>
<span class="linecomment">;;     Update #: 26067</span>
<span class="linecomment">;; URL: http://www.emacswiki.org/cgi-bin/wiki/icicles-doc1.el</span>
<span class="linecomment">;; Keywords: internal, extensions, help, abbrev, local, minibuffer,</span>
<span class="linecomment">;;           keys, apropos, completion, matching, regexp, command</span>
<span class="linecomment">;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Features that might be required by this library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   None</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;; Commentary:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles documentation, part 1.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Files `icicles-doc1.el' and `icicles-doc2.el' contain the doc for</span>
<span class="linecomment">;;  Icicles, including how to install and use Icicles.  You can also</span>
<span class="linecomment">;;  read the Icicles doc, in formatted form, on the Emacs-Wiki Web</span>
<span class="linecomment">;;  site: http://www.emacswiki.org/cgi-bin/wiki/Icicles.  Emacs Wiki</span>
<span class="linecomment">;;  also has a few addtional pages about Icicles.  In particular, if</span>
<span class="linecomment">;;  you are new to Emacs, as well as Icicles, see this page:</span>
<span class="linecomment">;;  http://www.emacswiki.org/cgi-bin/wiki/EmacsNewbieWithIcicles.</span>
 
<span class="linecomment">;;(@* "Installing Icicles")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To use this library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Add this to your initialization file (~/.emacs or ~/_emacs):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      (require 'icicles) ; Load this library.</span>
<span class="linecomment">;;      (icicle-mode 1)    ; Turn on Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    It is best to add this code *after* any code that creates or</span>
<span class="linecomment">;;    changes key bindings, so Icicles can pick up all of your key</span>
<span class="linecomment">;;    definitions (bindings).  However, if you make new bindings, you</span>
<span class="linecomment">;;    can always exit and then reenter Icicle mode to pick them up.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You will need all of these libraries (loaded by `icicles.el'):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     `icicles-chg.el'  (not loaded - change logs only)</span>
<span class="linecomment">;;     `icicles-cmd1.el'</span>
<span class="linecomment">;;     `icicles-cmd2.el'</span>
<span class="linecomment">;;     `icicles-doc1.el' (not loaded - doc only)</span>
<span class="linecomment">;;     `icicles-doc2.el' (not loaded - doc only)</span>
<span class="linecomment">;;     `icicles-face.el'</span>
<span class="linecomment">;;     `icicles-fn.el'</span>
<span class="linecomment">;;     `icicles-mac.el'</span>
<span class="linecomment">;;     `icicles-mcmd.el'</span>
<span class="linecomment">;;     `icicles-mode.el'</span>
<span class="linecomment">;;     `icicles-opt.el'</span>
<span class="linecomment">;;     `icicles-var.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The following libraries are recommended but optional (loaded by</span>
<span class="linecomment">;;    `icicles.el' if in your `load-path').  They are enhanced by</span>
<span class="linecomment">;;    Icicles, or Icicles is enhanced by them, or both.  They are all</span>
<span class="linecomment">;;    available at Emacs Wiki,</span>
<span class="linecomment">;;    http://www.emacswiki.org/cgi-bin/wiki/ElispArea.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     `apropos-fn+var.el' - Apropos enhancements for fns and vars.</span>
<span class="linecomment">;;     `bookmark+.el'      - Many bookmark enhancements.</span>
<span class="linecomment">;;     `col-highlight.el'  - Required by `crosshairs.el'.  Emacs 22+</span>
<span class="linecomment">;;     `crosshairs.el'     - Highlight target positions.  Emacs 22+</span>
<span class="linecomment">;;     `doremi.el' and</span>
<span class="linecomment">;;     `doremi-frm.el'     - Incremental changes.</span>
<span class="linecomment">;;     `frame-cmds.el'     - Frame and window commands.</span>
<span class="linecomment">;;     `fuzzy-match.el'    - Fuzzy completion (matching).</span>
<span class="linecomment">;;     `hexrgb.el'         - Color manipulation.</span>
<span class="linecomment">;;     `hl-line+.el'       - Required by `crosshairs.el'.  Emacs 22+</span>
<span class="linecomment">;;     `icomplete+.el'     - Enhancements to `icomplete.el'</span>
<span class="linecomment">;;     `info+.el'          - Enhancements to `info'.</span>
<span class="linecomment">;;     `lacarte.el'        - Keyboard access to the menubar menus.</span>
<span class="linecomment">;;     `mb-depth+.el'      - Minibuffer depth indicator.  Emacs 22+</span>
<span class="linecomment">;;     `pp+.el'            - Pretty-printing for `M-:'.</span>
<span class="linecomment">;;     `synonyms.el'       - A hypertext thesaurus.</span>
<span class="linecomment">;;     `thingatpt+.el'     - Better defaults for commands, `M-.'.</span>
<span class="linecomment">;;     `vline.el'          - Required by `crosshairs.el'.  Emacs 22+</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Be aware that some of these libraries in turn require other</span>
<span class="linecomment">;;    libraries.  For example, library `frame-cmds.el' requires</span>
<span class="linecomment">;;    library `frame-fns.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Depending on your platform, if you use Icicles in a text</span>
<span class="linecomment">;;    terminal (that is, without a window system/manager), then you</span>
<span class="linecomment">;;    might need to change some of the key bindings, if some of the</span>
<span class="linecomment">;;    default bindings are not available to you.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If on your platform, for example, Emacs in a text terminal does</span>
<span class="linecomment">;;    not recognize a key such as `S-TAB' (as something different from</span>
<span class="linecomment">;;    `TAB'), then you will want to change that key binding.  To</span>
<span class="linecomment">;;    customize Icicles key bindings, see</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Customizing Key Bindings").</span>
<span class="linecomment">;;    You might also want to customize some of the Icicles faces,</span>
<span class="linecomment">;;    since a text terminal is sometimes limited in the colors it can</span>
<span class="linecomment">;;    handle.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    It is of course best to byte-compile all of the libraries</span>
<span class="linecomment">;;    (except `icicle-chg.el', `icicles-doc1.el', and</span>
<span class="linecomment">;;    `icicles-doc2.el').  You will likely get some byte-compiler</span>
<span class="linecomment">;;    warning messages.  These are probably benign - ignore them.</span>
<span class="linecomment">;;    Icicles is designed to work with multiple versions of Emacs, and</span>
<span class="linecomment">;;    that fact provokes compiler warnings.  If you get byte-compiler</span>
<span class="linecomment">;;    errors (not warnings), then please report a bug, using `M-x</span>
<span class="linecomment">;;    icicle-send-bug-report'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Whenever you update Icicles (i.e., download new versions of</span>
<span class="linecomment">;;    Icicle source files), I recommend that you do the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      1. Delete all existing byte-compiled Icicles files</span>
<span class="linecomment">;;         (icicles*.elc).</span>
<span class="linecomment">;;      2. Load Icicles (`load-library' or `require').</span>
<span class="linecomment">;;      3. Byte-compile the source files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    In particular, always load `icicles-mac.el' (not</span>
<span class="linecomment">;;    `icicles-mac.elc') before you byte-compile new versions of the</span>
<span class="linecomment">;;    files, in case there have been any changes to Lisp macros (in</span>
<span class="linecomment">;;    `icicles-mac.el').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    After startup, you can turn Icicle mode on or off at any time</span>
<span class="linecomment">;;    interactively, using command `icy-mode' (aka `icicle-mode' -</span>
<span class="linecomment">;;    prefix `icy' is unique to this command, so it is easier to</span>
<span class="linecomment">;;    complete).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: If you turn on Icicle mode in your init file, it's</span>
<span class="linecomment">;;    generally best to do so as late as possible - after you or any</span>
<span class="linecomment">;;    libraries that you load do any key binding.  This is because</span>
<span class="linecomment">;;    Icicles uses the current global key bindings to determine which</span>
<span class="linecomment">;;    keys to bind for minibuffer completion and cycling.  To pick up</span>
<span class="linecomment">;;    the latest bindings at any time, you can of course enter Icicle</span>
<span class="linecomment">;;    mode interactively using command `icy-mode' (if necessary, exit,</span>
<span class="linecomment">;;    then re-enter).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: Icicles redefines some functions when you are in Icicle</span>
<span class="linecomment">;;    mode (it restores them when you leave Icicle mode).  It</span>
<span class="linecomment">;;    generally does not use `defadvice' to alter the functions; it</span>
<span class="linecomment">;;    redefines them instead.  Because of this, there can be</span>
<span class="linecomment">;;    incompatibilities with other libraries that also change the same</span>
<span class="linecomment">;;    functions (using `defadvice' or otherwise).  An example is Viper</span>
<span class="linecomment">;;    mode.  If you load Viper before Icicles, then you will run into</span>
<span class="linecomment">;;    problems with function `read-file-name' because it is tweaked by</span>
<span class="linecomment">;;    both Viper and Icicles.  If you load Icicles before Viper, you</span>
<span class="linecomment">;;    should not encounter this problem (but you might encounter other</span>
<span class="linecomment">;;    problems: both Icicles and Viper try to control the minibuffer).</span>
 
<span class="linecomment">;;(@* "Index")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Index</span>
<span class="linecomment">;;  -----</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you have library `linkd.el' and Emacs 22 or later, load</span>
<span class="linecomment">;;  `linkd.el' and turn on `linkd-mode' now.  It lets you easily</span>
<span class="linecomment">;;  navigate around the sections of this doc.  Linkd mode will</span>
<span class="linecomment">;;  highlight this Index and render it more readable.  Likewise, for</span>
<span class="linecomment">;;  the cross-references and section headings throughout this file.</span>
<span class="linecomment">;;  You can get `linkd.el' here:</span>
<span class="linecomment">;;  http://www.emacswiki.org/cgi-bin/wiki/linkd.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@* "Documentation in File `icicles-doc1.el'")</span>
<span class="linecomment">;;  ----------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Nutshell View of Icicles")</span>
<span class="linecomment">;;    (@&gt; "README for NON-Readers")</span>
<span class="linecomment">;;    (@&gt; "README")</span>
<span class="linecomment">;;    (@&gt; "Toggle Options on the Fly")</span>
<span class="linecomment">;;    (@&gt; "Cycle Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Display Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Prefix Completion and Apropos Completion")</span>
<span class="linecomment">;;    (@&gt; "Chains of Simple Match Patterns - Progressive Completion")</span>
<span class="linecomment">;;    (@&gt; "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;    (@&gt; "Choose Before You Act")</span>
<span class="linecomment">;;    (@&gt; "Help on Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Perform Multiple Operations in One Command")</span>
<span class="linecomment">;;    (@&gt; "Perform Alternative Operations on the Fly")</span>
<span class="linecomment">;;    (@&gt; "Completion Status Indicators")</span>
<span class="linecomment">;;    (@&gt; "Icicles Search")</span>
<span class="linecomment">;;    (@&gt; "Complete Key Sequences Too")</span>
<span class="linecomment">;;    (@&gt; "Available for Almost Any Input")</span>
<span class="linecomment">;;    (@&gt; "Component Icicles Libraries")</span>
<span class="linecomment">;;    (@&gt; "If You Are an Emacs-Lisp Programmer")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Inserting Text Found Near the Cursor")</span>
<span class="linecomment">;;  (@&gt; "Background on Vanilla Emacs Input Completion")</span>
<span class="linecomment">;;  (@&gt; "Cycling Completions")</span>
<span class="linecomment">;;  (@&gt; "Traversing Minibuffer Histories")</span>
<span class="linecomment">;;  (@&gt; "Apropos Completions")</span>
<span class="linecomment">;;  (@&gt; "Expanded-Common-Match Completion")</span>
<span class="linecomment">;;  (@&gt; "Progressive Completion")</span>
<span class="linecomment">;;    (@&gt; "`M-*': Matching Additional Regexps")</span>
<span class="linecomment">;;    (@&gt; "Successive Approximation...")</span>
<span class="linecomment">;;    (@&gt; "`M-&': Satisfying Additional Predicates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Regressive Completion")</span>
<span class="linecomment">;;  (@&gt; "Completion On Demand")</span>
<span class="linecomment">;;  (@&gt; "Moving Between the Minibuffer and Other Buffers")</span>
<span class="linecomment">;;  (@&gt; "Inserting a Regexp from a Variable or Register")</span>
<span class="linecomment">;;  (@&gt; "Special Characters in Input Patterns")</span>
<span class="linecomment">;;  (@&gt; "Exiting the Minibuffer Without Confirmation")</span>
<span class="linecomment">;;  (@&gt; "Ido and IswitchB")</span>
<span class="linecomment">;;  (@&gt; "*Completions* Display")</span>
<span class="linecomment">;;  (@&gt; "Icompletion")</span>
<span class="linecomment">;;    (@&gt; "icomplete+.el Displays the Number of Other Prefix Candidates")</span>
<span class="linecomment">;;    (@&gt; "Icicles Highlights the Input that Won't Complete")</span>
<span class="linecomment">;;    (@&gt; "Icompletion in *Completions*: Apropos and Prefix Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;    (@&gt; "Changing the Sort Order")</span>
<span class="linecomment">;;    (@&gt; "Defining New Sort Orders")</span>
<span class="linecomment">;;    (@&gt; "Different Sorts for Different Sorts of Uses")</span>
<span class="linecomment">;;  (@&gt; "Get Help on Candidates")</span>
<span class="linecomment">;;    (@&gt; "Use Candidate Help Like You Use Emacs Command `apropos'")</span>
<span class="linecomment">;;    (@&gt; "Other Icicles Apropos Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Multi-Commands")</span>
<span class="linecomment">;;    (@&gt; "What Is a Multi-Command?")</span>
<span class="linecomment">;;    (@&gt; "How Does a Multi-Command Work?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "More about Multi-Commands")</span>
<span class="linecomment">;;    (@&gt; "Alternative Actions")</span>
<span class="linecomment">;;    (@&gt; "Deleting Objects")</span>
<span class="linecomment">;;    (@* "Option `icicle-use-C-for-actions-flag'")</span>
<span class="linecomment">;;    (@* "Accessing Saved Locations (Bookmarks) on the Fly")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Tripping")</span>
<span class="linecomment">;;    (@&gt; "Highlighting the Destination")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Key Completion")</span>
<span class="linecomment">;;    (@&gt; "Completing Keys")</span>
<span class="linecomment">;;    (@&gt; "`S-TAB' Is Everywhere - Start With It")</span>
<span class="linecomment">;;    (@&gt; "Completing Keys By Name")</span>
<span class="linecomment">;;    (@&gt; "Completing Prefix Keys")</span>
<span class="linecomment">;;    (@&gt; "Meta Key Bindings")</span>
<span class="linecomment">;;    (@&gt; "Navigate the Key-Binding Hierarchy")</span>
<span class="linecomment">;;    (@&gt; "Local Bindings Are Highlighted")</span>
<span class="linecomment">;;    (@&gt; "Completing Keys By Just Hitting Them")</span>
<span class="linecomment">;;    (@&gt; "Key and Command Help")</span>
<span class="linecomment">;;    (@&gt; "`S-TAB' Is a Multi-Command")</span>
<span class="linecomment">;;    (@&gt; "Possible Source of Confusion")</span>
<span class="linecomment">;;    (@&gt; "Three-Key Emacs")</span>
<span class="linecomment">;;    (@&gt; "Entering Special and Foreign Characters")</span>
<span class="linecomment">;;    (@&gt; "Handling Keymaps That Are Inaccessible From the Global Map")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Multi `M-x'")</span>
<span class="linecomment">;;    (@&gt; "Examples of Using Multi `M-x'")</span>
<span class="linecomment">;;      (@&gt; "What about describe-variable and describe-function?")</span>
<span class="linecomment">;;    (@&gt; "Multi `M-x' Turns Every Command into a Multi-Command")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Choose All Completion Candidates")</span>
<span class="linecomment">;;  (@&gt; "Sets of Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Saving and Retrieving Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Different Places for Saving and Retrieving Candidates")</span>
<span class="linecomment">;;    (@&gt; "Set Operations")</span>
<span class="linecomment">;;  (@&gt; "Google Matching")</span>
<span class="linecomment">;;    (@&gt; "Domain of Discourse")</span>
<span class="linecomment">;;    (@&gt; "Global Filtering")</span>
<span class="linecomment">;;    (@&gt; "Word Matching and String Matching")</span>
<span class="linecomment">;;    (@&gt; "AND Matching and OR Matching")</span>
<span class="linecomment">;;    (@&gt; "NOT Matching")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Buffer-Name Input")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;    (@&gt; "Function `read-file-name'")</span>
<span class="linecomment">;;    (@&gt; "Function `completing-read'")</span>
<span class="linecomment">;;    (@&gt; "Icicles Commands that Read File Names")</span>
<span class="linecomment">;;    (@&gt; "Absolute File Names and Different Directories")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Saving Candidates in Cache Files")</span>
<span class="linecomment">;;    (@&gt; "Filesets and Icicles Saved Completion Sets")</span>
<span class="linecomment">;;    (@&gt; "Improving Performance with Persistent Sets")</span>
<span class="linecomment">;;      (@&gt; "Avoid Remote File-Name Completion")</span>
<span class="linecomment">;;      (@&gt; "Avoid Generating A Large Completion Set")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;  (@&gt; "History Enhancements")</span>
<span class="linecomment">;;    (@&gt; "What Input, What History?")</span>
<span class="linecomment">;;    (@&gt; "Overview of Minibuffer History Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Using Completion to Insert Previous Inputs: `M-o'")</span>
<span class="linecomment">;;    (@&gt; "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;    (@&gt; "Matching Only Historical Candidates: `M-h' and `M-pause'")</span>
<span class="linecomment">;;    (@&gt; "Using Other Histories; Commands Any Which Way")</span>
<span class="linecomment">;;      (@&gt; "Completing Against All Interactive Commands")</span>
<span class="linecomment">;;      (@&gt; "Using an Alternative History")</span>
<span class="linecomment">;;    (@&gt; "Cleaning Up History Lists")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Isearch Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Launch Occur using the Isearch Search String")</span>
<span class="linecomment">;;    (@&gt; "Launch Icicles Search using the Isearch Search String")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Documentation in File `icicles-doc2.el'")</span>
<span class="linecomment">;;  -----------------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Introduction: On Beyond Occur...")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "How Icicles Search Works")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Why Use 2 Search Patterns?")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Search Multiple Buffers, Files, and Bookmarks")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "User Options for Icicles Searching")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Regexps with Icicles Search")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Search and Replace")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Other Icicles Search Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Imenu")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "`icicle-imenu' Combines Benefits of Imenu and Emacs Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Compile/Grep Search")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Input Reuse in Interactive Interpreter Modes")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Define Your Own Icicles Search Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Bookmark Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Saving Regions and Selecting Them")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Setting a Bookmark and Jumping to a Bookmark")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Jumping to a Bookmark")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Searching Bookmarked Objects")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Enhancements for Emacs Tags")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "`icicle-find-tag': Find Tags in All Tags Tables")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "`icicle-find-first-tag': Find First Tag in Current Table")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "`icicle-tags-search': Search and Replace Using Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Shell-Command Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Shell Command Completion as File-Name Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Gotcha: `$' in Shell Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Known Shell Commands as Proxy Candidates")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Search-and-Replace Marked Files")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Save Marked Files as Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Open Dired for a Set of File Names")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Marked Files as a Project")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Shell Commands on Marked Files")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Info Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Completion for Info")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Virtual Info Books")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Icicle-Search With Info")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Support for Projects")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Bookmarks for Project Access and Organization")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "A Tags File Can Define a Project")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Navigating Among Code Definitions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Searching Project Files")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Defining and Saving Sets of Files or Buffers")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Retrieving and Reusing a Saved Project")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Semantics? Roll Your Own?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Using Complex Completion Candidates")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Apropos Completion as OO")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "M-RET")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "`icicle-object-action' and `icicle-anything'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles with Anything")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Multi-Completions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Multi-Completion Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "How Multi-Completions Work")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Multi-Completions vs `completing-read-multiple'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Dot, Dot, Dot")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Fuzzy Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Partial Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Scatter-Match Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Swank (Fuzzy Symbol) Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Fuzzy-Match Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Levenshtein Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Jaro-Winkler Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Completion in Other Buffers")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Dynamic Abbreviation")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "BBDB Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Thesaurus Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Completion in Comint Modes")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Customization and General Tips")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Icicles with Delete Selection Mode")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles User Options and Faces")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "File-Name and Directory-Name Completion Tips")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Key Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Global Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles-Mode Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Minibuffer Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Customizing Key Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Customizing Global Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Customizing Icicle Mode Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Customizing Minibuffer Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Redefines Some Standard Functions")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Programming with Fancy Candidates")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Programming Multi-Completions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Variable icicle-list-use-nth-parts")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Variable icicle-candidate-properties-alist")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "What You See Is Not What You Get")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Candidates with Text Properties")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Property icicle-special-candidate")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Applying Text Properties to a Candidate String")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Nothing To It!")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Multi-Commands Are Easy To Define Too")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Are Users Dependent on Icicles To Use Multi-Commands?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Icicles Tripping Commands")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Multiple-Choice Menus")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Icicles Multi `M-x'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "How Multi `M-x' is Defined")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Global Filters")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Specifying Match Functions for Commands")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Buffer-Text Completion for Comint Modes")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Note to Programmers")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "La Petite Histoire")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Note on Non-`nil' `pop-up-frames' on MS Windows")</span>
 
<span class="linecomment">;;(@* "Nutshell View of Icicles")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nutshell View of Icicles</span>
<span class="linecomment">;;  ------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "README for NON-Readers")</span>
<span class="linecomment">;;  ** README for NON-Readers **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Load library `icicles.el', turn on Icicle mode, and you're good to</span>
<span class="linecomment">;;  go.  You can turn Icicle mode off or on at any time with command</span>
<span class="linecomment">;;  `icy-mode'.  When you turn it off, you're back in vanilla Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Beyond that, the most important thing to know about Icicles is</span>
<span class="linecomment">;;  that you can get help on Icicle mode during minibuffer input.  You</span>
<span class="linecomment">;;  do that either by using item Help of the menu-bar Icicles menu or</span>
<span class="linecomment">;;  Minibuf menu, or by hitting `C-?' (`icicle-minibuffer-help').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You now know enough to use Icicles.  If you have doc-phobia or are</span>
<span class="linecomment">;;  easily overwhelmed by explanations, then *read no more* - just try</span>
<span class="linecomment">;;  it!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you want a little more explanation than the help page (`C-?'),</span>
<span class="linecomment">;;  then read the rest of section (@&gt; "Nutshell View of Icicles"), but</span>
<span class="linecomment">;;  no more.  It shows a sample of what you can do in Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you want to know more about Icicles by reading instead of just</span>
<span class="linecomment">;;  trying, then read beyond section (@&gt; "Nutshell View of Icicles").</span>
<span class="linecomment">;;  There is a lot you can learn, but there is not much that you need</span>
<span class="linecomment">;;  to learn, to use Icicles usefully.  Do not be afraid to get in and</span>
<span class="linecomment">;;  get wet.  Above all, do not be overwhelmed by the doc - if it</span>
<span class="linecomment">;;  helps, fine.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One good way to start is to explore menus `Icicles' and `Minibuf';</span>
<span class="linecomment">;;  you can access most Icicles features using these menus, without at</span>
<span class="linecomment">;;  the same time struggling to learn new key bindings.  The `Icicles'</span>
<span class="linecomment">;;  menu is available all of the time (that is, whenever you are in</span>
<span class="linecomment">;;  Icicle mode), and the `Minibuf' menu is available whenever the</span>
<span class="linecomment">;;  minibuffer is active.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During minibuffer input completion, you can also press Control and</span>
<span class="linecomment">;;  right-click (`C-mouse-3') on a completion candidate in buffer</span>
<span class="linecomment">;;  `*Completions*', and choose from a contextual popup menu,</span>
<span class="linecomment">;;  `Completion'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can customize this menu.  By default, submenu `This Candidate'</span>
<span class="linecomment">;;  has menu items that apply to the candidate you clicked to pop up</span>
<span class="linecomment">;;  the menu.  The other submenus have items that apply to all</span>
<span class="linecomment">;;  candidates, candidates you have selected (the region in</span>
<span class="linecomment">;;  `*Completions*'), or candidates you have saved (marked).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Altogether there are many menu items in the popup menu.  Think of</span>
<span class="linecomment">;;  the menu as a learning device and a way to remind you of possible</span>
<span class="linecomment">;;  operations on completion candidates and the keys they are bound</span>
<span class="linecomment">;;  to.  In this it is similar to the help you get when you use `C-?'</span>
<span class="linecomment">;;  in the minibuffer, but with the menu you can also act, not just be</span>
<span class="linecomment">;;  reminded.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "*Completions* Display").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "README")</span>
<span class="linecomment">;;  ** README **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances minibuffer completion.  It does so generally,</span>
<span class="linecomment">;;  throughout Emacs.  It does this by improving the basic Emacs</span>
<span class="linecomment">;;  functions that read minibuffer input with completion:</span>
<span class="linecomment">;;  `completing-read', `read-file-name', and `read-from-minibuffer'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This means that Icicles affects every kind of minibuffer</span>
<span class="linecomment">;;  completion, not just buffers or files or commands or variables or</span>
<span class="linecomment">;;  faces or...  Every kind.  (You can even complete key sequences.)</span>
<span class="linecomment">;;  Lisp code need not call a special completion function to get this</span>
<span class="linecomment">;;  advantage - each call to `completing-read' etc. benefits</span>
<span class="linecomment">;;  automatically.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles has this effect only when you are in Icicle minor mode.</span>
<span class="linecomment">;;  Turn off Icicle mode and Emacs behaves as usual (vanilla).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To best understand what Icicles offers you, you need to think a</span>
<span class="linecomment">;;  bit differently about minibuffer completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During (vanilla) Emacs completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  v1. You type some input.  Then you ask Emacs (`TAB') to look for a</span>
<span class="linecomment">;;      match of your input against the domain of input possibilities:</span>
<span class="linecomment">;;      the completion candidates.  If a match is found, your input is</span>
<span class="linecomment">;;      completed and you hit `RET' to accept it (commit it as your</span>
<span class="linecomment">;;      final input).  If there are several matches you type some more</span>
<span class="linecomment">;;      text and recomplete ... until there is only one match.  Then</span>
<span class="linecomment">;;      you hit `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  v2. The goal here is to complete and then enter your input, as</span>
<span class="linecomment">;;      easily and rapidly as possible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  v3. The process starts with a domain of possible inputs: the</span>
<span class="linecomment">;;      initial set of candidates.  This domain can be realized</span>
<span class="linecomment">;;      intensionally, via a function, or more commonly extensionally,</span>
<span class="linecomment">;;      via an explicit set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  v4. Sometimes completion is "lax" instead of "strict", meaning</span>
<span class="linecomment">;;      that you can input any text you like in the end (`RET'), but a</span>
<span class="linecomment">;;      set of candidates is still provided for the convenience of</span>
<span class="linecomment">;;      completion (`TAB').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  v5. When you hit `TAB' to complete, your current input in the</span>
<span class="linecomment">;;      minibuffer (the contents) filters the domain, narrowing it</span>
<span class="linecomment">;;      down to the set of matching candidates, which is shown in</span>
<span class="linecomment">;;      buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Background on Vanilla Emacs Input Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For Icicles it is the completion *process* that is important, and</span>
<span class="linecomment">;;  this process can serve several goals.  So instead of focusing on</span>
<span class="linecomment">;;  the goal of entering a final input (v2), let's consider the</span>
<span class="linecomment">;;  overall process: There is a set (domain) of possible candidates</span>
<span class="linecomment">;;  (v3) that you filter with your input (v1).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you edit your input and recomplete using `TAB', then the domain</span>
<span class="linecomment">;;  is refiltered to a different set of matching completion</span>
<span class="linecomment">;;  candidates.  Each time you do this your input corresponds to a</span>
<span class="linecomment">;;  different set.  The process of completion thus provides a great</span>
<span class="linecomment">;;  way to filter a set interactively.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Now if all you do in the minibuffer at the end of the day is enter</span>
<span class="linecomment">;;  your final input (`RET'), then changing your input and</span>
<span class="linecomment">;;  recompleting (`TAB') is pretty much a waste of time, a detour.</span>
<span class="linecomment">;;  But if you can do more along the way, if you can make use of the</span>
<span class="linecomment">;;  current set of matches in some way, then the story is different.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is the key to understanding what Icicles offers.  Think of</span>
<span class="linecomment">;;  minibuffer completion as a pattern-matching user interface, a</span>
<span class="linecomment">;;  general way to interact with sets of named objects.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  No doubt you have already used completion sometimes as more than</span>
<span class="linecomment">;;  just a means toward the end of inputting a value.  Perhaps you</span>
<span class="linecomment">;;  have used `TAB' during file-name completion to take a look at the</span>
<span class="linecomment">;;  nearby directory structure, possibly even finishing with `C-g'</span>
<span class="linecomment">;;  instead of entering any file name definitively (`RET').  In that</span>
<span class="linecomment">;;  scenario, you are exploring the set of file-name candidates, using</span>
<span class="linecomment">;;  minibuffer completion as a help feature.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles binds different keys in the minibuffer keymaps to provide</span>
<span class="linecomment">;;  different ways to interact with the current set of matches</span>
<span class="linecomment">;;  (completion candidates).  To exploit the possibilities of</span>
<span class="linecomment">;;  filtering a set dynamically by pattern matching, Icicles provides</span>
<span class="linecomment">;;  different features that work together.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These are the most important Icicles features:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  i1. Incremental completion.  By default, each change you make to</span>
<span class="linecomment">;;      your minibuffer input automatically rematches and recompletes</span>
<span class="linecomment">;;      it (v5).  IOW, the set of current candidates is updated</span>
<span class="linecomment">;;      dynamically, incrementally.  You can always see (in the</span>
<span class="linecomment">;;      `*Completions*' window) what your current input (the</span>
<span class="linecomment">;;      minibuffer content) matches.  This is a help and exploration</span>
<span class="linecomment">;;      feature.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  i2. Cycling and the current candidate.  You can cycle among the</span>
<span class="linecomment">;;      current set of candidates (minibuffer matches).  The current</span>
<span class="linecomment">;;      candidate is placed in the minibuffer as you do this, for</span>
<span class="linecomment">;;      possible editing.  You can of course hit `RET' to commit the</span>
<span class="linecomment">;;      current candidate, edited or not, as your final input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  i3. Help, multiple actions, alternative actions.  But you can also</span>
<span class="linecomment">;;      instead hit a key to provide information (help) about the</span>
<span class="linecomment">;;      current candidate; hit a key to act on it (accept it as input</span>
<span class="linecomment">;;      but without ending the minibuffer); hit a key to perform some</span>
<span class="linecomment">;;      alternative action on it (without ending the minibuffer); and</span>
<span class="linecomment">;;      so on.  Candidate help is perhaps the Icicles feature used</span>
<span class="linecomment">;;      most often.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  i4. Multi-commands.  A command that lets you act on a candidate</span>
<span class="linecomment">;;      without ending the minibuffer, so that you can thus act on</span>
<span class="linecomment">;;      several candidates, is called a "multi-command".  Not every</span>
<span class="linecomment">;;      command is a multi-command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  i5. Set operations.  You can hit a key to act not on any</span>
<span class="linecomment">;;      particular matching candidate but on each of them individually</span>
<span class="linecomment">;;      or on all of them collectively.  Among the collective set</span>
<span class="linecomment">;;      operations are union, intersection, difference/complementing,</span>
<span class="linecomment">;;      and saving for later reuse.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  i6. Progressive completion.  Set intersection can take a couple of</span>
<span class="linecomment">;;      forms.  The most useful is "progressive completion": use the</span>
<span class="linecomment">;;      current set of matching candidates as the domain for a</span>
<span class="linecomment">;;      recursive minibuffer.  That is, start over and match different</span>
<span class="linecomment">;;      inputs against a subset of the original domain that was</span>
<span class="linecomment">;;      defined by the previous matching operation.  This is analogous</span>
<span class="linecomment">;;      to piping `grep' outputs through additional `grep' filters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  i7. More powerful matching.  Using your input (minibuffer content)</span>
<span class="linecomment">;;      as a dynamic filter is very important in Icicles.  In line</span>
<span class="linecomment">;;      with this, you can employ different matching methods.  The</span>
<span class="linecomment">;;      most powerful is regexp matching (which includes substring</span>
<span class="linecomment">;;      matching).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  i8. Candidate sorting.  You can sort the current candidates on the</span>
<span class="linecomment">;;      fly in different ways, so that you can cycle them in different</span>
<span class="linecomment">;;      orders.  The possible sort orders at any time depend on the</span>
<span class="linecomment">;;      context and type of candidates.  You can define your own sort</span>
<span class="linecomment">;;      orders.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most of these features are unique to Icicles.  Others were</span>
<span class="linecomment">;;  original with Icicles but have since been copied by vanilla Emacs</span>
<span class="linecomment">;;  or other libraries.  But only Icicles offers these features (and</span>
<span class="linecomment">;;  more) together, combining them cooperatively.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles is very general.  It affects many aspects of minibuffer</span>
<span class="linecomment">;;  completion.  As you learn to take advantage of its features it can</span>
<span class="linecomment">;;  change how you use Emacs.  But Icicles also stays out of the way</span>
<span class="linecomment">;;  if you do not ask for its help.  If you just use `TAB' completion</span>
<span class="linecomment">;;  and you use none of the keys bound specially during completion</span>
<span class="linecomment">;;  (for cycling, progressive completion, etc.), then you will hardly</span>
<span class="linecomment">;;  notice Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All Lisp code that uses minibuffer completion automatically takes</span>
<span class="linecomment">;;  advantage of Icicles.  But some other libraries go beyond this by</span>
<span class="linecomment">;;  defining Icicles multi-commands or otherwise making some special</span>
<span class="linecomment">;;  use of Icicles features.  None of these libraries are required in</span>
<span class="linecomment">;;  order to use Icicles, but they are recommended because of the</span>
<span class="linecomment">;;  synergy they provide.  See (@&gt; "Installing Icicles").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Toggle Options on the Fly")</span>
<span class="linecomment">;;  ** Toggle Options on the Fly **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many user options that affect the behavior of Icicles</span>
<span class="linecomment">;;  features.  Some of these are Boolean (on/off) or allow for simple</span>
<span class="linecomment">;;  alternation or cycling of the possible values.  Many of those</span>
<span class="linecomment">;;  options are associated with toggle commands that are bound to keys</span>
<span class="linecomment">;;  whenever the minibuffer is active, or at least active for</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Throughout this doc you will see references to such options and</span>
<span class="linecomment">;;  their toggles.  For example: "You can toggle case-sensitivity at</span>
<span class="linecomment">;;  any time using `C-A' (that is, `C-S-a') in the minibuffer."</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The reason for making it so easy to change the values of these</span>
<span class="linecomment">;;  options on the fly is that different kinds of completion, in</span>
<span class="linecomment">;;  different contexts, can take advantage of different option values.</span>
<span class="linecomment">;;  Icicles completion is very general, and a single option value is</span>
<span class="linecomment">;;  not always optimal for all contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You will become acquainted with a few of these toggle keys and</span>
<span class="linecomment">;;  remember them, but you will forget others.  What is important to</span>
<span class="linecomment">;;  point out here is that `C-?'  (`icicle-minibuffer-help') is your</span>
<span class="linecomment">;;  friend in the minibuffer.  During completion, the help it displays</span>
<span class="linecomment">;;  includes, near the top, a list of the toggle keys and the</span>
<span class="linecomment">;;  corresponding current values of their options.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever you use an Icicles toggle command, a momentary message</span>
<span class="linecomment">;;  shows you the new option value.  So as an alternative to using</span>
<span class="linecomment">;;  `C-?' to see the current value of an option, you can just toggle</span>
<span class="linecomment">;;  it twice.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Cycle Completion Candidates")</span>
<span class="linecomment">;;  ** Cycle Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x  t o o l  next</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, type "tool" and then hit the `next' key, which is often</span>
<span class="linecomment">;;  labeled "Page Down".  Each time you hit `next', another match for</span>
<span class="linecomment">;;  your input (`tool') replaces it in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x ediff-toggle-use-toolbar  next</span>
<span class="linecomment">;;   M-x scroll-bar-toolkit-scroll next</span>
<span class="linecomment">;;   M-x tool-bar-mode             next</span>
<span class="linecomment">;;   M-x tooltip-mode              next</span>
<span class="linecomment">;;   M-x ediff-toggle-use-toolbar ; Back to the beginning</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keys `next' and `prior' ("Page Up") cycle among all of the</span>
<span class="linecomment">;;  commands that contain (match) the minibuffer input - `tool', in</span>
<span class="linecomment">;;  this case.  Just hit `RET' (Return) when you get to the command</span>
<span class="linecomment">;;  you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (Note: The particular candidates shown here and in other examples</span>
<span class="linecomment">;;  might be different from what you see, depending on your version of</span>
<span class="linecomment">;;  Emacs and what other libraries you might have loaded.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use a regular expression, to narrow the field of matching</span>
<span class="linecomment">;;  inputs:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x  i s e . + c h a r          next</span>
<span class="linecomment">;;   M-x isearch-delete-char         next</span>
<span class="linecomment">;;   M-x isearch-other-control-char  next</span>
<span class="linecomment">;;   ...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that when you cycle, a one-line description of the current</span>
<span class="linecomment">;;  candidate is shown in the mode line (of buffer `*Completions*' if</span>
<span class="linecomment">;;  visible; otherwise of the current buffer).  You can get more</span>
<span class="linecomment">;;  detailed info about individual candidates by holding the Control</span>
<span class="linecomment">;;  and Meta keys (e.g. `C-M-next') while you cycle - see</span>
<span class="linecomment">;;  (@&gt; "*Completions* Display") and (@&gt; "Help on Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Try cycling candidates for `C-h v' for instance, using `next'.</span>
<span class="linecomment">;;  Look for their descriptions in the mode line.  Now try cycling</span>
<span class="linecomment">;;  using `C-M-next' - complete candidate help is shown in buffer</span>
<span class="linecomment">;;  `*Help*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Cycling Completions") for more about cycling completion</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Display Completion Candidates")</span>
<span class="linecomment">;;  ** Display Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can display all of the matches for the current minibuffer</span>
<span class="linecomment">;;  input, in the `*Completions*' buffer, using `S-TAB' (Shift TAB).</span>
<span class="linecomment">;;  So, for instance, `S-TAB' with `M-x ise.+char' in the minibuffer</span>
<span class="linecomment">;;  displays all commands whose names contain `ise' followed</span>
<span class="linecomment">;;  (somewhere) by `char'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "*Completions* Display") for more about using the</span>
<span class="linecomment">;;  `*Completions*' window.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Prefix Completion and Apropos Completion")</span>
<span class="linecomment">;;  ** Prefix Completion and Apropos Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can get the standard Emacs "prefix" completion, instead of the</span>
<span class="linecomment">;;  "apropos" completion just described, by using `TAB' instead of</span>
<span class="linecomment">;;  `S-TAB'.  You can cycle prefix-completion candidates by using the</span>
<span class="linecomment">;;  `end' and `home' keys instead of `next' and `prior'.  (All four of</span>
<span class="linecomment">;;  these keys are typically together in a central keypad to the right</span>
<span class="linecomment">;;  of the main keyboard.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also cycle candidates according to the current completion</span>
<span class="linecomment">;;  mode, prefix or apropos, using either the mouse wheel or the arrow</span>
<span class="linecomment">;;  keys `down' and `up'.  These are all called the "modal" cycling</span>
<span class="linecomment">;;  keys because they respect the current completion mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The current completion mode is determined by the last completion</span>
<span class="linecomment">;;  key you used, `TAB' or `S-TAB'.  If you have not used either so</span>
<span class="linecomment">;;  far during the current minibuffer invocation, then the modal keys</span>
<span class="linecomment">;;  cycle according to the value of option</span>
<span class="linecomment">;;  `icicle-default-cycling-mode'.  By default the option value is</span>
<span class="linecomment">;;  `prefix', which means that you can use `down', `up', or the mouse</span>
<span class="linecomment">;;  wheel to cycle prefix completions without needing to first hit</span>
<span class="linecomment">;;  `TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The non-modal cycling keys, `next', `prior', `end', and `home'</span>
<span class="linecomment">;;  automatically set the completion mode and update the candidate</span>
<span class="linecomment">;;  completions.  The modal cycling keys just cycle according to the</span>
<span class="linecomment">;;  current completion mode, whether it is apropos or prefix.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To cycle using the mouse wheel, the mouse must not be over the</span>
<span class="linecomment">;;  `*Completions*' window; if it is, then the wheel scrolls that</span>
<span class="linecomment">;;  window instead of cycling candidates - see (@&gt; "*Completions* Display").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an alternative to using `end' or `next', you can cycle</span>
<span class="linecomment">;;  candidates downward (forward) by just repeating the same</span>
<span class="linecomment">;;  completion key: `TAB' or `S-TAB'.  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x tool           TAB ; Display candidates with prefix `tool'</span>
<span class="linecomment">;;   M-x tool-bar-mode  TAB</span>
<span class="linecomment">;;   M-x tooltip-mode   TAB</span>
<span class="linecomment">;;   M-x tool-bar-mode      ; Back to the beginning</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Or:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-x tool                      S-TAB ; Display matching candidates</span>
<span class="linecomment">;;   M-x ediff-toggle-use-toolbar  S-TAB</span>
<span class="linecomment">;;   M-x scroll-bar-toolkit-scroll S-TAB</span>
<span class="linecomment">;;   M-x tool-bar-mode             S-TAB</span>
<span class="linecomment">;;   M-x tooltip-mode              S-TAB</span>
<span class="linecomment">;;   M-x ediff-toggle-use-toolbar        ; Back to the beginning</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Changing to a different completion key (`TAB' to `S-TAB' or vice</span>
<span class="linecomment">;;  versa) always switches completion type and completes, but you can</span>
<span class="linecomment">;;  then repeat that new completion key to cycle among the candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: In vanilla Emacs, repeating `TAB' scrolls the</span>
<span class="linecomment">;;  `*Completions*' window.  In Icicles, you can use `C-v' to scroll</span>
<span class="linecomment">;;  `*Completions*' down and `M-v' to scroll up.  You can also use the</span>
<span class="linecomment">;;  mouse wheel to scroll `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Apropos Completions") for more about apropos and prefix</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Chains of Simple Match Patterns - Progressive Completion")</span>
<span class="linecomment">;;  ** Chains of Simple Match Patterns - Progressive Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To see which functions contain `char', `delete', and `back' in</span>
<span class="linecomment">;;  their names, in any order:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   C-h f  c h a r  S-TAB - Display all function names that contain</span>
<span class="linecomment">;;   `char'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-*  d e l e t e  - Narrow that set of names to those that also</span>
<span class="linecomment">;;   contain `delete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   M-*  b a c k  - Narrow the set of matching names further, to</span>
<span class="linecomment">;;   those that also contain `back'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This displays a list of functions like this in buffer</span>
<span class="linecomment">;;  `*Completions*' (your list might be somewhat different):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    backward-delete-char        backward-delete-char-untabify</span>
<span class="linecomment">;;    delete-backward-char        icicle-backward-delete-char-untabify</span>
<span class="linecomment">;;    icicle-delete-backward-char</span>
<span class="linecomment">;;    quail-conversion-backward-delete-char</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Since you are completing input to `C-h f', you can then cycle to a</span>
<span class="linecomment">;;  name using `next' and hit `RET', or click `mouse-2', to see the</span>
<span class="linecomment">;;  doc for that function.  If, instead, you were completing input to</span>
<span class="linecomment">;;  `M-x', you could choose a command to execute.  And so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The thing to notice here is that you can use `M-*' to input chains</span>
<span class="linecomment">;;  of multiple simple regexps, to narrow down the set of completion</span>
<span class="linecomment">;;  candidates progressively.  This is analogous to piping the result</span>
<span class="linecomment">;;  of `grep' to another `grep', and piping that result to another</span>
<span class="linecomment">;;  `grep'...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are a couple others to try (I'm always forgetting the order</span>
<span class="linecomment">;;  in these compound names):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   C-h f  w i n d o w  S-TAB M-*  f r a m e</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   C-h f  w i n d o w  S-TAB M-*  b u f f e r</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, you can use just `S-SPC' instead of `S-TAB M-*'.</span>
<span class="linecomment">;;  See (@&gt; "Progressive Completion") for more about progressive</span>
<span class="linecomment">;;  completion with `M-*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;  ** Chip Away the Non-Elephant **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There's a joke about a sculptor who, when asked how he created</span>
<span class="linecomment">;;  such a life-like statue of an elephant, said that he just chipped</span>
<span class="linecomment">;;  steadily away, removing marble that did not resemble an elephant.</span>
<span class="linecomment">;;  (Actually, Michelangelo supposedly said something similar.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you sculpt this way too - it is in fact a common</span>
<span class="linecomment">;;  Icicles usage idiom.  There are two ways to say, "I do not want</span>
<span class="linecomment">;;  that" when it comes to possible completions:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The `delete' key or `S-mouse-2' says, "Get rid of this</span>
<span class="linecomment">;;    completion candidate."</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-~' says "I want all possible completions *except* those that</span>
<span class="linecomment">;;    are the current matches."  That is, "Remove all of this, and let</span>
<span class="linecomment">;;    me see what's left."  `C-~' takes the complement of the current</span>
<span class="linecomment">;;    set of matches, using the initial set of possible candidates as</span>
<span class="linecomment">;;    the universe of discourse.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In other words, instead of coming up with input that you want a</span>
<span class="linecomment">;;  completion to match, get rid of one or all of the candidates that</span>
<span class="linecomment">;;  do match.  You can keep clicking `mouse-2' while holding Shift, or</span>
<span class="linecomment">;;  keep hitting `delete' (without Shift), to chip away at the set of</span>
<span class="linecomment">;;  possible completions.  If there are several candidates in a row</span>
<span class="linecomment">;;  that you want to eliminate, just hold down the `delete' key until</span>
<span class="linecomment">;;  they're gone.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So that you can use `delete' this way to delete candidates one</span>
<span class="linecomment">;;  after the other, in order, the next candidate is chosen each time</span>
<span class="linecomment">;;  you delete one.  This means that it becomes the current candidate</span>
<span class="linecomment">;;  in the minibuffer.  You can, however, use `M-k' to clear the</span>
<span class="linecomment">;;  minibuffer or use `C-l' (bound to command</span>
<span class="linecomment">;;  `icicle-retrieve-previous-input') to clear the minibuffer and</span>
<span class="linecomment">;;  retrieve your last real input - see (@&gt; "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `delete' works well to delete isolated candidates or groups of</span>
<span class="linecomment">;;  candidates that are in order (the current sort order), one right</span>
<span class="linecomment">;;  after the other, and you can of course combine it with positive</span>
<span class="linecomment">;;  matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: In Emacs releases prior to Emacs 22, `delete' has no real</span>
<span class="linecomment">;;  effect on file-name completion candidates (but it works fine on</span>
<span class="linecomment">;;  non file-name candidates).  It removes them temporarily, but they</span>
<span class="linecomment">;;  are not really removed as possible candidates, so `TAB' and</span>
<span class="linecomment">;;  `S-TAB' will still show them as candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-~' is particularly handy in combination with progressive</span>
<span class="linecomment">;;  completion (`M-*') to narrow down a set of candidates, especially</span>
<span class="linecomment">;;  when you are not exactly sure what you are looking for.  You can</span>
<span class="linecomment">;;  repeat `C-~' with different inputs to eliminate everything matched</span>
<span class="linecomment">;;  by each of them.  In other words, this is a variable-size chisel,</span>
<span class="linecomment">;;  and you can use it to remove very large chips.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For instance, suppose you are looking for a standard Emacs command</span>
<span class="linecomment">;;  involving buffers.  You try `M-x buff S-TAB', but that shows</span>
<span class="linecomment">;;  zillions of matches.  Suppose that you know you do not want a</span>
<span class="linecomment">;;  command in some 3rd-party package.  You proceed to eliminate</span>
<span class="linecomment">;;  those, progressively, using something like this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-* ediff C-~ ibuffer C-~ icicle C-~ Buffer-menu C-~ ps- C-~</span>
<span class="linecomment">;;        ido C-~ search-buffers C-~ moccur C-~ swbuff C-~</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And so on.  That is, instead of using `M-*' repeatedly to specify</span>
<span class="linecomment">;;  multiple patterns that candidates must match, you use `C-~'</span>
<span class="linecomment">;;  repeatedly (after an initial `M-*'), to chip away candidates you</span>
<span class="linecomment">;;  do not want.  You could, alternatively, hold down the `delete' key</span>
<span class="linecomment">;;  to eliminate each of these groups of command names.  There are</span>
<span class="linecomment">;;  over 100 commands whose names begin with `ediff', however, so `M-*</span>
<span class="linecomment">;;  C-~' can be quicker in that case.  It can definitely be quicker</span>
<span class="linecomment">;;  when apropos matching is involved.  And you can of course combine</span>
<span class="linecomment">;;  the fine chiseling of `delete' with the variable-size chiseling of</span>
<span class="linecomment">;;  `C-~'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Sets of Completion Candidates") for more about `C-~'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Choose Before You Act")</span>
<span class="linecomment">;;  ** Choose Before You Act **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The opposite operation from chipping away at a set of candidates</span>
<span class="linecomment">;;  to refine it is to build up a set of candidates that you want to</span>
<span class="linecomment">;;  act on.  This too is easy with Icicles.  In some user interfaces,</span>
<span class="linecomment">;;  including Dired in Emacs, you can mark items in a checklist and</span>
<span class="linecomment">;;  then, when you've selected the items you want and verified the</span>
<span class="linecomment">;;  list, act on those that are selected.  You might do this, for</span>
<span class="linecomment">;;  instance, if you were deleting some files.  Icicles lets you</span>
<span class="linecomment">;;  interact with completion candidates this same way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You do this by building up a saved set of candidates, and then</span>
<span class="linecomment">;;  retrieving these saved candidates later.  You can use the</span>
<span class="linecomment">;;  retrieved candidates just as you would any current set of</span>
<span class="linecomment">;;  candidates.  One of the things you can do is act on all of them,</span>
<span class="linecomment">;;  that is, act on each, in turn.  You do that with `C-!'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, if you can use a regexp to match exactly the candidates</span>
<span class="linecomment">;;  you want to act on, then you need not bother to save and retrieve</span>
<span class="linecomment">;;  them, before acting on them: you can see them all alone in buffer</span>
<span class="linecomment">;;  `*Completions*'.  Here's an exercise in choosing candidates to</span>
<span class="linecomment">;;  save with the mouse in `*Completions*':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  C-x C-f  i c i  TAB - Match all file names that begin with `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Click `mouse-1' inside (or to the left of) `icicles-face.el'. [*]</span>
<span class="linecomment">;;  Click `mouse-3' inside (or to the right of) `icicles-mode.el'.</span>
<span class="linecomment">;;  Click `mouse-3' again, in the same place.</span>
<span class="linecomment">;;  Click `M-S-mouse-2' on each of `icicles.el' and `icicles-cmd1.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  [* If you click `mouse-1' on a candidate and (starting with Emacs</span>
<span class="linecomment">;;  22) `mouse-1-click-follows-link' is an integer, then you will need</span>
<span class="linecomment">;;  to hold the mouse button depressed longer than that many seconds,</span>
<span class="linecomment">;;  or else that candidate will simply by chosen.  If the value is</span>
<span class="linecomment">;;  `t', then this will not work at all.  Any other value presents no</span>
<span class="linecomment">;;  problem.  (Personally, I use `nil'.)]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The candidates that you selected - those between `icicles-face.el'</span>
<span class="linecomment">;;  and `icicles-mode.el', inclusive, plus `icicles.el' and</span>
<span class="linecomment">;;  `icicles-cmd1.el', are highlighted specially in buffer</span>
<span class="linecomment">;;  `*Completions*', and feedback in the minibuffer tells you that</span>
<span class="linecomment">;;  they were "saved", which you can also think of as "marked".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Next, use `C-M-&lt;'.  This retrieves the set of saved candidates;</span>
<span class="linecomment">;;  that is, it replaces the current set of candidates with the saved</span>
<span class="linecomment">;;  candidates.  If you now use `C-!', it applies the action to each</span>
<span class="linecomment">;;  candidate.  In this case, the action is to visit the file (`C-x</span>
<span class="linecomment">;;  C-f').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The combination of saving (marking) candidates and then retrieving</span>
<span class="linecomment">;;  only those you have saved is like progressive completion or</span>
<span class="linecomment">;;  chipping away: it is another way of progressively narrowing the</span>
<span class="linecomment">;;  set of candidates that you act on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Choose All Completion Candidates") for more about `C-!'.</span>
<span class="linecomment">;;  See (@&gt; "Sets of Completion Candidates") for more about saving and</span>
<span class="linecomment">;;  retrieving sets of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Help on Completion Candidates")</span>
<span class="linecomment">;;  ** Help on Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes, you'd like to be able to ask for help about individual</span>
<span class="linecomment">;;  completion candidates while you're in the process of choosing one.</span>
<span class="linecomment">;;  That is the purpose of the Icicles `C-M-' key bindings available</span>
<span class="linecomment">;;  during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The simplest such bindings are `C-M-RET' and `C-M-mouse2'.  They</span>
<span class="linecomment">;;  each do the same thing: provide help on the current candidate.</span>
<span class="linecomment">;;  You can use them during cycling or whenever you've narrowed the</span>
<span class="linecomment">;;  choice down to a single candidate.  You can check this way, before</span>
<span class="linecomment">;;  you execute a command you're unsure of.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During completion, you can also cycle among the doc strings for</span>
<span class="linecomment">;;  the candidates that match your input, by holding `C-M-' while</span>
<span class="linecomment">;;  using any of the cycling keys:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `C-M-down', `C-M-up', or `C-M-' + wheel - current-mode matching</span>
<span class="linecomment">;;  - `C-M-next', `C-M-prior'                 - apropos matching</span>
<span class="linecomment">;;  - `C-M-end',  `C-M-home'                  - prefix matching</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Prefix Completion and Apropos Completion")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This gives you a very useful on-the-fly apropos feature - use it</span>
<span class="linecomment">;;  while you're completing a command, to check the difference between</span>
<span class="linecomment">;;  several possible commands.  Or just use it to browse doc strings,</span>
<span class="linecomment">;;  to learn more about Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Get Help on Candidates") for more about this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Perform Multiple Operations in One Command")</span>
<span class="linecomment">;;  ** Perform Multiple Operations in One Command **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-x C-f  i c i  TAB - Find a file whose name starts with `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down (that is, the down arrow) ... until you get to candidate</span>
<span class="linecomment">;;                                       `icicles-cmd1.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    RET - Open file `icicles-cmd1.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nothing new here.  Now try the same thing, but use `C-RET' instead</span>
<span class="linecomment">;;  of `RET'.  The command is not ended, and you can continue to</span>
<span class="linecomment">;;  choose files to open:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-x C-f  i c i  TAB - Find a file whose name starts with `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down ... until you get to `icicles-cmd1.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-RET - Open file `icicles-cmd1.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down ... until you get to `icicles-opt.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-RET - Open file `icicles-opt.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down ... until you get to `icicles.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    RET - Open file `icicles.el' (end).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You just opened three files in a single command.  Command</span>
<span class="linecomment">;;  `icicle-file' (`C-x C-f') is an Icicles multi-command.  You can</span>
<span class="linecomment">;;  tell if a command is a multi-command when you execute it - if so,</span>
<span class="linecomment">;;  the input prompt is prefixed by `+'.  So, for example, when you</span>
<span class="linecomment">;;  used `C-x C-f', the prompt was "+ File or directory:".  Icicles</span>
<span class="linecomment">;;  menu items that are multi-commands are also prefixed by `+'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to using `down' (or `end' or `next') and choosing</span>
<span class="linecomment">;;  (acting on) candidates with `C-RET', you can combine these</span>
<span class="linecomment">;;  operations by using `C-down' (or `C-next'): act on candidates in</span>
<span class="linecomment">;;  succession.  And, as mentioned, you can use `C-!'  to act on all</span>
<span class="linecomment">;;  candidates at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many possible uses of multi-commands.  They all make use</span>
<span class="linecomment">;;  of the same key bindings, which begin with `C-'.  These keys are</span>
<span class="linecomment">;;  analogous to the `C-M-' keys that provide help on completion</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Multi-Commands") for more information about Icicles</span>
<span class="linecomment">;;  multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Perform Alternative Operations on the Fly")</span>
<span class="linecomment">;;  ** Perform Alternative Operations on the Fly **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (If this section seems a bit weird or advanced to you, just skip</span>
<span class="linecomment">;;  it the first time through.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-x C-f  i c i TAB - Find a file whose name starts with `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down ... until you get to candidate `icicles-cmd1.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-S-RET - You are prompted to choose a function to apply.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    f i n d e TAB RET - Choose function `finder-commentary'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    down ... until you get to candidate `icicles-fn.el'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-S-RET TAB TAB ... until you get to `find-file-read-only'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    RET - Visit file `icicles-fn.el' in read-only mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-k TAB - Kill rest of input, then complete the prefix `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-|  b y t e - c TAB - Byte-compile all files matching `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    TAB ... until you get to `icicles-doc1.el', then RET to visit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What's going on?  `C-S-RET' invokes an alternative action on the</span>
<span class="linecomment">;;  current completion candidate.  Here, you do this, in turn, for the</span>
<span class="linecomment">;;  file-name candidates `icicles-cmd1.el' and `icicles-fn.el'.  `C-|'</span>
<span class="linecomment">;;  invokes an alternative action on *all* of the current completion</span>
<span class="linecomment">;;  candidates.  Here, you do this for all file names that begin with</span>
<span class="linecomment">;;  `ici'.  Finally, you cycle to `icicles-doc1.el' and hit RET to</span>
<span class="linecomment">;;  visit that file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The alternative action for `C-x C-f' (command `icicle-file')</span>
<span class="linecomment">;;  prompts you for a function to apply to the current completion</span>
<span class="linecomment">;;  candidate (for `C-S-RET') or to all candidates (for `C-|').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here, you choose function `finder-commentary' to visit the</span>
<span class="linecomment">;;  Commentary of file `icicles-cmd1.el', function</span>
<span class="linecomment">;;  `find-file-read-only' to visit file `icicles-fn.el' in read-only</span>
<span class="linecomment">;;  mode, and function `byte-compile-file' to byte-compile all files</span>
<span class="linecomment">;;  whose names start with `ici'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-u' with a function you choose, to pretty-print its</span>
<span class="linecomment">;;  result (in buffer `*Pp Eval Output*', if too large for the echo</span>
<span class="linecomment">;;  area).  That is useful for functions that have no side effects.</span>
<span class="linecomment">;;  For this to work, use `C-RET', not `RET', to choose the function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Each command defines its own alternative action, but many Icicles</span>
<span class="linecomment">;;  commands have the behavior described here for `icicle-file': their</span>
<span class="linecomment">;;  alternative action is to let you apply any function that is</span>
<span class="linecomment">;;  appropriate for the given type of candidate (here, file names).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can even enter an appropriate lambda expression, instead of</span>
<span class="linecomment">;;  completing to one of the function candidates provided.  For</span>
<span class="linecomment">;;  example, you could use `C-|' with the following input to copy all</span>
<span class="linecomment">;;  Icicles libraries to directory `ICICLES':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (lambda (f) (copy-file f "ICICLES" t))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that function `copy-file' is effectively curried here, to</span>
<span class="linecomment">;;  create a function of a single argument on the fly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Alternative Actions").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completion Status Indicators")</span>
<span class="linecomment">;;  ** Completion Status Indicators **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can always know whether completion is possible when you are</span>
<span class="linecomment">;;  inputting text in the minibuffer and, if so, what kind of</span>
<span class="linecomment">;;  completion.  Completion status is indicated in two places: (1) at</span>
<span class="linecomment">;;  the beginning of the minibuffer prompt and (2) in the `Icy'</span>
<span class="linecomment">;;  minor-mode lighter in the mode line.  The second is optional,</span>
<span class="linecomment">;;  controlled by option `icicle-highlight-lighter-flag'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever input completion is available, the prompt is prefixed by</span>
<span class="linecomment">;;  `.' or `+', indicating simple or multi-command completion,</span>
<span class="linecomment">;;  respectively.  If completion is strict (your input must match one</span>
<span class="linecomment">;;  of the candidates), then this character is enclosed in a box.  If</span>
<span class="linecomment">;;  completion is lax (permissive), there is no box.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The `Icy' minor-mode lighter text is highlighted red during</span>
<span class="linecomment">;;  completion.  `+' is added to the lighter (`Icy+') for</span>
<span class="linecomment">;;  multi-command completion, and the lighter is boxed for strict</span>
<span class="linecomment">;;  completion.  When minibuffer input is read without completion, the</span>
<span class="linecomment">;;  lighter is not highlighted in any way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the list of candidates shown in `*Completions*' is truncated</span>
<span class="linecomment">;;  (because of option `icicle-max-candidates'), then the lighter text</span>
<span class="linecomment">;;  is suffixed by `...'.  So if you see `...' then you know that if</span>
<span class="linecomment">;;  you increase `icicle-max-candidates' (e.g. by using `C-x #' during</span>
<span class="linecomment">;;  completion) then more candidates will be available.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Customization and General Tips")</span>
<span class="linecomment">;;  for info about `C-x #' and option `icicle-max-candidates'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, the lighter text (with or without `+' and `...') is</span>
<span class="linecomment">;;  `Icy' if completion is case-sensitive and `ICY' if not.  You can</span>
<span class="linecomment">;;  toggle case-sensitivity at any time using `C-A' (that is, `C-S-a')</span>
<span class="linecomment">;;  in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The faces used for this highlighting in the minibuffer and the</span>
<span class="linecomment">;;  mode line are `icicle-completion',</span>
<span class="linecomment">;;  `icicle-multi-command-completion', and</span>
<span class="linecomment">;;  `icicle-mustmatch-completion'.  Consult their doc strings for more</span>
<span class="linecomment">;;  information.  These faces are combined to produce the various</span>
<span class="linecomment">;;  highlighting effects - keep that in mind if you customize them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you are inputting, keep an eye out for this highlighting.  If</span>
<span class="linecomment">;;  you do not see it when you are prompted for input, it means that</span>
<span class="linecomment">;;  input completion is not available.  This in turn means that</span>
<span class="linecomment">;;  `S-TAB' is available, not for input completion, but for key</span>
<span class="linecomment">;;  completion - see (@&gt; "Key Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Search")</span>
<span class="linecomment">;;  ** Icicles Search **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides a unique way of searching incrementally.  Command</span>
<span class="linecomment">;;  `icicle-search' (`C-c `') is a multi-command.  In this case, the</span>
<span class="linecomment">;;  completion candidates are the buffer occurrences that match a</span>
<span class="linecomment">;;  regexp that you input.  `C-RET' visits a search-hit candidate, and</span>
<span class="linecomment">;;  `C-next' visits a candidate and prepares to visit the next in</span>
<span class="linecomment">;;  succession.  If you visit file `icicles-doc1.el', which contains</span>
<span class="linecomment">;;  the text you are reading now, do this in that buffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-c `</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Search within contexts (regexp): . * r e c u r s i v e . *  RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Search within contexts defined by the regexp `.*recursive.*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Choose an occurrence: S-TAB - Show the search hits, in buffer</span>
<span class="linecomment">;;    `*Completions*' (optional).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-next ... - Cycle among the search hits, navigating to them in</span>
<span class="linecomment">;;    turn.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    S-TAB next ... - Cycle among the search hits without navigating.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    next ... C-RET next ... C-RET - Cycle to particular hits and</span>
<span class="linecomment">;;    visit (only) those hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    next ... RET - Cycle to a hit and stay there (end).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-c `</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Search within contexts (regexp): M-p RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Search again within `.*recursive.*' (`M-p' uses input history).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    S-TAB e d i t C-next ... - Search for the substring `edit'</span>
<span class="linecomment">;;    within all search hits for `.*recursive.*'.  Cycle among the</span>
<span class="linecomment">;;    matches.  The substring `edit' is highlighted inside the</span>
<span class="linecomment">;;    (differently) highlighted `.*recursive.*' hits.  Whatever you</span>
<span class="linecomment">;;    type filters the initial set of hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-k - Empty the minibuffer, then S-TAB.  All `.*recursive.*'</span>
<span class="linecomment">;;    hits are restored as candidates.  Again, whatever your input is</span>
<span class="linecomment">;;    (nothing, now), the set of candidates is dynamically updated to</span>
<span class="linecomment">;;    match it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    t \ w + n S-TAB C-next ... - Search for matches of the regexp</span>
<span class="linecomment">;;    `t\w+n' within all search hits for `.*recursive.*' - that is,</span>
<span class="linecomment">;;    `t' followed by at least one other word character, followed by</span>
<span class="linecomment">;;    `n'.  Whatever the regexp `t\w+n' matches (`thin', `then',</span>
<span class="linecomment">;;    `traighten', `tion') is highlighted inside each candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    RET - Stop searching at the current candidate (end).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Now try the same thing, but first use `C-^' in the minibuffer</span>
<span class="linecomment">;;  (e.g. after you enter `.*recursive.*').  That toggles an Icicles</span>
<span class="linecomment">;;  search option for highlighting your input matches.  The behavior</span>
<span class="linecomment">;;  is the same as before, except that all matches to your input are</span>
<span class="linecomment">;;  highlighted at once, not just the current match.  And not only the</span>
<span class="linecomment">;;  exact match is highlighted, but the longest common match among all</span>
<span class="linecomment">;;  input matches is highlighted: If your input is `edi', then `edi'</span>
<span class="linecomment">;;  is highlighted (there is no longer common match), but if you input</span>
<span class="linecomment">;;  the four characters `e d i t', then ``abort-recursive-edit'' is</span>
<span class="linecomment">;;  highlighted.  You can use `C-^' at any time during searching to</span>
<span class="linecomment">;;  change the highlighting behavior.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Now try the same thing, but first select some text.  The search is</span>
<span class="linecomment">;;  confined to the active region (selection) instead of the entire</span>
<span class="linecomment">;;  buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Now try the same thing (without a region), but use a negative</span>
<span class="linecomment">;;  prefix argument such as `C--' with `C-c `'.  This time, after you</span>
<span class="linecomment">;;  input the regexp to search for, you are prompted for one or more</span>
<span class="linecomment">;;  files to search.  This too is multi-command input: you can input</span>
<span class="linecomment">;;  any number of file names, using completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-- C-c `</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Search within contexts (regexp): . * r e c u r s i v e . *  RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Search within contexts defined by the regexp `.*recursive.*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Choose file (`RET' when done): i c i TAB - Choose among file</span>
<span class="linecomment">;;    candidates that begin with `ici' (shown in `*Completions*').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-! - Choose all matching file names: icicles-cmd1.el,</span>
<span class="linecomment">;;    icicles-cmd2.el, icicles-doc1.el, icicles-doc2.el,</span>
<span class="linecomment">;;    icicles-face.el, icicles-fn.el, icicles-mac.el, icicles-mcmd.el,</span>
<span class="linecomment">;;    icicles-mode.el, icicles-opt.el, icicles-var.el, and icicles.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Choose an occurrence: S-TAB - Show the hits in buffer</span>
<span class="linecomment">;;    `*Completions*' (optional).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-next ... - Cycle among the search hits in all chosen</span>
<span class="linecomment">;;    files...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as you can choose particular search hits to visit, using</span>
<span class="linecomment">;;  `C-RET', so you can use `C-RET' to choose particular files (whose</span>
<span class="linecomment">;;  names match the input, e.g. ici) to search.  Just as you can visit</span>
<span class="linecomment">;;  search hits in order, using `C-next' (or `C-end' or `C-down'), so</span>
<span class="linecomment">;;  you can use `C-next' (or `C-end' or `C-down') to choose files to</span>
<span class="linecomment">;;  visit, one after the other.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you input the initial regexp (`.*recursive.*' in the example</span>
<span class="linecomment">;;  above) to `icicle-search', you can use completion to retrieve a</span>
<span class="linecomment">;;  regexp that you entered previously.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-`' in the minibuffer to toggle escaping of regexp</span>
<span class="linecomment">;;  special characters.  Use that if you want to find a literal string</span>
<span class="linecomment">;;  - for example, if you want to search for the string `form.' and</span>
<span class="linecomment">;;  not text that matches the regexp `form.' (`form' followed by any</span>
<span class="linecomment">;;  character except newline).  If you use `C-`' during Icicles</span>
<span class="linecomment">;;  search, start the search over again for the toggle to take effect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Oh, can you use progressive completion with Icicles search?  Sure.</span>
<span class="linecomment">;;  And chipping away the non-elephant (complementing)?  Yep.  Try</span>
<span class="linecomment">;;  using vanilla Emacs incremental search to find a line that</span>
<span class="linecomment">;;  contains a given set of words in any (unknown) order and that also</span>
<span class="linecomment">;;  does not contain another given set of words.  No can do.  But that</span>
<span class="linecomment">;;  is simple using Icicles search.  (Yes, you can do it using</span>
<span class="linecomment">;;  `grep'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And while you're searching, you can perform on-the-fly, on-demand</span>
<span class="linecomment">;;  replacement.  You tell Emacs whenever you want to replace text,</span>
<span class="linecomment">;;  instead of replying to an endless litany of `query-replace'</span>
<span class="linecomment">;;  queries.  Unlike `query-replace', you need not visit search</span>
<span class="linecomment">;;  matches successively or exhaustively.  You can visit and replace</span>
<span class="linecomment">;;  selected matches in any order.  And you can even change the order</span>
<span class="linecomment">;;  (using `C-,') in which search hits appear and are navigated</span>
<span class="linecomment">;;  sequentially.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to Icicles search (which is also incremental), Icicles</span>
<span class="linecomment">;;  offers some enhancements to the standard Emacs incremental search,</span>
<span class="linecomment">;;  Isearch:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can reuse a previous Isearch search string, choosing it</span>
<span class="linecomment">;;    using Icicles completion.  Hit `M-o' during Isearch, type some</span>
<span class="linecomment">;;    input to complete against the search history, and hit `RET' or</span>
<span class="linecomment">;;    click `mouse-2' to choose a string and continue Isearch with it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can start Icicles search from Isearch.  The current Isearch</span>
<span class="linecomment">;;    search string becomes the starting point for the Icicles search</span>
<span class="linecomment">;;    regexp.  You can edit it or type something different.  And you</span>
<span class="linecomment">;;    can complete what you type against the Isearch regexp history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    for more about searching with Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Search and Replace")</span>
<span class="linecomment">;;    for information about replacing selected search hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Expanded-Common-Match Completion") for more about Icicles</span>
<span class="linecomment">;;    expansion of your input to a common match among all candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Isearch Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Using Completion to Insert Previous Inputs: `M-o'") for</span>
<span class="linecomment">;;    more about `M-o' - you can use it anywhere to complete against</span>
<span class="linecomment">;;    previous inputs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Complete Key Sequences Too")</span>
<span class="linecomment">;;  ** Complete Key Sequences Too **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Try `S-TAB' at the top level (without first invoking a command</span>
<span class="linecomment">;;  that reads input).  Icicles presents all of the possible keys and</span>
<span class="linecomment">;;  their bindings in the current context - for completion.  For</span>
<span class="linecomment">;;  example, if you are in Dired mode, the completion candidates</span>
<span class="linecomment">;;  include all key sequences in the global map and the Dired-mode map</span>
<span class="linecomment">;;  (and any current minor-mode maps, such as Icicle mode).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs key</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option `icicle-key-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can then type part of a key name or a command name, and hit</span>
<span class="linecomment">;;  `S-TAB' again to apropos-complete your input.  You can navigate</span>
<span class="linecomment">;;  down the key-sequence hierarchy by completing a key sequence piece</span>
<span class="linecomment">;;  by piece:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    S-TAB to see the available keys at top level</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Click (using `mouse-2') candidate `C-x  =  ...', to see the keys</span>
<span class="linecomment">;;    that start with `C-x'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Click `r  =  ...', to see the keys that start with `C-x r'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Click `b  =  bookmark-jump', to invoke that command and visit a</span>
<span class="linecomment">;;    bookmark</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever you're completing a prefix key, such as `C-x', you can</span>
<span class="linecomment">;;  click `..' to navigate back up the key-sequence hierarchy.  For</span>
<span class="linecomment">;;  instance, if you are completing `C-x p', click `..' to go back to</span>
<span class="linecomment">;;  completing `C-x', and then click `..' to go back to the top level.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The available keys at any level include the following important</span>
<span class="linecomment">;;  keys, which means that you can use Icicles key completion to do</span>
<span class="linecomment">;;  almost anything in Emacs:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-x' - Execute an arbitrary command.</span>
<span class="linecomment">;;    `M-x' is treated as `ESC-x', so complete first `ESC  =  ...',</span>
<span class="linecomment">;;    then `x = icicle-execute-extended-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-:' - Evaluate any Emacs-Lisp expression.</span>
<span class="linecomment">;;    If command remapping is available (Emacs 22 or later), and if</span>
<span class="linecomment">;;    option `icicle-top-level-key-bindings' remaps `eval-expression'</span>
<span class="linecomment">;;    to `icicle-pp-eval-expression' (which it does, by default), then</span>
<span class="linecomment">;;    complete first `remapped  =  ...', then `eval-expression  =</span>
<span class="linecomment">;;    icicle-pp-eval-expression'.  Otherwise, complete first `ESC  =</span>
<span class="linecomment">;;    ...', then `:  =  eval-expression'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    In Icicles, `M-:' gives you a quick pop-up mode for evaluating a</span>
<span class="linecomment">;;    Lisp sexp.  Most of the normal Emacs-Lisp mode bindings are in</span>
<span class="linecomment">;;    effect, except that `RET' evaluates the minibuffer contents and</span>
<span class="linecomment">;;    pretty-prints the result.  You can also use it with a prefix arg</span>
<span class="linecomment">;;    (`C-u M-:') to insert the result of such an on-the-fly Lisp</span>
<span class="linecomment">;;    evaluation into the current buffer (including the minibuffer).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `menu-bar  =  ...' - Invoke any menu-bar menu.</span>
<span class="linecomment">;;    Continue completing, to navigate the entire menu hierarchy.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can start directly with a key prefix, and then hit `S-TAB' to</span>
<span class="linecomment">;;  complete it - you need not start with `S-TAB'.  You can use</span>
<span class="linecomment">;;  Icicles key completion to learn key bindings - `C-M-mouse-2'</span>
<span class="linecomment">;;  displays help on any key.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of clicking a completion candidate with `mouse-2', you can</span>
<span class="linecomment">;;  of course type part of the key name or command name, and then</span>
<span class="linecomment">;;  complete the name and enter it.  Gotcha: `S-TAB' uses apropos</span>
<span class="linecomment">;;  completion, by default, so remember that typing `.' matches any</span>
<span class="linecomment">;;  character (except a newline).  To match only `..' (to go up a</span>
<span class="linecomment">;;  level), either use prefix completion (`TAB') or escape the regexp</span>
<span class="linecomment">;;  special character: `\.\.' (or use `^\.').  Or cycle to it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Key Completion") for more about Icicles key completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Available for Almost Any Input")</span>
<span class="linecomment">;;  ** Available for Almost Any Input **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All of this works not only for the input of commands, with `M-x',</span>
<span class="linecomment">;;  but for the input of nearly anything.  For instance, you can use</span>
<span class="linecomment">;;  `C-x b' (`switch-to-buffer') and cycle among buffer names.  Or use</span>
<span class="linecomment">;;  `C-h v' (`describe-variable') and cycle among variable names.  It</span>
<span class="linecomment">;;  works whenever a command reads input with completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever you're in Icicle mode, you see "Icy" in the mode-line.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Component Icicles Libraries")</span>
<span class="linecomment">;;  ** Component Icicles Libraries **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles is composed of the following libraries.  When you load the</span>
<span class="linecomment">;;  driver library, `icicles.el', the others are all loaded</span>
<span class="linecomment">;;  automatically .</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicles.el'      - driver library</span>
<span class="linecomment">;;    `icicles-doc1.el' - first part of the doc (this!)</span>
<span class="linecomment">;;    `icicles-doc2.el' - second part of the doc</span>
<span class="linecomment">;;    `icicles-cmd1.el' - top-level commands (part 1)</span>
<span class="linecomment">;;    `icicles-cmd2.el' - top-level commands (part 2)</span>
<span class="linecomment">;;    `icicles-face.el' - faces</span>
<span class="linecomment">;;    `icicles-fn.el'   - non-interactive functions</span>
<span class="linecomment">;;    `icicles-mac.el'  - macros</span>
<span class="linecomment">;;    `icicles-mcmd.el' - minibuffer commands</span>
<span class="linecomment">;;    `icicles-mode.el' - Icicle mode definition</span>
<span class="linecomment">;;    `icicles-opt.el'  - user options (variables)</span>
<span class="linecomment">;;    `icicles-var.el'  - internal variables</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Libraries `icicles-doc1.el' and `icicles-doc2.el' are not really</span>
<span class="linecomment">;;  libraries.  They contain only comments, with the Icicles doc.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `lacarte.el' is not part of Icicles, but it is especially</span>
<span class="linecomment">;;  useful when used with Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "If You Are an Emacs-Lisp Programmer")</span>
<span class="linecomment">;;  ** If You Are an Emacs-Lisp Programmer **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are an Emacs-Lisp programmer, this is the no-brainer,</span>
<span class="linecomment">;;  nutshell view of how to take advantage of Icicles in your own code</span>
<span class="linecomment">;;  that calls `completing-read' or `read-file-name':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Add this line to your library: (require 'icicles nil t)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is really all you need to do.  And there is no consequence if</span>
<span class="linecomment">;;  users do not have Icicles (no load error is raised, because of the</span>
<span class="linecomment">;;  non-`nil' third argument).  In other words, there is no reason not</span>
<span class="linecomment">;;  to add this soft `require', unless your library somehow conflicts</span>
<span class="linecomment">;;  with Icicles features.  (Even then, users will not be affected</span>
<span class="linecomment">;;  unless they turn on Icicle mode.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For more (and there is a lot more), read on...</span>
 
<span class="linecomment">;;(@* "Inserting Text Found Near the Cursor")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Inserting Text Found Near the Cursor</span>
<span class="linecomment">;;  ------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most of Icicles is about completing text that you type in the</span>
<span class="linecomment">;;  minibuffer against some set of possible completion candidates.</span>
<span class="linecomment">;;  This feature is not.  It is related only in the sense that it is</span>
<span class="linecomment">;;  also about inputting text that is already available elsewhere.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some Emacs commands provide, as the default value for minibuffer</span>
<span class="linecomment">;;  input, a word or other text at the cursor position (aka "point").</span>
<span class="linecomment">;;  You can insert this default value in the minibuffer with `M-n'.</span>
<span class="linecomment">;;  Icicles option `icicle-default-value' can be used to automatically</span>
<span class="linecomment">;;  insert the default value into the minibuffer as an initial value,</span>
<span class="linecomment">;;  if you prefer that optional behavior (I do; many people do not).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes you would like to use the text at the cursor, but the</span>
<span class="linecomment">;;  command asking for input does not let you retrieve that text as</span>
<span class="linecomment">;;  the default value.  For example, if the text at point is a file</span>
<span class="linecomment">;;  name, you might like to use it with `C-x C-f' to open that file.</span>
<span class="linecomment">;;  Or, if the text is a URL, you might want to visit it using a Web</span>
<span class="linecomment">;;  browser.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some Emacs-Lisp libraries, such as `ffap.el', have as their</span>
<span class="linecomment">;;  specific purpose to help you do this.  "Ffap" stands for</span>
<span class="linecomment">;;  `find-file-at-point', the main command in that library.  It tries</span>
<span class="linecomment">;;  to interpret the text at point and "do the right thing" with it:</span>
<span class="linecomment">;;  visit a file, open a URL in a Web browser, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you like, you can use library `ffap.el' with Icicles.  All</span>
<span class="linecomment">;;  Icicles features are then available during file-name and URL</span>
<span class="linecomment">;;  completion.  And if you like `ffap.el', you might also like to try</span>
<span class="linecomment">;;  my extension library `ffap-.el'.  However, if you use ffap with</span>
<span class="linecomment">;;  Icicles, you might not want to use the ffap key bindings,</span>
<span class="linecomment">;;  preferring the Icicles bindings or the standard Emacs bindings for</span>
<span class="linecomment">;;  keys such as `C-x C-f'.  (In that case, do not call function</span>
<span class="linecomment">;;  `ffap-bindings'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides a couple of simple ways to take advantage of</span>
<span class="linecomment">;;  `ffap-guesser', which is the ffap function that guesses which</span>
<span class="linecomment">;;  string at the cursor position you want to grab, without</span>
<span class="linecomment">;;  sacrificing any key bindings to ffap.  One way is to use `M-.'</span>
<span class="linecomment">;;  (command `icicle-insert-string-at-point') at any time in the</span>
<span class="linecomment">;;  minibuffer.  It grabs text at or near the cursor and yanks it into</span>
<span class="linecomment">;;  the minibuffer.  By default, the text it grabs is whatever</span>
<span class="linecomment">;;  `ffap-guesser' guesses.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way is to use one of the proxy completion candidates</span>
<span class="linecomment">;;  `*point file name*' or `*mouse-2 file name*' whenever Emacs asks</span>
<span class="linecomment">;;  you to input a file name (provided option</span>
<span class="linecomment">;;  `icicle-add-proxy-candidates-flag' is non-`nil' - toggle with</span>
<span class="linecomment">;;  `C-M-_').  The former picks up the file name at point, just like</span>
<span class="linecomment">;;  `M-.'.  The latter lets you click a file name anywhere with</span>
<span class="linecomment">;;  `mouse-2' to pick up the name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using `M-.' or a proxy candidate on demand, instead of binding</span>
<span class="linecomment">;;  keys to ffap commands, lets you control which buffer text you use</span>
<span class="linecomment">;;  as minibuffer input and how that text should be interpreted (file</span>
<span class="linecomment">;;  name, URL, and so on).  You can change the behavior of `M-.'</span>
<span class="linecomment">;;  (which string-inserting functions are used) by customizing user</span>
<span class="linecomment">;;  option `icicle-thing-at-point-functions'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Actually, `M-.' acts differently if you use it successively.</span>
<span class="linecomment">;;  Successive uses of `M-.' grab and insert either 1) alternative</span>
<span class="linecomment">;;  bits of text (different text "things") or 2) successive bits of</span>
<span class="linecomment">;;  text.  The default behavior is #1, but you can change this choice</span>
<span class="linecomment">;;  by customizing option `icicle-default-thing-insertion' (setting it</span>
<span class="linecomment">;;  to `more-of-the-same', instead of `alternatives').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of grabbing successive bits of text (#2), suppose</span>
<span class="linecomment">;;  that the cursor is at the beginning of the word "use" in the</span>
<span class="linecomment">;;  previous paragraph.  Then, during minibuffer input, suppose that</span>
<span class="linecomment">;;  you use `M-. M-. M-.'.  Each time you hit `M-.', another word is</span>
<span class="linecomment">;;  inserted in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    use</span>
<span class="linecomment">;;    use it</span>
<span class="linecomment">;;    use it successively</span>
<span class="linecomment">;;    ...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The rest of this section is a bit technical, so you might want to</span>
<span class="linecomment">;;  skip it if you are reading the Icicles doc for the first time.  It</span>
<span class="linecomment">;;  details the behavior and definitions of options</span>
<span class="linecomment">;;  `icicle-default-thing-insertion' and</span>
<span class="linecomment">;;  `icicle-thing-at-point-functions', and how to temporarily override</span>
<span class="linecomment">;;  those settings interactively.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Option `icicle-thing-at-point-functions' controls which text at or</span>
<span class="linecomment">;;  near the cursor `M-.' inserts into the minibuffer.  It is a cons</span>
<span class="linecomment">;;  cell, that is, an ordered pair:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The car (first part) is a list of functions that grab different</span>
<span class="linecomment">;;    kinds of strings at or near point (#1, above).  Any number of</span>
<span class="linecomment">;;    functions can be used.  They are used in sequence by `M-.'.  I</span>
<span class="linecomment">;;    recommend that you also use library `thingatpt+.el', so that</span>
<span class="linecomment">;;    `M-.' can take advantage of the string-grabbing functions it</span>
<span class="linecomment">;;    defines.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The cdr (second part) is a function that advances point one text</span>
<span class="linecomment">;;    thing (#2, above).  Each time command `M-.' is used</span>
<span class="linecomment">;;    successively, this is called to grab more things of text (of the</span>
<span class="linecomment">;;    same kind).  The default function grabs successive words.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If either the car or cdr is empty, then the other alone determines</span>
<span class="linecomment">;;  the behavior of `M-.'.  Otherwise, option</span>
<span class="linecomment">;;  `icicle-default-thing-insertion' determines whether the car or the</span>
<span class="linecomment">;;  cdr is used by `M-.'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if the value of `icicle-default-thing-insertion' is</span>
<span class="linecomment">;;  `alternatives' (the default value), then repeated use of `M-.'</span>
<span class="linecomment">;;  inserts a different kind of thing at point: ffap guess, file name,</span>
<span class="linecomment">;;  word, or URL.  If you set `icicle-default-thing-insertion' to</span>
<span class="linecomment">;;  `more-of-the-same', then repeated use of `M-.' inserts successive</span>
<span class="linecomment">;;  words into the minibuffer, as shown in the example above.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You need not make a final choice once and for all between</span>
<span class="linecomment">;;  `alternatives' and `more-of-the-same'.  You can also make an</span>
<span class="linecomment">;;  interactive choice by using a prefix argument (`C-u') at any time</span>
<span class="linecomment">;;  to override the value of `icicle-default-thing-insertion'.  If you</span>
<span class="linecomment">;;  use plain `C-u', then `M-.' inserts alternative strings.  If you</span>
<span class="linecomment">;;  use a numeric prefix argument N (not just plain `C-u'), then it is</span>
<span class="linecomment">;;  the same as using `M-.' N times with `more-of-the-same' as the</span>
<span class="linecomment">;;  value of `icicle-default-thing-insertion'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And, if the numeric argument is negative, then text is grabbed to</span>
<span class="linecomment">;;  the left of the cursor, instead of to the right.  In the example</span>
<span class="linecomment">;;  above, if you used `M-- M-. M-. M-.', then the successive</span>
<span class="linecomment">;;  insertions would be as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  differently</span>
<span class="linecomment">;;  differently if</span>
<span class="linecomment">;;  differently if you</span>
<span class="linecomment">;;  ...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you used `M--3 M-.', then you would immediately insert</span>
<span class="linecomment">;;  `differently if you'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the case of `alternatives', the default possibilities depend on</span>
<span class="linecomment">;;  whether or not you also use my library `thingatpt+.el'.  If not,</span>
<span class="linecomment">;;  there are four alternatives:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The first alternative inserts text that has the syntax of an</span>
<span class="linecomment">;;    Emacs-Lisp symbol name.  In practice, this can also be a file</span>
<span class="linecomment">;;    name or a URL - it can include characters such as -, /, +, ., :,</span>
<span class="linecomment">;;    @, and _.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The second alternative inserts a word, which includes letters,</span>
<span class="linecomment">;;    ', and -.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The third alternative inserts whatever `ffap-guesser' returns: a</span>
<span class="linecomment">;;    file name or URL.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The fourth alternative inserts a URL, adding prefix "http://" if</span>
<span class="linecomment">;;    needed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you also use my library `thingatpt+.el', then:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The first and second alternatives are like those for the case</span>
<span class="linecomment">;;    where you do not use `thingatpt+.el', except that the cursor</span>
<span class="linecomment">;;    need not be exactly on the text - the symbol or word *nearest*</span>
<span class="linecomment">;;    the cursor is grabbed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If the region is active, then the second alternative inserts the</span>
<span class="linecomment">;;    region text instead of just the nearest word.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The third alternative inserts the (non-`nil') list nearest</span>
<span class="linecomment">;;    point.  IOW, this grabs a sexp that is more than just an atom.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The fourth and fifth alternatives are like the third, but they</span>
<span class="linecomment">;;    grab wider sexps.  They first go up one and two list levels,</span>
<span class="linecomment">;;    respectively.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The sixth and seventh alternatives insert a file name and URL,</span>
<span class="linecomment">;;    respectively.  They are the same as the third and fourth</span>
<span class="linecomment">;;    alternatives that are provided if you do not use</span>
<span class="linecomment">;;    `thingatpt+.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can of course add to or replace any of the alternatives</span>
<span class="linecomment">;;  provided by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Inserting a Regexp from a Variable or Register") for</span>
<span class="linecomment">;;    information on inserting text saved in a variable or register.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Moving Between the Minibuffer and Other Buffers") for</span>
<span class="linecomment">;;    another way to insert buffer text in the minibuffer.</span>
 
<span class="linecomment">;;(@* "Background on Vanilla Emacs Input Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Background on Vanilla Emacs Input Completion</span>
<span class="linecomment">;;  --------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section reviews standard Emacs behavior regarding input</span>
<span class="linecomment">;;  completion.  It does not describe any Icicles completion features.</span>
<span class="linecomment">;;  See also (@&gt; "README").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you are prompted in the minibuffer to enter something, you</span>
<span class="linecomment">;;  are sometimes presented with a default value.  This might be</span>
<span class="linecomment">;;  automatically inserted after the prompt, initially.  If not, you</span>
<span class="linecomment">;;  can retrieve the default value yourself, using `M-n' (Emacs 21 or</span>
<span class="linecomment">;;  later).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Often, there is more than one reasonable default value that might</span>
<span class="linecomment">;;  make sense.  Depending on what you're being asked to enter, these</span>
<span class="linecomment">;;  "candidate default values" might be command names, buffer names,</span>
<span class="linecomment">;;  existing file names, variable names, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For most Emacs functions that prompt you for input, the person who</span>
<span class="linecomment">;;  wrote the function decided on the reasonable set of default</span>
<span class="linecomment">;;  values, and passed these to an "input-completing function" such as</span>
<span class="linecomment">;;  `completing-read' or `read-file-name', which prompts you and reads</span>
<span class="linecomment">;;  your input.  The programmer also decided whether you will be</span>
<span class="linecomment">;;  *required* to pick one of the default values or you will be free</span>
<span class="linecomment">;;  to enter something else.  The programmer might also have told the</span>
<span class="linecomment">;;  input-completing function to require that your input pass some</span>
<span class="linecomment">;;  special test (predicate).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Be aware that standard Emacs terminology does not refer to such a</span>
<span class="linecomment">;;  set of default values as "default values"; they are called</span>
<span class="linecomment">;;  "completions".  By "default value", standard Emacs terminology</span>
<span class="linecomment">;;  means only the values that you can access via `M-n'.  Icicles</span>
<span class="linecomment">;;  refers to all such potential inputs indifferently as "default</span>
<span class="linecomment">;;  values", "completions", "completion candidates", and "candidates".</span>
<span class="linecomment">;;  Whenever completion is not requiring you to pick one of the</span>
<span class="linecomment">;;  available candidates, they are effectively only default choices.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, how do you get access to the default values that the</span>
<span class="linecomment">;;  programmer has made available to you, in order to choose one?  You</span>
<span class="linecomment">;;  hit certain keys to complete the current contents of the</span>
<span class="linecomment">;;  minibuffer (excluding the prompt).  This current, partial input is</span>
<span class="linecomment">;;  considered as a prefix of one of the default values, and it is</span>
<span class="linecomment">;;  completed in the minibuffer to the entire default value</span>
<span class="linecomment">;;  (completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keys `TAB', `RET' (Return), and `SPC' (Space) perform different</span>
<span class="linecomment">;;  degrees of this "prefix completion" in standard Emacs.  If you</span>
<span class="linecomment">;;  type a prefix of one of the available default values, you can</span>
<span class="linecomment">;;  complete the value this way in the minibuffer, and then enter</span>
<span class="linecomment">;;  (commit) it, using `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But if your partial input matches the prefix of more than one</span>
<span class="linecomment">;;  default value, then completion pops up the list of all matching</span>
<span class="linecomment">;;  completions for you to choose from (in buffer `*Completions*').</span>
<span class="linecomment">;;  You choose a candidate by clicking it with `mouse-2' or placing</span>
<span class="linecomment">;;  the cursor on it and hitting `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because this is the way you access the default values supplied to</span>
<span class="linecomment">;;  an input-completing function, I call those values</span>
<span class="linecomment">;;  "prefix-completion candidates".  If there is no partial input yet</span>
<span class="linecomment">;;  (empty minibuffer), then the entire list of default values</span>
<span class="linecomment">;;  supplied to the input-completing function appears in the pop-up</span>
<span class="linecomment">;;  `*Completions*' buffer.  See the Emacs manual (`C-h i') for more</span>
<span class="linecomment">;;  on this general mechanism of prefix completion (called simply</span>
<span class="linecomment">;;  "completion" there).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Calls to `completing-read' and `read-file-name' are not the only</span>
<span class="linecomment">;;  places where input completion is used.  When you use `M-x'</span>
<span class="linecomment">;;  (command `execute-extended-command'), completion is also</span>
<span class="linecomment">;;  available.</span>
 
<span class="linecomment">;;(@* "Cycling Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Cycling Completions</span>
<span class="linecomment">;;  -------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you use the `end' and `home' keys to cycle through</span>
<span class="linecomment">;;  the list of candidate prefix completions that match whatever input</span>
<span class="linecomment">;;  is present in the minibuffer (or all candidate completions, if</span>
<span class="linecomment">;;  there is no input in the minibuffer).  In the minibuffer, each</span>
<span class="linecomment">;;  candidate replaces your partial input, in turn, when you cycle.</span>
<span class="linecomment">;;  The prefix (root) that was completed is underlined in the</span>
<span class="linecomment">;;  minibuffer completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an alternative to using `end' to cycle forward, you can hit</span>
<span class="linecomment">;;  `TAB' repeatedly.  See (@&gt; "Prefix Completion and Apropos Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Suppose you use `C-x b' (command `switch-to-buffer').  You can</span>
<span class="linecomment">;;  then use `end' until the right buffer name appears in the</span>
<span class="linecomment">;;  minibuffer, then hit `RET'.  Or you can type some text that begins</span>
<span class="linecomment">;;  one or more of the buffer names, and then use `end' to cycle among</span>
<span class="linecomment">;;  those names that match that prefix.  If there are many candidates,</span>
<span class="linecomment">;;  typing part of the name to narrow the field can save time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another example: Suppose you use `C-h v' (`describe-variable') and</span>
<span class="linecomment">;;  type `cal'.  Use `end' to cycle among all variables that start</span>
<span class="linecomment">;;  with `cal', until you find the one you want (then hit `RET').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In other words, the current partial input in the minibuffer</span>
<span class="linecomment">;;  determines a matching set of default values, and those are the</span>
<span class="linecomment">;;  values that you can cycle through.  You can at any time erase or</span>
<span class="linecomment">;;  change the partial input - the list of matching candidates</span>
<span class="linecomment">;;  automatically reflects the change.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This also means that it's good to have a quick way to clear the</span>
<span class="linecomment">;;  minibuffer of any input, so Icicles also provides minibuffer key</span>
<span class="linecomment">;;  binding `M-k' to do that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A visible and audible signal lets you know when you have reached</span>
<span class="linecomment">;;  one end of the list of completion candidates, but you can of</span>
<span class="linecomment">;;  course continue to cycle, wrapping around.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the completion candidates are already displayed in buffer</span>
<span class="linecomment">;;  `*Completions*' when you try to cycle among them (because you hit</span>
<span class="linecomment">;;  `TAB'), then the current candidate is highlighted in</span>
<span class="linecomment">;;  `*Completions*' as you access it in the minibuffer with the `home'</span>
<span class="linecomment">;;  and `end' keys.  If you change the minibuffer input, then the</span>
<span class="linecomment">;;  `*Completions*' list is updated accordingly, to reflect the new</span>
<span class="linecomment">;;  set of matching candidates.  The root that was completed (the</span>
<span class="linecomment">;;  minibuffer input) is highlighted in each candidate of the</span>
<span class="linecomment">;;  `*Completions*' display.  The `*Completions*' window is</span>
<span class="linecomment">;;  automatically scrolled as needed, to show the current candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Do not become a cycling drone!  Input some text to narrow the set</span>
<span class="linecomment">;;  of candidates, before cycling among them to choose one.  This is a</span>
<span class="linecomment">;;  good habit to adopt, generally, in Icicles.  Most of the power of</span>
<span class="linecomment">;;  Icicles comes in your ability to filter a set of candidates.  This</span>
<span class="linecomment">;;  is especially true when it comes to regexp filtering (see</span>
<span class="linecomment">;;  (@&gt; "Apropos Completions")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Cycling and filtering work hand in hand.  If the set of candidates</span>
<span class="linecomment">;;  is small to begin with, then just cycling might be quick enough -</span>
<span class="linecomment">;;  that is the case if you move among a small set of buffers, for</span>
<span class="linecomment">;;  instance.  But with Icicles you can profitably use cycling on even</span>
<span class="linecomment">;;  a very large set of candidates - by filtering the set first.  The</span>
<span class="linecomment">;;  reason this is not very practical with vanilla Emacs is that</span>
<span class="linecomment">;;  filtering by a prefix only is not very potent.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tip: Whenever you type or delete text in the minibuffer, your</span>
<span class="linecomment">;;  partial input is remembered.  When you cycle completion</span>
<span class="linecomment">;;  candidates, your input is replaced by each candidate, but you can</span>
<span class="linecomment">;;  at any time refresh the minibuffer to retrieve what you last</span>
<span class="linecomment">;;  typed.  You do this with `C-l', which is bound in the minibuffer</span>
<span class="linecomment">;;  to command `icicle-retrieve-previous-input'.  Editing a completion</span>
<span class="linecomment">;;  candidate that you have cycled into the minibuffer counts as</span>
<span class="linecomment">;;  input.  Editing tells Icicles to remember what is in the</span>
<span class="linecomment">;;  minibuffer as your last real input.  If you want to replace the</span>
<span class="linecomment">;;  candidate and go back to editing the input you had already typed</span>
<span class="linecomment">;;  before cycling, then use `C-l' - do not just delete characters</span>
<span class="linecomment">;;  from the candidate.  See (@&gt; "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can change the keys that are bound to completion-candidate</span>
<span class="linecomment">;;  cycling.  And you can change whether `down' and `up' start off by</span>
<span class="linecomment">;;  cycling prefix completions or apropos completions.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Customizing Key Bindings").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Finally, you can use the mouse wheel (Emacs 22 or later) to cycle</span>
<span class="linecomment">;;  candidates according to the current completion mode (prefix or</span>
<span class="linecomment">;;  apropos).  See (@&gt; "Prefix Completion and Apropos Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Mouse-wheel cycling works also with modifier keys: `C-M-' for</span>
<span class="linecomment">;;  candidate help, `C-' for candidate actions, and `C-S-' for</span>
<span class="linecomment">;;  alternative candidate actions.  In particular, `C-' with the wheel</span>
<span class="linecomment">;;  gives you a very quick way to visit search hits during Icicles</span>
<span class="linecomment">;;  search (and `C-S-' works for search-and-replace).</span>
<span class="linecomment">;;  (See (@* "Icicles Search Commands, Overview").)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are an Emacs-Lisp programmer, then you can use</span>
<span class="linecomment">;;  `completing-read' and `read-file-name' to define your own</span>
<span class="linecomment">;;  commands, enabling them to take advantage of Icicles completion</span>
<span class="linecomment">;;  and cycling.  The definition of command `icicle-recent-file' is a</span>
<span class="linecomment">;;  good model to follow.  Emacs has a `recentf-mode' that lets you</span>
<span class="linecomment">;;  open recently accessed files.  But this mode makes you open a file</span>
<span class="linecomment">;;  using a menu interface.  Command `icicle-recent-file' lets you use</span>
<span class="linecomment">;;  the usual `find-file' minibuffer interface, with completion and</span>
<span class="linecomment">;;  cycling among your recent files.  See sections</span>
<span class="linecomment">;;  (@&gt; "Defining Icicles Commands") and</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Note to Programmers")</span>
<span class="linecomment">;;  for more on defining your own commands with `completing-read' and</span>
<span class="linecomment">;; `read-file-name'.</span>
 
<span class="linecomment">;;(@* "Traversing Minibuffer Histories")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Traversing Minibuffer Histories</span>
<span class="linecomment">;;  -------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Perhaps you are already used to accessing past inputs with vanilla</span>
<span class="linecomment">;;  Emacs using the `down' and `up' arrow keys (or `M-n', `M-p', and</span>
<span class="linecomment">;;  `next').  If not, try it (not in Icicle mode).  You can go</span>
<span class="linecomment">;;  backward and forward in the minibuffer histories (there are</span>
<span class="linecomment">;;  different history lists for different kinds of input).  You cannot</span>
<span class="linecomment">;;  really cycle them (with wraparound), but when you get to one end</span>
<span class="linecomment">;;  you can reverse the direction.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Anyway, the input-cycling behavior that Icicles offers is in</span>
<span class="linecomment">;;  addition to this standard traversal of histories.  Since there</span>
<span class="linecomment">;;  are, by default, several extra pairs of keys used for history</span>
<span class="linecomment">;;  traversal, rebinding some of them to use for Icicles completion is</span>
<span class="linecomment">;;  no real loss.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, Icicles rebinds the arrow keys `down' and `up' for</span>
<span class="linecomment">;;  current-mode completion cycling.  Icicles also rebinds `end' and</span>
<span class="linecomment">;;  `home' for prefix-completion cycling, and `next' and `prior' for</span>
<span class="linecomment">;;  apropos-completion cycling.  But you still have `M-n' and `M-p'</span>
<span class="linecomment">;;  available to access past inputs (history).  And the rebindings are</span>
<span class="linecomment">;;  only for minibuffer input; global bindings are not affected.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can at any time switch back and forth between input-history</span>
<span class="linecomment">;;  traversal (`M-n', `M-p') and completion cycling (`down', `up',</span>
<span class="linecomment">;;  `next', `prior', `end', `home').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "History Enhancements") for new ways to use Emacs history</span>
<span class="linecomment">;;    lists with Icicles</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Customizing Key Bindings")</span>
<span class="linecomment">;;    for how to change the default Icicles key bindings, including</span>
<span class="linecomment">;;    the keys used for candidate cycling</span>
 
<span class="linecomment">;;(@* "Apropos Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Apropos Completions</span>
<span class="linecomment">;;  -------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles offers a new way to complete your partial input in the</span>
<span class="linecomment">;;  minibuffer.  Instead of considering the string of input characters</span>
<span class="linecomment">;;  to be the prefix of various complete names, you can look for names</span>
<span class="linecomment">;;  that match that string anywhere.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is the single most important feature that Icicles offers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is similar in effect to using command `apropos' to find</span>
<span class="linecomment">;;  "apropos completions" of a string (except it works also for file</span>
<span class="linecomment">;;  and buffer names), so that's the term I use for this: apropos</span>
<span class="linecomment">;;  completion.  The more correct characterization of this is that of</span>
<span class="linecomment">;;  the previous paragraph, however: names that match the given</span>
<span class="linecomment">;;  string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as with prefix completion, Icicles lets you cycle among the</span>
<span class="linecomment">;;  apropos candidates.  To do this, you use keys `next' and `prior'.</span>
<span class="linecomment">;;  The root that was completed is underlined in the minibuffer</span>
<span class="linecomment">;;  completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, suppose you use `M-x' to enter a command.  You do not</span>
<span class="linecomment">;;  remember the exact command name, but it has something to do with</span>
<span class="linecomment">;;  lines, so you type `M-x line', then hit `next' repeatedly, until</span>
<span class="linecomment">;;  you see the right "line" command - `transpose-lines', perhaps.</span>
<span class="linecomment">;;  Prefix completion cannot find this command, because "line" is not</span>
<span class="linecomment">;;  a prefix of "transpose-lines".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because `M-x' expects a command name, only command names are</span>
<span class="linecomment">;;  inserted into the minibuffer as the apropos-completion candidates</span>
<span class="linecomment">;;  for `M-x'.  Likewise, in other contexts, where names of other</span>
<span class="linecomment">;;  kinds of object are expected, apropos completion inserts only</span>
<span class="linecomment">;;  names of objects of the appropriate type.  Prefix completion works</span>
<span class="linecomment">;;  the same way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, using `next' and `prior' with `C-x b at' lets you</span>
<span class="linecomment">;;  cycle through all buffers (such as `*scratch*') that have "at" in</span>
<span class="linecomment">;;  their name - only buffer names appear as candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an alternative to using `next' to cycle forward, you can hit</span>
<span class="linecomment">;;  `S-TAB' repeatedly.  Similarly, for prefix completion you can</span>
<span class="linecomment">;;  repeat `TAB' to cycle forward.  See</span>
<span class="linecomment">;;  (@&gt; "Prefix Completion and Apropos Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Apropos completion uses a regular expression (regexp) as its input</span>
<span class="linecomment">;;  string.  You can type `M-x \bes', for instance, to find commands</span>
<span class="linecomment">;;  with "es" at the start of a word within the command name (`\b'</span>
<span class="linecomment">;;  matches the start of a word).  It will find `eshell-test' and</span>
<span class="linecomment">;;  `color-theme-blue-eshell', but not `count-lines' - "es" does not</span>
<span class="linecomment">;;  start a word in `count-lines'.  Similarly, for file names, buffer</span>
<span class="linecomment">;;  names, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Prefix completion is actually a special case of apropos</span>
<span class="linecomment">;;  completion, where the regexp starts with "^".  (That is not how it</span>
<span class="linecomment">;;  is implemented, however.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What if you want to see the list of all completion candidates that</span>
<span class="linecomment">;;  match the minibuffer input?  Instead of cycling candidates</span>
<span class="linecomment">;;  blindly, just hit `S-TAB' (Shift TAB) at any time to display the</span>
<span class="linecomment">;;  matching candidates in pop-up buffer `*Completions*'.  This is</span>
<span class="linecomment">;;  analogous to `TAB' for prefix completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs apropos</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option</span>
<span class="linecomment">;;  `icicle-apropos-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Everything said in section (@&gt; "Cycling Completions") about the</span>
<span class="linecomment">;;  `*Completions*' buffer for prefix completion is also true for</span>
<span class="linecomment">;;  apropos completion.  It is updated to reflect the current set of</span>
<span class="linecomment">;;  matching candidates, and the current completion is highlighted.</span>
<span class="linecomment">;;  The root that was completed is highlighted within each candidate</span>
<span class="linecomment">;;  (first occurrence only).  Root highlighting is more important in</span>
<span class="linecomment">;;  the case of apropos completion, because the match position is</span>
<span class="linecomment">;;  different in different candidates.  In the case of apropos</span>
<span class="linecomment">;;  completion, the root is not the input string, taken literally, but</span>
<span class="linecomment">;;  the part of a candidate that the input matches.  See</span>
<span class="linecomment">;;  (@&gt; "*Completions* Display") for additional ways to use the</span>
<span class="linecomment">;;  minibuffer with `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regexp matching is one of the most powerful features of Icicles.</span>
<span class="linecomment">;;  Enjoy!  Explore!  You can at any time switch back and forth</span>
<span class="linecomment">;;  between prefix completion (`end', `home'), apropos completion</span>
<span class="linecomment">;;  (`next', `prior'), and input history traversal (`M-n', `M-p').</span>
 
<span class="linecomment">;;(@* "Expanded-Common-Match Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Expanded-Common-Match Completion</span>
<span class="linecomment">;;  --------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Apropos (regexp) matching and prefix completion each match a</span>
<span class="linecomment">;;  pattern against a completion candidate.  This operation concerns</span>
<span class="linecomment">;;  only a single candidate; it does not take into account the fact</span>
<span class="linecomment">;;  that there are others.  Since the matching operation is repeated</span>
<span class="linecomment">;;  anyway for each candidate, however, we can also find an expanded</span>
<span class="linecomment">;;  string that includes the same match (apropos or prefix) for all</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For prefix completion, Emacs completes your input to the longest</span>
<span class="linecomment">;;  common prefix match.  Icicles uses a similar notion for apropos</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you enter `M-x minib' and hit `TAB', Emacs</span>
<span class="linecomment">;;  completes your input to `minibuffer', which is the longest prefix</span>
<span class="linecomment">;;  match for `minib' among all command names.  The actual string that</span>
<span class="linecomment">;;  matches prefix `minib' among all candidates is, itself, `minib'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you hit `S-TAB', then each matching candidate contains a</span>
<span class="linecomment">;;  substring that matches your regexp input `minib'.  In this case,</span>
<span class="linecomment">;;  that substring is `minib', just as in the prefix-matching case.</span>
<span class="linecomment">;;  And, as in the prefix case, each matching candidate also includes</span>
<span class="linecomment">;;  a longer substring, `minibuffer', which includes what your input</span>
<span class="linecomment">;;  matches for each candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles replaces your regexp input in the minibuffer by a common</span>
<span class="linecomment">;;  substring.  Icicles highlights this expanded common match in</span>
<span class="linecomment">;;  buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-common-match-highlight-Completions' (magenta foreground,</span>
<span class="linecomment">;;  by default).  What your input matches directly is highlighted in</span>
<span class="linecomment">;;  `*Completions*' using face `icicle-match-highlight-Completions'</span>
<span class="linecomment">;;  (red foreground, by default).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is of course possible that a given regexp match different</span>
<span class="linecomment">;;  candidates differently, so that there is no common match.  In that</span>
<span class="linecomment">;;  case, only the individual matches are highlighted in</span>
<span class="linecomment">;;  `*Completions*' - you will see only red, no magenta, highlighting.</span>
<span class="linecomment">;;  For example, if your regexp input is `min.*buf' then various</span>
<span class="linecomment">;;  different substrings (such as `minibuf' from `minibuffer-complete'</span>
<span class="linecomment">;;  and `mint-truncate-buf' from `comint-truncate-buffer') are</span>
<span class="linecomment">;;  highlighted in red, but these share no common substring.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You will also see only red highlighting if what your input matches</span>
<span class="linecomment">;;  directly is the same as the expanded common match.  For example,</span>
<span class="linecomment">;;  if a function `moccur-regexp-read-from-minibuf' is defined (it is</span>
<span class="linecomment">;;  in library `color-moccur.el'), and your input to `C-h f' is</span>
<span class="linecomment">;;  `min[^-]*buf', then only `minibuf' is highlighted in red.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Expanded-common-match completion is convenient, but when</span>
<span class="linecomment">;;  apropos-completing you often need to try variants of a regexp,</span>
<span class="linecomment">;;  editing it and observing which candidates match in</span>
<span class="linecomment">;;  `*Completions*', until you get the regexp right.</span>
<span class="linecomment">;;  Expanded-common-match completion has the disadvantage that you</span>
<span class="linecomment">;;  lose your regexp as input, which makes it hard to edit it!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To retrieve it, use `C-l' (`icicle-retrieve-previous-input')</span>
<span class="linecomment">;;  during completion.  You can repeat `C-l' to retrieve older</span>
<span class="linecomment">;;  completion inputs, cycling among them, and you can use `C-S-l'</span>
<span class="linecomment">;;  (that is, `C-L') to cycle previous inputs in the other direction -</span>
<span class="linecomment">;;  see (@&gt; "History Enhancements").  You can set option</span>
<span class="linecomment">;;  `icicle-expand-input-to-common-match-flag' to `nil' to turn off</span>
<span class="linecomment">;;  expanded-common-match completion altogether, if you prefer.  You</span>
<span class="linecomment">;;  can also toggle it from the minibuffer at any time, using `C-;'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just what is meant by the "expanded common match" that Icicles</span>
<span class="linecomment">;;  finds?  It is the longest match of your input pattern that is</span>
<span class="linecomment">;;  common to all candidates and also contains the first input match</span>
<span class="linecomment">;;  in the first or second candidate, whichever is longer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For apropos completion, this is not always the longest common</span>
<span class="linecomment">;;  match of your input, but in most cases it is, and it is quicker to</span>
<span class="linecomment">;;  compute.  In general, the longest common match does not</span>
<span class="linecomment">;;  necessarily contain the first match of your input with either the</span>
<span class="linecomment">;;  first candidate or the second candidate.  It might contain a</span>
<span class="linecomment">;;  different input match from the first in both the first and second</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, with input `a' and candidates `abacb', `abbac', and</span>
<span class="linecomment">;;  `bacba' (in that order), `bac' is the longest common match.  But</span>
<span class="linecomment">;;  `a' is the longest common match that contains the first match in</span>
<span class="linecomment">;;  the first candidate.  It is the second match of `a' against</span>
<span class="linecomment">;;  `abacb' that yields `bac'.  Likewise for the second candidate: it</span>
<span class="linecomment">;;  is the second match of `a' against `abbac' that yields `bac'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So in this case Icicles will use `a' as the expanded input and</span>
<span class="linecomment">;;  miss the longest common match.  If the candidate order is</span>
<span class="linecomment">;;  different, so that `bacba' is either the first or the second</span>
<span class="linecomment">;;  candidate, then Icicles finds the longest common match, because</span>
<span class="linecomment">;;  the first match of `a' against `bacba' yields `bac'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The reason that Icicles common-match expansion typically finds the</span>
<span class="linecomment">;;  longest common match is that your input typically matches the</span>
<span class="linecomment">;;  first or the second candidate in only one place.  And the longer</span>
<span class="linecomment">;;  the input you type, the more likely this is.  In practice, it is</span>
<span class="linecomment">;;  only with very short input such as `a' that Icicles expansion</span>
<span class="linecomment">;;  sometimes misses the longest common match.  Icicles independently</span>
<span class="linecomment">;;  tries two candidates (first and second) as its starting point, to</span>
<span class="linecomment">;;  increase the probability of finding the longest common match.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is also technically incorrect to speak of "the" longest common</span>
<span class="linecomment">;;  match: in general, there can be more than one.  For example, if</span>
<span class="linecomment">;;  the input is `a' and the candidates are `abab', `abba', and</span>
<span class="linecomment">;;  `baba', then both `ab' and `ba' are longest common substrings.</span>
<span class="linecomment">;;  Again, however, for typical input and typical candidates there is</span>
<span class="linecomment">;;  a single longest common match, and Icicles finds it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that Icicles expanded common match is not just a common</span>
<span class="linecomment">;;  substring among all of the candidates that are matched by your</span>
<span class="linecomment">;;  input pattern.  It is a substring common to all candidates matched</span>
<span class="linecomment">;;  by your input, but a substring that also matches your input.  For</span>
<span class="linecomment">;;  example, with apropos completion input `a.z' and candidates `abz'</span>
<span class="linecomment">;;  and `apz', there is no expanded common match.  The substring `a'</span>
<span class="linecomment">;;  is common to both candidates, but it is not matched by the</span>
<span class="linecomment">;;  (complete) input pattern.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Finally, note that in Emacs 20 no common match is found if your</span>
<span class="linecomment">;;  input or any of the candidates contains binary data.  This is</span>
<span class="linecomment">;;  because function `string-match' cannot handle strings with binary</span>
<span class="linecomment">;;  data in Emacs 20.</span>
 
<span class="linecomment">;;(@* "Progressive Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Progressive Completion</span>
<span class="linecomment">;;  ----------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Perhaps the best way to explain this feature is to use a familiar</span>
<span class="linecomment">;;  analogy.  Unix or GNU/Linux command `grep' takes a</span>
<span class="linecomment">;;  regular-expression argument, and matches it against lines in</span>
<span class="linecomment">;;  files.  A common idiom that people use is to chain, or cascade,</span>
<span class="linecomment">;;  multiple calls to `grep', using the output of one as the input to</span>
<span class="linecomment">;;  the next.  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    grep plant *.txt | grep food | grep mineral</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The output of the search for "plant" is used as the input for the</span>
<span class="linecomment">;;  search for "food", and the output of that search serves as the</span>
<span class="linecomment">;;  input for the search for "mineral".  The order of the three</span>
<span class="linecomment">;;  component searches can make a difference in terms of performance,</span>
<span class="linecomment">;;  but not in terms of the result, which is always the set of lines</span>
<span class="linecomment">;;  in files *.txt that match "plant" AND "food" AND "mineral", in any</span>
<span class="linecomment">;;  order.  Each of the `grep' operations defines a set of matches,</span>
<span class="linecomment">;;  and the chain of `grep' operations effects the intersection of</span>
<span class="linecomment">;;  those sets.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, you could try to accomplish the same thing with a</span>
<span class="linecomment">;;  single call to `grep' using a complex regexp.  But why would you?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Moreover, it is in fact impossible to express such an unordered</span>
<span class="linecomment">;;  set intersection using a single regexp.  On their own, regular</span>
<span class="linecomment">;;  expressions cannot express set intersection (conjunction) or</span>
<span class="linecomment">;;  complementing (negation).  (However, most `grep' programs provide</span>
<span class="linecomment">;;  a way to obtain the lines that do not match a regexp.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The same idea of combining multiple regexp matches is behind the</span>
<span class="linecomment">;;  Icicles feature of progressive completion: instead of trying to</span>
<span class="linecomment">;;  come up with a single complex regexp that does what you want, try</span>
<span class="linecomment">;;  getting there a step at a time:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   1. Match an input regexp against the set of all possible</span>
<span class="linecomment">;;      completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   2. Narrow the set of matched candidates by matching them against</span>
<span class="linecomment">;;      another input regexp (or by filtering them with a predicate).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   3. Narrow those results down by matching them against a third</span>
<span class="linecomment">;;      input regexp (or by filtering them with another predicate).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   4... And so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`M-*': Matching Additional Regexps")</span>
<span class="linecomment">;;  ** `M-*': Matching Additional Regexps **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During completion, `M-*' is bound in the minibuffer to command</span>
<span class="linecomment">;;  `icicle-narrow-candidates', which prompts for a new regexp and</span>
<span class="linecomment">;;  matches it against the current set of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, suppose that you want to know about an Emacs function</span>
<span class="linecomment">;;  that deletes the character to the left of point (that is,</span>
<span class="linecomment">;;  backward).  You do not recall if it is `delete-character-back',</span>
<span class="linecomment">;;  `delete-backward-char', `character-delete-backward', or whatever.</span>
<span class="linecomment">;;  You take a guess that the name contains `delete', `char', and</span>
<span class="linecomment">;;  `back'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   1. `C-h f char S-TAB' displays function names that contain</span>
<span class="linecomment">;;      `char'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   2. `M-* delete' narrows that set of function names to those that</span>
<span class="linecomment">;;      also contain `delete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   3. `M-* back' narrows the set of matching names further, to those</span>
<span class="linecomment">;;      that also contain `back'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This displays a list of functions like this in `*Completions*'</span>
<span class="linecomment">;;  (your list might be somewhat different):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    backward-delete-char        backward-delete-char-untabify</span>
<span class="linecomment">;;    delete-backward-char        icicle-backward-delete-char-untabify</span>
<span class="linecomment">;;    icicle-delete-backward-char</span>
<span class="linecomment">;;    quail-conversion-backward-delete-char</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Then, of course, you can pick one (or you can use `C-M-next'</span>
<span class="linecomment">;;  repeatedly to view the doc of each of these functions in turn -</span>
<span class="linecomment">;;  see (@&gt; "Get Help on Candidates")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You get the idea.  This feature is both very simple to use and</span>
<span class="linecomment">;;  very useful.  It's easy to appreciate using multiple simple</span>
<span class="linecomment">;;  matching steps (regexp or not) instead of a single regexp.  Try it</span>
<span class="linecomment">;;  once, and you'll be hooked.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Successive Approximation...")</span>
<span class="linecomment">;;  ** Successive Approximation... **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use as many invocations of `M-*' (and of `M-&', described</span>
<span class="linecomment">;;  in the next section) as you like, in any order.  It works with</span>
<span class="linecomment">;;  both prefix completion and apropos completion.  You can, for</span>
<span class="linecomment">;;  instance, first use `TAB' to require the target to start with some</span>
<span class="linecomment">;;  string, and then use `M-*' to specify other patterns that parts of</span>
<span class="linecomment">;;  it must also match.  However, it of course makes no sense to use</span>
<span class="linecomment">;;  `TAB' instead of `S-TAB' after you use `M-*': once you've said</span>
<span class="linecomment">;;  that the target must start with "fo" there is no sense saying that</span>
<span class="linecomment">;;  it also starts with "ti"!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, instead of using `S-TAB' followed by `M-*', you can</span>
<span class="linecomment">;;  use `S-SPC' (command `icicle-apropos-complete-and-narrow') to do</span>
<span class="linecomment">;;  the same thing.  You can thus use only `S-SPC', any number of</span>
<span class="linecomment">;;  times, to choose a candidate by narrowing down the matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I call this process of completion by successive approximation, or</span>
<span class="linecomment">;;  progressively narrowing the candidate set, "progressive</span>
<span class="linecomment">;;  completion".  If the name "incremental completion" (= icompletion)</span>
<span class="linecomment">;;  were not already taken to mean incremental completion *help*</span>
<span class="linecomment">;;  (which performs no completion), then that might be a good name for</span>
<span class="linecomment">;;  this.  This might also be called "stepped", "cascaded", or</span>
<span class="linecomment">;;  "piecewise" completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another possible name for it would be "multiple completion", but I</span>
<span class="linecomment">;;  use that to stand for simultaneous (parallel) completion of</span>
<span class="linecomment">;;  multiple parts of a compound target, which is something different</span>
<span class="linecomment">;;  (see (@file :file-name "icicles-doc2.el" :to "Multi-Completions")).</span>
<span class="linecomment">;;  Progressive completion is a set of mini-completions that are wired</span>
<span class="linecomment">;;  in series, not in parallel.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that when you use `M-*' (or `S-SPC') in the minibuffer, it</span>
<span class="linecomment">;;  calls `completing-read' or `read-file-name', which creates a</span>
<span class="linecomment">;;  recursive minibuffer.  That is, the minibuffer depth is increased.</span>
<span class="linecomment">;;  (This is not the case for `M-&', however.)  In vanilla Emacs,</span>
<span class="linecomment">;;  there is no indicator of the current minibuffer depth, and this</span>
<span class="linecomment">;;  can sometimes be disorienting.  Each time you use `M-*' you push</span>
<span class="linecomment">;;  down one level of minibuffer recursion (that is, minibuffer depth</span>
<span class="linecomment">;;  is incremented).  Each time you use, say, `C-g', you pop up one</span>
<span class="linecomment">;;  level of minibuffer recursion (that is, minibuffer depth is</span>
<span class="linecomment">;;  decremented).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use library `mb-depth.el', which is included with Emacs 23</span>
<span class="linecomment">;;  and which also works with Emacs 22, Icicle mode takes advantage of</span>
<span class="linecomment">;;  this library by indicating the current depth in the minibuffer.  I</span>
<span class="linecomment">;;  recommend you also use my library `mb-depth+.el', which lets you</span>
<span class="linecomment">;;  customize the form and face of the depth indicator.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use my library `oneonone.el', then you get visual feedback</span>
<span class="linecomment">;;  on the current minibuffer depth.  One-On-One Emacs gives you a</span>
<span class="linecomment">;;  standalone minibuffer frame, and it changes the background hue</span>
<span class="linecomment">;;  (color) of that frame slightly with each change in minibuffer</span>
<span class="linecomment">;;  depth.  This is especially helpful with Icicles, where use of</span>
<span class="linecomment">;;  `M-*' (or `S-SPC') is common.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There is a slight difference in behavior between Icicles commands</span>
<span class="linecomment">;;  and some other Emacs commands when you accept input after `M-*'.</span>
<span class="linecomment">;;  When possible, Icicles accepts your input and passes it</span>
<span class="linecomment">;;  immediately to the top level, bypassing any intermediate recursive</span>
<span class="linecomment">;;  minibuffer levels that are waiting for input.  However, Emacs</span>
<span class="linecomment">;;  commands that are defined with literal-string `interactive' specs,</span>
<span class="linecomment">;;  such as (interactive "fFile: "), do not use `completing-read' or</span>
<span class="linecomment">;;  `read-file-name', so there is no way for Icicles to take this</span>
<span class="linecomment">;;  shortcut with them.  In that case, you will simply need to hit</span>
<span class="linecomment">;;  `RET' again to accept your input at each recursive minibuffer</span>
<span class="linecomment">;;  level, until you get back to the top level.  Sorry for this</span>
<span class="linecomment">;;  inconvenience!  If you are an Emacs-Lisp programmer, note that</span>
<span class="linecomment">;;  this is one reason to use `completing-read' and `read-file-name'</span>
<span class="linecomment">;;  when you write commands that use completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: If you use progressive completion with file names in Emacs</span>
<span class="linecomment">;;  20 or 21, `M-*' calls `completing-read', not `read-file-name'.</span>
<span class="linecomment">;;  This is because `read-file-name' does not accept a PREDICATE</span>
<span class="linecomment">;;  argument before Emacs 22.  The effect is that instead of there</span>
<span class="linecomment">;;  being a default directory for completion, the current directory at</span>
<span class="linecomment">;;  the time you hit `M-*' is tacked onto each file name, to become</span>
<span class="linecomment">;;  part of the completion candidates themselves.  Yes, this is a</span>
<span class="linecomment">;;  hack.  It works, but be aware of the behavior.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Progressive completion lets you match multiple regexps, some of</span>
<span class="linecomment">;;  which could of course be literal substrings, with their regexp</span>
<span class="linecomment">;;  special characters, if any, escaped.  If you need to match such</span>
<span class="linecomment">;;  substrings at particular locations in the target completion</span>
<span class="linecomment">;;  candidate, then progressive completion will not do the job - it</span>
<span class="linecomment">;;  matches its component regexps independently.  You can regexp-quote</span>
<span class="linecomment">;;  (escape) parts or all of your input using `M-%'</span>
<span class="linecomment">;;  (`icicle-regexp-quote-input').</span>
<span class="linecomment">;;  See (@&gt; "Quoting (Escaping) Special Characters")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`M-&': Satisfying Additional Predicates")</span>
<span class="linecomment">;;  ** `M-&': Satisfying Additional Predicates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use Icicles, then you will use `M-*' very often.  This</span>
<span class="linecomment">;;  section describes a seldom-used feature that can be useful in</span>
<span class="linecomment">;;  certain contexts.  If you are new to Icicles or you are unfamiliar</span>
<span class="linecomment">;;  with Emacs Lisp, then you might want to just skim this section or</span>
<span class="linecomment">;;  skip it and come back to it later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as you can use `M-*' to narrow the set of candidates by</span>
<span class="linecomment">;;  matching an additional regexp, so you can use `M-&' (bound to</span>
<span class="linecomment">;;  `icicle-narrow-candidates-with-predicate') to narrow by satisfying</span>
<span class="linecomment">;;  an additional predicate.  The idea is the same; the only</span>
<span class="linecomment">;;  difference is that, instead of typing a regexp to match, you type</span>
<span class="linecomment">;;  a predicate to satisfy.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The predicate is a Boolean function of a single completion</span>
<span class="linecomment">;;  candidate.  At the prompt, you enter its name or its</span>
<span class="linecomment">;;  lambda-expression definition (anonymous function).  The predicate</span>
<span class="linecomment">;;  is used the same way as the PREDICATE argument to</span>
<span class="linecomment">;;  `completing-read' and `read-file-name'.  This means that the</span>
<span class="linecomment">;;  candidate argument to the predicate is whatever is used in the</span>
<span class="linecomment">;;  original call to `completing-read' or `read-file-name'; it is not</span>
<span class="linecomment">;;  just a string such as you see in buffer `*Completions*'.  To</span>
<span class="linecomment">;;  provide an appropriate predicate, you must be familiar with the</span>
<span class="linecomment">;;  kind of candidate expected by the command you invoked before just</span>
<span class="linecomment">;;  before `M-&'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `describe-function' (`C-h f') uses candidates that are</span>
<span class="linecomment">;;    symbols.  An appropriate predicate would accept a symbol as</span>
<span class="linecomment">;;    argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-search' (`C-c `') uses candidates that have this</span>
<span class="linecomment">;;    form: (CONTEXT . MARKER), where CONTEXT is a string, the search</span>
<span class="linecomment">;;    hit (search context), and MARKER is a buffer marker that locates</span>
<span class="linecomment">;;    the CONTEXT.  An appropriate predicate would accept such a</span>
<span class="linecomment">;;    candidate as argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Although entering a lambda expression at a prompt might not seem</span>
<span class="linecomment">;;  too convenient, you can at least retrieve previously entered</span>
<span class="linecomment">;;  predicates (using `M-p' and so on).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also use `C-M-&' (bound to</span>
<span class="linecomment">;;  `icicle-save-predicate-to-variable') at any time during completion</span>
<span class="linecomment">;;  to save the current predicate as a string-valued variable.  By</span>
<span class="linecomment">;;  default, the variable is `icicle-input-string'.  You can then</span>
<span class="linecomment">;;  retrieve the saved string later, using `C-=' at the prompt for</span>
<span class="linecomment">;;  `M-&'.  The current predicate is what is saved.  You can build up</span>
<span class="linecomment">;;  a complex predicate, and then save it for later use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The inconvenience of typing an Emacs-Lisp sexp must be balanced</span>
<span class="linecomment">;;  against the power of applying predicates on the fly.  Whereas</span>
<span class="linecomment">;;  regexp matching is purely syntactic, with a predicate you can</span>
<span class="linecomment">;;  perform semantic tests.  During search, for instance, you can look</span>
<span class="linecomment">;;  not only for a syntax match; you can look for matching search</span>
<span class="linecomment">;;  candidates that also belong to a particular class of objects</span>
<span class="linecomment">;;  (e.g. function, variable, type) or that satisfy some other</span>
<span class="linecomment">;;  semantic property.</span>
<span class="linecomment">;;  See also (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Sets of Completion Candidates") for another way to perform</span>
<span class="linecomment">;;    a set intersection on sets of candidate completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    for a way to search using two regexps - command `icicle-search'</span>
<span class="linecomment">;;    uses the same idea as that behind progressive completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Compile/Grep Search")</span>
<span class="linecomment">;;    for a way to grep files using multiple levels of regexps, and</span>
<span class="linecomment">;;    performing selected replacements.</span>
 
<span class="linecomment">;;(@* "Regressive Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regressive Completion</span>
<span class="linecomment">;;  ---------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Though generally less useful than progressive completion, you can</span>
<span class="linecomment">;;  also widen, instead of narrow, the current set of completion</span>
<span class="linecomment">;;  candidates, by providing an alternative pattern (regexp) to match.</span>
<span class="linecomment">;;  By analogy, I call this "regressive completion".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The analogy is not exact.  By definition, your current input is</span>
<span class="linecomment">;;  always matched against all candidates in the domain of discourse.</span>
<span class="linecomment">;;  With progressive completion, a recursive minibuffer is entered for</span>
<span class="linecomment">;;  each new pattern to match.  The candidates that matched the</span>
<span class="linecomment">;;  previous input of the progression become the new domain of</span>
<span class="linecomment">;;  discourse for the current act (recursive level) of completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That same technique is not applicable for widening.  Instead, you</span>
<span class="linecomment">;;  enter, using `RET', a new pattern to match as an alternative, and</span>
<span class="linecomment">;;  Icicles changes the current input to a regexp that matches either</span>
<span class="linecomment">;;  what the previous input matched or the alternative pattern.  In</span>
<span class="linecomment">;;  other words, it is just a short cut for typing a regexp that</span>
<span class="linecomment">;;  matches a choice: \(...\|...\).  The domain of discourse remains</span>
<span class="linecomment">;;  the same - in particular, there is no way to widen the domain of</span>
<span class="linecomment">;;  discourse like narrowing narrows it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You use `M-+' (`icicle-widen-candidates') for regressive</span>
<span class="linecomment">;;  completion - think of the `+' as set union (OR), just as you think</span>
<span class="linecomment">;;  of the `*' in `M-*' as set intersection (AND).  And, just as for</span>
<span class="linecomment">;;  progressive completion, there is a shortcut, `S-backspace', for</span>
<span class="linecomment">;;  `S-TAB' followed by `M-+'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you want to see all of the candidates that contain</span>
<span class="linecomment">;;  either `for' or `back', you could type `\(for\|back\)' in the</span>
<span class="linecomment">;;  minibuffer, or you could just type `for', then `S-backspace' (or</span>
<span class="linecomment">;;  `S-TAB' followed by `M-+'), then `back'.  Icicles replaces your</span>
<span class="linecomment">;;  input by `\(for\|back\)'.  You can continue with additional</span>
<span class="linecomment">;;  alternative match patterns.  And you can combine narrowing with</span>
<span class="linecomment">;;  widening, that is, progressive with regressive completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can of course cycle among all matching candidates, regardless</span>
<span class="linecomment">;;  of which alternative they match.  One use of regressive completion</span>
<span class="linecomment">;;  is with Icicles search - it corresponds to the OR searching of</span>
<span class="linecomment">;;  common search engines.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Gotcha: When completing file names that are not absolute</span>
<span class="linecomment">;;  (e.g. using `C-x C-f', not `C-u C-x C-f'), be sure that the</span>
<span class="linecomment">;;  default directory is not included in your minibuffer input when</span>
<span class="linecomment">;;  you hit `M-+'.  You do not want the overall regexp that `M-+'</span>
<span class="linecomment">;;  constructs to be something like \(/my/default/dir/foo\|bar\) - you</span>
<span class="linecomment">;;  want it to be just \(foo\|bar\).  For absolute file name</span>
<span class="linecomment">;;  completion there is no such problem, because the completion</span>
<span class="linecomment">;;  candidates themselves have a directory component.  So either use a</span>
<span class="linecomment">;;  `nil' value of `insert-default-directory' or use `M-k' to remove</span>
<span class="linecomment">;;  the directory component before hitting `M-+'.</span>
 
<span class="linecomment">;;(@* "Completion On Demand")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Completion On Demand</span>
<span class="linecomment">;;  --------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When the minibuffer is active for your input, completion is not</span>
<span class="linecomment">;;  always available.  Functions such as `completing-read' and</span>
<span class="linecomment">;;  `read-file-name' provide completion, but other functions that read</span>
<span class="linecomment">;;  input in the minibuffer, such as `read-from-minibuffer' and</span>
<span class="linecomment">;;  `read-string', do not provide completion.</span>
<span class="linecomment">;;  (See (@&gt; "Completion Status Indicators"), for how to tell when</span>
<span class="linecomment">;;  completion is available in Icicles.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But in Icicles you can always invoke (lax) completion to insert</span>
<span class="linecomment">;;  some completed text in the minibuffer - this is completion on</span>
<span class="linecomment">;;  demand.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  On-demand completion is always available to insert a file name.</span>
<span class="linecomment">;;  You invoke this using `C-M-F', that is, `C-M-S-f'</span>
<span class="linecomment">;;  (`icicle-read+insert-file-name').  A recursive minibuffer is used</span>
<span class="linecomment">;;  to perform the completion.  The result of completing is inserted</span>
<span class="linecomment">;;  at point in the parent minibuffer, without replacing any other</span>
<span class="linecomment">;;  text that might already be there.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use this feature to add multiple file or directory names</span>
<span class="linecomment">;;  to the same minibuffer input.  In this way, for instance, you can</span>
<span class="linecomment">;;  use it to add particular file or directory names as arguments to a</span>
<span class="linecomment">;;  shell command that you input in the minibuffer.  By default, a</span>
<span class="linecomment">;;  relative name is inserted, but if you use a prefix argument then</span>
<span class="linecomment">;;  the directory component is included.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similarly, you can use `C-M-C', that is, `C-M-S-c'</span>
<span class="linecomment">;;  (`icicle-completing-read+insert'), to invoke non file-name</span>
<span class="linecomment">;;  completion.  This, however, is available only if the command</span>
<span class="linecomment">;;  reading from the minibuffer allows it, by defining a set of</span>
<span class="linecomment">;;  possible completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The actual keys used for on-demand completion are customizable,</span>
<span class="linecomment">;;  using options `icicle-read+insert-file-name-keys' and</span>
<span class="linecomment">;;  `icicle-completing-read+insert-keys'.  The default values are</span>
<span class="linecomment">;;  `C-M-S-f' and `C-M-S-c'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another kind of on-demand completion is provided by `M-o'</span>
<span class="linecomment">;;  (`icicle-insert-history-element').  Again, this is always</span>
<span class="linecomment">;;  available in the minibuffer, regardless of whether input is being</span>
<span class="linecomment">;;  read with completion.  This invokes completion against the entries</span>
<span class="linecomment">;;  in the current minibuffer history.</span>
<span class="linecomment">;;  See (@&gt; "History Enhancements").</span>
 
<span class="linecomment">;;(@* "Moving Between the Minibuffer and Other Buffers")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Moving Between the Minibuffer and Other Buffers</span>
<span class="linecomment">;;  -----------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes, when the minibuffer is active, you might want to move</span>
<span class="linecomment">;;  the cursor and focus from the minibuffer back to the original</span>
<span class="linecomment">;;  buffer from which you activated the minibuffer.  When you are in</span>
<span class="linecomment">;;  Icicle mode, the `pause' key is bound (by default) to command</span>
<span class="linecomment">;;  `icicle-switch-to/from-minibuffer', which does that.  This lets</span>
<span class="linecomment">;;  you start minibuffer input (with or without completion), and then</span>
<span class="linecomment">;;  interrupt it to search, edit, and so on, in the original buffer.</span>
<span class="linecomment">;;  This same command (bound to `pause') then lets you switch back to</span>
<span class="linecomment">;;  the minibuffer - it acts as a toggle for the input focus; go back</span>
<span class="linecomment">;;  and forth as much as you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This can be especially useful when you use multi-commands (see</span>
<span class="linecomment">;;  (@&gt; "Multi-Commands")).  In that case, you often keep the</span>
<span class="linecomment">;;  minibuffer active for completion while performing multiple</span>
<span class="linecomment">;;  completion actions.  It can be handy to interrupt this to perform</span>
<span class="linecomment">;;  some normal editing or search, and then resume multi-command</span>
<span class="linecomment">;;  actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another use for this feature is to select text in the original</span>
<span class="linecomment">;;  buffer and then insert it in the minibuffer.  See also</span>
<span class="linecomment">;;  (@&gt; "Inserting Text Found Near the Cursor") for another way to do</span>
<span class="linecomment">;;  that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A somewhat related toggle is available using `C-insert'.  This</span>
<span class="linecomment">;;  lets you switch the focus between the minibuffer and buffer</span>
<span class="linecomment">;;  `*Completions*'.  See (@&gt; "*Completions* Display") for more</span>
<span class="linecomment">;;  information.</span>
 
<span class="linecomment">;;(@* "Inserting a Regexp from a Variable or Register")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Inserting a Regexp from a Variable or Register</span>
<span class="linecomment">;;  ----------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regexps are powerful, but they can sometimes be complex to compose</span>
<span class="linecomment">;;  and hard to remember once composed.  A shortcut is to compose a</span>
<span class="linecomment">;;  regexp that you want to use and assign it to an Emacs variable or</span>
<span class="linecomment">;;  register.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you assign it to a register (using `C-x r s'), then you can use</span>
<span class="linecomment">;;  `C-x r i' (`insert-register') in the minibuffer to insert it.  If</span>
<span class="linecomment">;;  you assign it to a string, then you can use `C-='</span>
<span class="linecomment">;;  (`icicle-insert-string-from-variable') to insert it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `C-u C-=' (provide a prefix argument) then you are</span>
<span class="linecomment">;;  prompted for the variable to use.  You can use any variable.</span>
<span class="linecomment">;;  Without `C-u', the default variable is used (no prompting),</span>
<span class="linecomment">;;  `icicle-input-string'.  So, for example, if `icicle-input-string'</span>
<span class="linecomment">;;  had value "[a-zA-Z]+" then it would match any completion candidate</span>
<span class="linecomment">;;  composed only of letters.  You can customize</span>
<span class="linecomment">;;  `icicle-input-string'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For convenience, instead of using Lisp evaluation of a sexp such</span>
<span class="linecomment">;;  as (setq icicle-input-string "[a-zA-Z]+") or (setq my-var ".*"),</span>
<span class="linecomment">;;  you can use Icicles command `icicle-save-string-to-variable' to</span>
<span class="linecomment">;;  save a regexp to a variable.  You are prompted for the regexp to</span>
<span class="linecomment">;;  save.  Just as for `icicle-insert-string-from-variable', with a</span>
<span class="linecomment">;;  prefix argument you are prompted for the variable to use; with no</span>
<span class="linecomment">;;  prefix argument the regexp is saved to variable</span>
<span class="linecomment">;;  `icicle-input-string'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way of inserting a string into the minibuffer is to use a</span>
<span class="linecomment">;;  negative prefix arg with `M-:' (e.g. `M-- M-:') during minibuffer</span>
<span class="linecomment">;;  input.  With this method, you can type not only a string-valued</span>
<span class="linecomment">;;  variable name but any Emacs-Lisp expression.  The expression need</span>
<span class="linecomment">;;  not evaluate to a string - whatever the result of evaluation is,</span>
<span class="linecomment">;;  it is pretty-printed in the minibuffer, to be used as part of your</span>
<span class="linecomment">;;  input text.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These shortcut features are especially convenient for use with</span>
<span class="linecomment">;;  command `icicle-search' - you can use it to search text for</span>
<span class="linecomment">;;  sentences, paragraphs, file names, URLs, dates, times, function</span>
<span class="linecomment">;;  definitions, and any other text entities that you can specify by</span>
<span class="linecomment">;;  regexp.  Create a library of regexp-valued variables that are</span>
<span class="linecomment">;;  useful to you, and use `C-=' to quickly access them in</span>
<span class="linecomment">;;  `icicle-search'.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;  for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Inserting Text Found Near the Cursor").</span>
 
<span class="linecomment">;;(@* "Special Characters in Input Patterns")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Special Characters in Input Patterns</span>
<span class="linecomment">;;  ------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regular-expression syntax treats some characters specially, but</span>
<span class="linecomment">;;  some of these special characters have another special meaning in</span>
<span class="linecomment">;;  Emacs when used with file-name inputs.  What about the conflict</span>
<span class="linecomment">;;  between interpreting characters such as `$', `\', `.', `?', and</span>
<span class="linecomment">;;  `*' as 1) regexp special characters and 2) special characters for</span>
<span class="linecomment">;;  file-name input?  For example, when inputting a file name, should</span>
<span class="linecomment">;;  `*' be treated as a regexp multiple-occurrences operator or as a</span>
<span class="linecomment">;;  file-name wildcard?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Emacs file-name input:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `$' can be used to prefix environment variables.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `*' and `?' can be used as wildcards, effectively inputting</span>
<span class="linecomment">;;    multiple file names at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `.' and `..' can be used to navigate a directory hierarchy.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `\' is a directory separator, like `/', on MS Windows, at least.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles handles the conflict by interpreting such characters as</span>
<span class="linecomment">;;  regexp special characters only during input completion and cycling</span>
<span class="linecomment">;;  - and then only if you do not escape them (with `\').  If present</span>
<span class="linecomment">;;  in the input when you finally accept it (using `RET'), they take</span>
<span class="linecomment">;;  on their normal Emacs meanings for file-name input:</span>
<span class="linecomment">;;  environment-variable prefix, wildcard, directory abbreviation, or</span>
<span class="linecomment">;;  directory separator.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, whenever there is a potential conflict of interpretation,</span>
<span class="linecomment">;;  the regexp meaning is used for completion and cycling, and the</span>
<span class="linecomment">;;  standard interpretation for file-name input is used for accepting</span>
<span class="linecomment">;;  the input.  So, for example, to get the wildcard interpretation of</span>
<span class="linecomment">;;  `*', just forego regexp completion and cycling.  And vice versa:</span>
<span class="linecomment">;;  forego the wildcard interpretation to use regexp completion and</span>
<span class="linecomment">;;  cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is in any case the behavior of vanilla Emacs as well.  If, in</span>
<span class="linecomment">;;  vanilla Emacs, you use `ici*' or `ici*.el' as input to `find-file'</span>
<span class="linecomment">;;  and hit `TAB', there is no completion available.  File-name</span>
<span class="linecomment">;;  globbing and completion are independent.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Because `?' is useful in regexp syntax, the standard Emacs</span>
<span class="linecomment">;;        minibuffer binding of `?', which just displays the</span>
<span class="linecomment">;;        completion-candidates list, is not used in Icicles.  In</span>
<span class="linecomment">;;        Icicles, `?' self-inserts in the minibuffer, like any other</span>
<span class="linecomment">;;        printable character.  (Use `TAB' or `S-TAB' to display the</span>
<span class="linecomment">;;        list.)  In standard Emacs, you must quote `?' or</span>
<span class="linecomment">;;        copy-and-paste it, to insert it in the minibuffer for use as</span>
<span class="linecomment">;;        a file-name wildcard.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The interpretation conflict for `\' (on MS Windows) is not really</span>
<span class="linecomment">;;  a problem, anyway.  Although you cannot use a backslash (`\') as a</span>
<span class="linecomment">;;  directory separator during apropos completion and cycling, you can</span>
<span class="linecomment">;;  always use a slash (`/') instead - even on MS Windows.  The best</span>
<span class="linecomment">;;  practice is to just break with MS-Windows syntax, and get in the</span>
<span class="linecomment">;;  habit of always using `/' as the directory-separator character.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But what if you copy an absolute filename from some MS Windows</span>
<span class="linecomment">;;  application, so it has backslashes, and you want to use it in</span>
<span class="linecomment">;;  Emacs?  You can go ahead and paste it in the minibuffer for</span>
<span class="linecomment">;;  filename completion, as long as you are not doing regexp</span>
<span class="linecomment">;;  completion.  You can (a) use prefix completion with it, (b) use</span>
<span class="linecomment">;;  `C-`' to turn on regexp quoting for apropos completion (so you can</span>
<span class="linecomment">;;  complete a substring), or (c) change the backslashes to slashes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Even if you always use only slash, not backslash, as a directory</span>
<span class="linecomment">;;  separator when inputting, however, it is possible that you could</span>
<span class="linecomment">;;  run into some trouble on MS Windows.  You might (knowingly or not)</span>
<span class="linecomment">;;  use `\' as a directory separator in the values of environment</span>
<span class="linecomment">;;  variables that you use as part of file-name input.  If you are</span>
<span class="linecomment">;;  regexp completing, then those backslashes will be treated as</span>
<span class="linecomment">;;  regexp escapes.  So you should use only non-regexp completion with</span>
<span class="linecomment">;;  input that includes environment variables whose expansions might</span>
<span class="linecomment">;;  include backslashes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The interpretation conflict for `$' is also not a real problem.</span>
<span class="linecomment">;;  You can get the effect of both interpretations of `$' at the same</span>
<span class="linecomment">;;  time, because Icicles recognizes that `$' at the end of input</span>
<span class="linecomment">;;  cannot be an environment-variable prefix.  This means, for</span>
<span class="linecomment">;;  example, that you can use a pattern such as `$HOME.*t$' to match</span>
<span class="linecomment">;;  the files in your home directory whose names end in `t'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first `$' here is not treated specially during regexp matching</span>
<span class="linecomment">;;  and cycling; the environment variable `$HOME' is expanded by the</span>
<span class="linecomment">;;  shell to a directory name.  The second `$' is treated as the</span>
<span class="linecomment">;;  regexp special character that matches at the end of a line.  When</span>
<span class="linecomment">;;  using environment variables, you can also enclose them in braces:</span>
<span class="linecomment">;;  `${HOME}', for example.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Starting with Emacs 23, if option</span>
<span class="linecomment">;;  `icicle-TAB-completion-methods' includes `vanilla', and you choose</span>
<span class="linecomment">;;  `vanilla' completion for `TAB' (by cycling using `C-(' or by</span>
<span class="linecomment">;;  customizing `icicle-TAB-completion-methods' to use `vanilla' as</span>
<span class="linecomment">;;  the default), then Icicles `TAB' completion will complete an</span>
<span class="linecomment">;;  environment variable during file-name completion.  This is in</span>
<span class="linecomment">;;  addition to the traditional shell expansion of a variable when you</span>
<span class="linecomment">;;  hit `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tip: Because slash (`/') is about the only non-word syntax</span>
<span class="linecomment">;;       character that is likely to appear in file-name completions,</span>
<span class="linecomment">;;       you can usually use `\W$' to match only directories (by</span>
<span class="linecomment">;;       matching the `/' at the end of their names).  `\W' is the</span>
<span class="linecomment">;;       regexp pattern that matches any character that does not</span>
<span class="linecomment">;;       appear in words.  For example, you can use `${HOME}\W$' to</span>
<span class="linecomment">;;       match all direct subdirectories in your home directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Quoting (Escaping) Special Characters")</span>
<span class="linecomment">;;  ** Quoting (Escaping) Special Characters **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can toggle interpretation vs escaping of regexp special</span>
<span class="linecomment">;;  characters at any time, using `C-`' in the minibuffer (command</span>
<span class="linecomment">;;  `icicle-toggle-regexp-quote').  Escaping special characters this</span>
<span class="linecomment">;;  way means they are no longer special; they simply match</span>
<span class="linecomment">;;  themselves.  This has the effect of reducing apropos completion to</span>
<span class="linecomment">;;  simple substring completion.  If you never want to use regexp</span>
<span class="linecomment">;;  matching (*not* recommended!), you can customize user option</span>
<span class="linecomment">;;  `icicle-regexp-quote-flag', setting it to non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Apropos (regexp) completion contains literal substring completion</span>
<span class="linecomment">;;  as a (common) special case.  Sometimes you want to use regexp</span>
<span class="linecomment">;;  completion, but you also want to match a literal substring that</span>
<span class="linecomment">;;  contains special characters.  You can of course quote (escape)</span>
<span class="linecomment">;;  each of these characters by hand.  Alternatively, you can use</span>
<span class="linecomment">;;  `M-%' (`icicle-regexp-quote-input') to quote the text that you</span>
<span class="linecomment">;;  want to match literally.  If the region is active, then it is</span>
<span class="linecomment">;;  quoted; otherwise, your entire minibuffer input is quoted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that if a substring that you want to match literally can</span>
<span class="linecomment">;;  occur anywhere in the target completion candidate, then it is</span>
<span class="linecomment">;;  simpler to just use progressive completion.  Quoting a literal</span>
<span class="linecomment">;;  substring is useful when the overall regexp requires it to be at a</span>
<span class="linecomment">;;  certain location in the target.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    for how to use Icicles regexp-matching to open Dired on sets of</span>
<span class="linecomment">;;    files that you might not be able to specify using file-name</span>
<span class="linecomment">;;    wildcards.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Multi-Commands") for a way to open multiple files whose</span>
<span class="linecomment">;;    names match a regular expression.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "File-Name and Directory-Name Completion Tips")</span>
<span class="linecomment">;;    for:</span>
<span class="linecomment">;;    - Information about abbreviating your home directory as `~' or</span>
<span class="linecomment">;;      expanding it.</span>
<span class="linecomment">;;    - A way to locate and open files by regexp anywhere in your file</span>
<span class="linecomment">;;      system - that is, match against directory-name as well as</span>
<span class="linecomment">;;      file-name components.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Progressive Completion")</span>
 
<span class="linecomment">;;(@* "Exiting the Minibuffer Without Confirmation")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Exiting the Minibuffer Without Confirmation</span>
<span class="linecomment">;;  -------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Normally, if you exit the minibuffer with input that only</span>
<span class="linecomment">;;  partially matches a completion candidate, the value you input is</span>
<span class="linecomment">;;  exactly what you typed.  That is, exiting does not automatically</span>
<span class="linecomment">;;  complete your input - what you type is what you get.  This is</span>
<span class="linecomment">;;  "lax" (or "permissive") completion, and it is desirable most of</span>
<span class="linecomment">;;  the time, because it lets you input a value that does not</span>
<span class="linecomment">;;  correspond to any of the completion candidates.  This is how, for</span>
<span class="linecomment">;;  instance, you can use `C-x C-f' to open a new file or `C-x b' to</span>
<span class="linecomment">;;  create a new buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, some people prefer "strict" completion: limiting input to</span>
<span class="linecomment">;;  the available completion candidates.  This can be handy in the</span>
<span class="linecomment">;;  case of switching to a buffer, for instance.  If you have a buffer</span>
<span class="linecomment">;;  named `new-ideas.txt', you might like to be able to type only</span>
<span class="linecomment">;;  `new' followed by `RET', and not have to first complete the input</span>
<span class="linecomment">;;  text.  This is the behavior of libraries `ido.el' and</span>
<span class="linecomment">;;  `iswitchb.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is the command you use that decides whether `RET' first</span>
<span class="linecomment">;;  completes your input before exiting the minibuffer (strict</span>
<span class="linecomment">;;  completion) or not (lax completion).  This is done in the command</span>
<span class="linecomment">;;  definition by providing a non-`nil' or `nil' REQUIRE-MATCH</span>
<span class="linecomment">;;  argument to function `completing-read', which prompts you and</span>
<span class="linecomment">;;  reads your input, possibly completing it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use standard Emacs command `switch-to-buffer' then</span>
<span class="linecomment">;;  completion is lax: `RET' does not complete your input `new' to</span>
<span class="linecomment">;;  `new-ideas.txt'; it simply accepts your input as is, and creates a</span>
<span class="linecomment">;;  new buffer with that name, `new'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using `S-RET' to Accept a Partial Match")</span>
<span class="linecomment">;;  ** Using `S-RET' to Accept a Partial Match **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, Icicles command `icicle-buffer', not vanilla command</span>
<span class="linecomment">;;  `switch-to-buffer', is bound to `C-x b' in Icicle mode.  The</span>
<span class="linecomment">;;  default behavior of `icicle-buffer' is the same as the behavior of</span>
<span class="linecomment">;;  `switch-to-buffer' with respect to `RET'.  However, you can obtain</span>
<span class="linecomment">;;  the complete-and-exit `RET' behavior with `icicle-buffer' by</span>
<span class="linecomment">;;  setting option `icicle-buffer-require-match-flag' to</span>
<span class="linecomment">;;  `partial-match-ok'.  This value overrides the REQUIRE-MATCH</span>
<span class="linecomment">;;  argument to `completing-read', in effect forcing it to `t'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever completion is strict, requiring a match against one of</span>
<span class="linecomment">;;  the completion candidates (typically, an existing file or buffer</span>
<span class="linecomment">;;  name), you can complete and exit the minibuffer all at once, with</span>
<span class="linecomment">;;  only partial input in the minibuffer, by using `RET'.  But what</span>
<span class="linecomment">;;  about apropos completion?  Simply use `S-RET'</span>
<span class="linecomment">;;  (`icicle-apropos-complete-and-exit') instead of `RET': `RET' is</span>
<span class="linecomment">;;  standard in Emacs and uses prefix completion; `S-RET' is specific</span>
<span class="linecomment">;;  to Icicles and uses apropos completion.  For example, you can type</span>
<span class="linecomment">;;  `idea' followed by `S-RET' to switch to buffer `new-ideas.txt'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: You can customize `icicle-top-level-key-bindings' to prevent</span>
<span class="linecomment">;;  the rebinding of `C-x b' in Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Accepting Partial Matches by Default")</span>
<span class="linecomment">;;  ** Accepting Partial Matches by Default **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For those people who prefer that a partial match always be</span>
<span class="linecomment">;;  accepted immediately, regardless of the context (whether a match</span>
<span class="linecomment">;;  is required or not) and without having to use `RET' or `S-RET',</span>
<span class="linecomment">;;  there is Icicles user option</span>
<span class="linecomment">;;  `icicle-top-level-when-sole-completion-flag'.  If you set this to</span>
<span class="linecomment">;;  non-`nil', then, whenever your input matches only one candidate</span>
<span class="linecomment">;;  completion, that candidate is used immediately.  I do not</span>
<span class="linecomment">;;  recommend this practice generally, but some people might prefer</span>
<span class="linecomment">;;  it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Option `icicle-top-level-when-sole-completion-delay' is the number</span>
<span class="linecomment">;;  of seconds Icicles waits, before returning to top level with the</span>
<span class="linecomment">;;  sole completion.  It has no effect if</span>
<span class="linecomment">;;  `icicle-top-level-when-sole-completion-flag' is `nil'.  The delay</span>
<span class="linecomment">;;  gives you a chance to forestall acceptance of the sole completion:</span>
<span class="linecomment">;;  editing the completion (typing or deleting a character) before the</span>
<span class="linecomment">;;  delay expires prevents its automatic acceptance.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@* "Ido and IswitchB")</span>
 
<span class="linecomment">;;(@* "Ido and IswitchB")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Ido and IswitchB</span>
<span class="linecomment">;;  ----------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Libraries Ido and IswitchB are alternatives to Icicles that also</span>
<span class="linecomment">;;  enhance minibuffer completion in various ways.  Their UIs are</span>
<span class="linecomment">;;  similar to each other - Ido essentially extends IswitchB's</span>
<span class="linecomment">;;  buffer-name completion to file names as well.  Neither completes</span>
<span class="linecomment">;;  other kinds of candidates.  They work only for buffer names or</span>
<span class="linecomment">;;  file names, but you can advise the standard completion functions</span>
<span class="linecomment">;;  to get them to use Ido completion more generally.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The behavior of Ido and IswitchB is different from the default</span>
<span class="linecomment">;;  Icicles behavior.  If you prefer their behavior for buffers then</span>
<span class="linecomment">;;  you can just use IswitchB and Icicles together.  You cannot use</span>
<span class="linecomment">;;  Icicles and Ido together, however - they use the minibuffer in</span>
<span class="linecomment">;;  incompatible ways.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The default behavior of Icicles is different, but you can make</span>
<span class="linecomment">;;  Icicles behave more like Ido if you like.  It would be a mistake</span>
<span class="linecomment">;;  to look for a complete reproduction of the Ido behavior in</span>
<span class="linecomment">;;  Icicles, however.  If you want exactly the same behavior as Ido,</span>
<span class="linecomment">;;  then use Ido. ;-)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Icicles UI is different by design.  Some of this difference in</span>
<span class="linecomment">;;  approach has to do with the fact that Ido is specialized to</span>
<span class="linecomment">;;  buffer- and file-name completion.  The generality of Icicles makes</span>
<span class="linecomment">;;  a different approach appropriate.  Icicles has many additional</span>
<span class="linecomment">;;  features that are not available in other libraries, but its main</span>
<span class="linecomment">;;  advantage is its generality: you use the same user interface for</span>
<span class="linecomment">;;  input of any kind.  As you learn more about Icicles you may begin</span>
<span class="linecomment">;;  to appreciate its approach, even if you are a diehard Ido addict.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section summarizes some differences between Icicles and Ido</span>
<span class="linecomment">;;  and tells you how you can get more Ido-like behavior in Icicles if</span>
<span class="linecomment">;;  that's what you prefer.  It does not cover Icicles features that</span>
<span class="linecomment">;;  have no counterpart in Ido or features that they have in common</span>
<span class="linecomment">;;  (except to emphasize some differences).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you have the Ido habit but want to give Icicles a try, then</span>
<span class="linecomment">;;  this section is for you.  I recommend, however, that you give the</span>
<span class="linecomment">;;  default Icicles behavior a good try before convincing yourself</span>
<span class="linecomment">;;  that you still prefer a more Ido-like approach.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See also the references at the section end for other sections that</span>
<span class="linecomment">;;  go into more detail about some of the things mentioned here.</span>
<span class="linecomment">;;  </span>
<span class="linecomment">;;  1. Incremental completion.  By default, Icicles does not turn on</span>
<span class="linecomment">;;     incremental completion until you have hit `TAB' or `S-TAB' to</span>
<span class="linecomment">;;     display the matching candidates.  Ido turns it on immediately.</span>
<span class="linecomment">;;     You can get that behavior by setting option</span>
<span class="linecomment">;;     `icicle-show-Completions-initially-flag' to `t'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     You can get an intermediate behavior in this regard by instead</span>
<span class="linecomment">;;     setting option `icicle-incremental-completion-flag' to a value</span>
<span class="linecomment">;;     other than `nil' and `t'.  That makes Icicles show the matching</span>
<span class="linecomment">;;     candidates as soon as you start typing input.  See also option</span>
<span class="linecomment">;;     `icicle-incremental-completion-delay'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Matching.  By default, Ido uses substring matching for</span>
<span class="linecomment">;;     completion.  You can hit a key to switch to prefix matching,</span>
<span class="linecomment">;;     "flex" matching, or regexp matching.  Icicles gives you these</span>
<span class="linecomment">;;     same matching possibilities, and more.  (What Ido calls "flex"</span>
<span class="linecomment">;;     matching Icicles calls "scatter" matching.)  The main</span>
<span class="linecomment">;;     difference here is that Icicles regexp support is general and</span>
<span class="linecomment">;;     complete.  Regexp-matching in Ido does not work with Ido-style</span>
<span class="linecomment">;;     completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Current candidate, cycling, sorting.  Both Ido and Icicles have</span>
<span class="linecomment">;;     a notion of "current candidate".  In Ido, completion candidates</span>
<span class="linecomment">;;     are presented in a predefined sort order, most recently used</span>
<span class="linecomment">;;     first.  The current candidate is the first one.  You cycle</span>
<span class="linecomment">;;     candidates by moving the first to last or the last to first.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     In Icicles, you can switch among any number of sort orders at</span>
<span class="linecomment">;;     any time by hitting a key.  (And you can easily define your own</span>
<span class="linecomment">;;     sort orders.)  When you cycle candidates, the candidates stay</span>
<span class="linecomment">;;     in order.  If the candidates are displayed in `*Completions*'</span>
<span class="linecomment">;;     then the current one is highlighted there, in place.  The</span>
<span class="linecomment">;;     highlight moves, not the candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Input editing.  In Ido, cycling does not replace your input by</span>
<span class="linecomment">;;     the current candidate.  To edit the current candidate you hit a</span>
<span class="linecomment">;;     key to enter an edit mode (recursive minibuffer).  In Icicles,</span>
<span class="linecomment">;;     cycling replaces your input in the minibuffer by the current</span>
<span class="linecomment">;;     candidate, so you can just edit it there normally.  You can use</span>
<span class="linecomment">;;     `C-l' to retrieve your original input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Completions shown.  In Ido, a limited number of matching</span>
<span class="linecomment">;;     completion candidates are shown in the minibuffer.  You can hit</span>
<span class="linecomment">;;     a key to see all matches in a separate buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     In Icicles, completion candidates are always shown in buffer</span>
<span class="linecomment">;;     `*Completions*', not in the minibuffer.  You can limit the</span>
<span class="linecomment">;;     number of matches shown by customizing option</span>
<span class="linecomment">;;     `icicle-max-candidates'.  Only the first</span>
<span class="linecomment">;;     `icicle-max-candidates' (in the current sort order) are shown.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     You can also increment and decrement this truncation value on</span>
<span class="linecomment">;;     the fly during completion, by hitting `C-x #' and then using</span>
<span class="linecomment">;;     the vertical arrow keys or the mouse wheel.  (For that feature</span>
<span class="linecomment">;;     you also need library `doremi.el'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. Auto-choice of sole candidate.  In Ido, if there is only one</span>
<span class="linecomment">;;     match for your input then `TAB', which normally completes, also</span>
<span class="linecomment">;;     chooses that candidate - you do not need to hit `RET'.  By</span>
<span class="linecomment">;;     default, Icicles always requires you to explicitly choose with</span>
<span class="linecomment">;;     `RET' (or `C-RET').  If you set option</span>
<span class="linecomment">;;     `icicle-top-level-when-sole-completion-flag' to non-`nil', then</span>
<span class="linecomment">;;     Icicles provides similar behavior to Ido.  See also option</span>
<span class="linecomment">;;     `icicle-top-level-when-sole-completion-delay'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Ido-Like Behavior Everywhere: `icicle-ido-like-mode'")</span>
<span class="linecomment">;;  ** Ido-Like Behavior Everywhere: `icicle-ido-like-mode' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you want Icicles to be Ido-like in general, then turn on global</span>
<span class="linecomment">;;  minor mode `icicle-ido-like-mode' (not available in Emacs 20).</span>
<span class="linecomment">;;  Doing that sets options `icicle-show-Completions-initially-flag'</span>
<span class="linecomment">;;  and `icicle-top-level-when-sole-completion-flag' to `t'.  Turning</span>
<span class="linecomment">;;  the mode off sets them to `nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can simultaneously set option `icicle-max-candidates' when you</span>
<span class="linecomment">;;  turn on `icicle-ido-like-mode', by using a positive prefix</span>
<span class="linecomment">;;  argument.  If you want the option to keep that value when you turn</span>
<span class="linecomment">;;  the mode off, then use a zero or negative prefix argument.</span>
<span class="linecomment">;;  Otherwise, it is reset to `nil' (no limit on the number of</span>
<span class="linecomment">;;  candidates displayed).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use this mode, you might also want to use `nil' or `t' as</span>
<span class="linecomment">;;  the value of option `icicle-default-value', in order to not insert</span>
<span class="linecomment">;;  the default value in the minibuffer.  If you want to change that</span>
<span class="linecomment">;;  option dynamically for the mode, use `icicle-ido-like-mode-hook'.</span>
<span class="linecomment">;;  E.g.:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (add-hook 'icicle-ido-like-mode-hook</span>
<span class="linecomment">;;            (lambda () (setq icicle-default-value</span>
<span class="linecomment">;;                        (if icicle-ido-like-mode t 'insert-end))))</span>
<span class="linecomment">;;  </span>
<span class="linecomment">;;(@* "Ido-Like Behavior for Buffers and Files")</span>
<span class="linecomment">;;  ** Ido-Like Behavior for Buffers and Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you want Ido-like behavior in Icicles for buffers or files, but</span>
<span class="linecomment">;;  not in general, then customize either or both options</span>
<span class="linecomment">;;  `icicle-buffers-ido-like-flag' and `icicle-files-ido-like-flag' to</span>
<span class="linecomment">;;  non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Exiting the Minibuffer Without Confirmation")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Customization and General Tips"):</span>
<span class="linecomment">;;     `icicle-buffer-require-match-flag',</span>
<span class="linecomment">;;     `icicle-deletion-action-flag',</span>
<span class="linecomment">;;     `icicle-file-require-match-flag',</span>
<span class="linecomment">;;     `icicle-show-Completions-initially-flag',</span>
<span class="linecomment">;;     `icicle-incremental-completion-flag',</span>
<span class="linecomment">;;     `icicle-incremental-completion-delay',</span>
<span class="linecomment">;;     `icicle-max-candidates',</span>
<span class="linecomment">;;     `icicle-regexp-quote-flag',</span>
<span class="linecomment">;;     `icicle-top-level-when-sole-completion-flag',</span>
<span class="linecomment">;;     `icicle-top-level-when-sole-completion-delay',</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Fuzzy Completion")</span>
<span class="linecomment">;;  * (@&gt; "Special Characters in Input Patterns")</span>
<span class="linecomment">;;  * (@&gt; "Prefix Completion and Apropos Completion")</span>
<span class="linecomment">;;  * http://www.emacswiki.org/emacs/IciclesDiscussion#IdoAndIcicles</span>
<span class="linecomment">;;    (out-of-date discussion, but it might be helpful)</span>
 
<span class="linecomment">;;(@* "*Completions* Display")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  *Completions* Display</span>
<span class="linecomment">;;  ---------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances the `*Completions*' display in several ways.  The</span>
<span class="linecomment">;;  following features are available whenever buffer `*Completions*'</span>
<span class="linecomment">;;  is displayed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In buffer `*Completions*', you can use the arrow keys (`down',</span>
<span class="linecomment">;;    `up', `right', `left') to navigate among the candidate</span>
<span class="linecomment">;;    completions.  The current candidate (under the cursor) is</span>
<span class="linecomment">;;    highlighted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * When you cycle completions in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - The current candidate is highlighted in `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - Help on the current candidate (typically, the first line of a</span>
<span class="linecomment">;;      doc string) is displayed in the mode line, provided user</span>
<span class="linecomment">;;      option `icicle-help-in-mode-line-delay' is greater than zero.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The total number of completion candidates is displayed in the</span>
<span class="linecomment">;;    mode-line of buffer `*Completions*' - e.g. `567 candidates'.</span>
<span class="linecomment">;;    If the number of candidates is currently truncated (because of</span>
<span class="linecomment">;;    option `icicle-max-candidates' - see</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Customization and General Tips"),</span>
<span class="linecomment">;;    then the total number of candidates before truncation is also</span>
<span class="linecomment">;;    shown - e.g. `149 shown / 567'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `C-insert' to move back and forth between the</span>
<span class="linecomment">;;    minibuffer and `*Completions*'.  In each direction, the current</span>
<span class="linecomment">;;    candidate is tracked in the destination buffer.  For example, if</span>
<span class="linecomment">;;    the candidate in the minibuffer is `foobar', after you hit</span>
<span class="linecomment">;;    `C-insert' the cursor is on `foobar' in `*Completions*'.  In the</span>
<span class="linecomment">;;    other direction, if the cursor is on `foobar' in</span>
<span class="linecomment">;;    `*Completions*', after you hit `C-insert' the current input in</span>
<span class="linecomment">;;    the minibuffer is `foobar'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `*Completions*' can also serve as a new kind of icompletion help</span>
<span class="linecomment">;;    - see (@&gt; "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can choose multiple candidates during completion, by</span>
<span class="linecomment">;;    clicking them with `mouse-2' while holding the Control key</span>
<span class="linecomment">;;    pressed.  See (@&gt; "Multi-Commands").  You can choose a set of</span>
<span class="linecomment">;;    candidates in additional ways, and then act on all of them - see</span>
<span class="linecomment">;;    (@&gt; "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Icicles dynamically resizes the `*Completions*' window</span>
<span class="linecomment">;;    vertically, to fit the current set of completion candidates.</span>
<span class="linecomment">;;    The window is not resized, however, if buffer `*Completions*'</span>
<span class="linecomment">;;    appears in its own frame.  (It is also not resized in Emacs</span>
<span class="linecomment">;;    releases prior to 21.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You can control this automatic resizing generally or on a</span>
<span class="linecomment">;;    per-command basis:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     * User option `icicle-Completions-window-max-height' is the</span>
<span class="linecomment">;;       maximum number of lines to show in the `*Completions*'</span>
<span class="linecomment">;;       window.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     * You can override the behavior of option</span>
<span class="linecomment">;;       `icicle-Completions-window-max-height' for any given command,</span>
<span class="linecomment">;;       by setting property `icicle-Completions-window-max-height' on</span>
<span class="linecomment">;;       the command symbol to a different maximum window height</span>
<span class="linecomment">;;       value.  This property value is predefined for commands, such</span>
<span class="linecomment">;;       as `icicle-buffer' and `icicle-file', that do not involve the</span>
<span class="linecomment">;;       content of the current buffer during completion.  A large</span>
<span class="linecomment">;;       value is used for these commands, so that nearly all of the</span>
<span class="linecomment">;;       frame real estate is given to the `*Completions*' window.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For example, you can use the following code to set the maximum</span>
<span class="linecomment">;;    `*Completions*' height for command `foo' to 100 and turn off</span>
<span class="linecomment">;;    per-command control of the height for command `bar'.  If you use</span>
<span class="linecomment">;;    such code, evaluate it after you load Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       (put 'foo 'icicle-Completions-window-max-height 100)</span>
<span class="linecomment">;;       (put 'bar 'icicle-Completions-window-max-height nil)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Starting with Emacs 23, if you also use Do Re Mi library</span>
<span class="linecomment">;;    `doremi-frm.el', then you can use `C-x -' in the minibuffer to</span>
<span class="linecomment">;;    zoom the `*Completions*' buffer text, shrinking or enlarging it</span>
<span class="linecomment">;;    incrementally using `-' or `=', respectively (`=' is typically</span>
<span class="linecomment">;;    on the same keyboard key as `+', but it needs no Shift).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Also starting with Emacs 23 (whether or not you use</span>
<span class="linecomment">;;    `doremi-frm.el'), you can specify an initial text-scale amount</span>
<span class="linecomment">;;    for the `*Completions*' text, by customizing option</span>
<span class="linecomment">;;    `icicle-Completions-text-scale-decrease'.  This controls the</span>
<span class="linecomment">;;    default appearance.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You typically use these features to make the `*Completions*'</span>
<span class="linecomment">;;    text a bit smaller and thus save screen real estate - show more</span>
<span class="linecomment">;;    candidates in less space.  However, Emacs 23 text-scaling does</span>
<span class="linecomment">;;    not by itself let you recuperate the saved window space - it</span>
<span class="linecomment">;;    shrinks the text, but it does not shrink the window accordingly.</span>
<span class="linecomment">;;    For that, you also need library `face-remap+.el' and its option</span>
<span class="linecomment">;;    `text-scale-resize-window', which lets you resize the window or</span>
<span class="linecomment">;;    not, horizontally, vertically, or in both directions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (For example, you might set `split-width-threshold' to a small</span>
<span class="linecomment">;;    number, so `*Completions*' appears on the side rather than above</span>
<span class="linecomment">;;    or below other windows, and in that case you might want to</span>
<span class="linecomment">;;    resize it only horizontally.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If you use library `oneonone.el' with a standalone</span>
<span class="linecomment">;;    `*Completions*' frame, then see option</span>
<span class="linecomment">;;    `1on1-completions-frame-zoom-font-difference'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Icicles varies the number of columns used to display completion</span>
<span class="linecomment">;;    candidates, for a better fit.  You can tweak this with options</span>
<span class="linecomment">;;    `icicle-candidate-width-factor' and</span>
<span class="linecomment">;;    `icicle-inter-candidates-min-spaces'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If you use Do Re Mi (library `doremi.el'), then you can modify</span>
<span class="linecomment">;;    these options incrementally during completion, seeing the effect</span>
<span class="linecomment">;;    as they change.  Use `C-x w' or `C-x |' from the minibuffer,</span>
<span class="linecomment">;;    then use the arrow keys or the mouse wheel to increment and</span>
<span class="linecomment">;;    decrement the current value.  WYSIWYG.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Why is this important enough to merit changing it dynamically,</span>
<span class="linecomment">;;    instead of just customizing the options once and for all?</span>
<span class="linecomment">;;    Because different sets of candidates have different candidate</span>
<span class="linecomment">;;    lengths and distributions of those lengths.  Play with it a bit</span>
<span class="linecomment">;;    and you will see.  One size does not fit all in an ideal way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `C-x .' (`icicle-toggle-hiding-common-match') in the</span>
<span class="linecomment">;;    minibuffer at any time during completion to toggle hiding of the</span>
<span class="linecomment">;;    matched portions of the candidates in `*Completions*'.  This</span>
<span class="linecomment">;;    portion is replaced by ellipsis, `...'.  (In Emacs 20, it is</span>
<span class="linecomment">;;    replaced by nothing.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    This can be useful when you do not care about the text that</span>
<span class="linecomment">;;    matches or when that text is particularly long.  For example, if</span>
<span class="linecomment">;;    you use `icicle-find-file-absolute' (`C-u C-x C-f') and the</span>
<span class="linecomment">;;    completion candidates are absolute file names that share a</span>
<span class="linecomment">;;    common directory, it can be convenient to hide the directory</span>
<span class="linecomment">;;    portion that is common to all candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Starting with Emacs 22, thumbnail images are shown in</span>
<span class="linecomment">;;    `*Completions*' for candidates that are file names of image</span>
<span class="linecomment">;;    files, if option `icicle-image-files-in-Completions' is</span>
<span class="linecomment">;;    non-`nil' (it is `t' by default).  If the option value is</span>
<span class="linecomment">;;    `image-only', then only the thumbnail images are shown.  If it</span>
<span class="linecomment">;;    is otherwise non-`nil' then the file names are also shown.  You</span>
<span class="linecomment">;;    can cycle the option value using `C-x t' in the minibuffer at</span>
<span class="linecomment">;;    any time during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can scroll `*Completions*' down using `C-v', and up using</span>
<span class="linecomment">;;    `M-v'.  You can use `C-u' at any time to reverse the scroll</span>
<span class="linecomment">;;    directions.  In Emacs 22 or later, you can also use the mouse</span>
<span class="linecomment">;;    wheel to scroll `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can lay completion candidates out vertically, if you like,</span>
<span class="linecomment">;;    instead of horizontally (the default).  To do that, customize</span>
<span class="linecomment">;;    option `icicle-completions-format' to have the value `vertical'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Starting with Emacs 23.2, this is also possible in vanilla</span>
<span class="linecomment">;;    Emacs, and the vanilla option for this is `completions-format'.</span>
<span class="linecomment">;;    The default value of `icicle-completions-format' is the value of</span>
<span class="linecomment">;;    `completions-format', so if you prefer you can simply use the</span>
<span class="linecomment">;;    vanilla Emacs option.  Vertical layout works in Icicles for all</span>
<span class="linecomment">;;    Emacs versions, starting with Emacs 20.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Unlike the case for vanilla Emacs, in Icicles the arrow keys in</span>
<span class="linecomment">;;    buffer `*Completions*' correctly reflect the candidate order</span>
<span class="linecomment">;;    (e.g. as currently sorted).  This also means that candidate</span>
<span class="linecomment">;;    cycling acts properly for a vertical layout.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: For visual clarity, a `vertical' value is overridden</span>
<span class="linecomment">;;    (ignored) when multi-line multi-completions are used - the</span>
<span class="linecomment">;;    layout is horizontal.  See (@* "Customization and General Tips")</span>
<span class="linecomment">;;    for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In some cases, Icicles adds one or more additional, proxy</span>
<span class="linecomment">;;    completion candidates.  These are placeholders for real</span>
<span class="linecomment">;;    candidates.  If you choose a proxy candidate, then the real</span>
<span class="linecomment">;;    candidate that is referred to is used.  Typical proxy candidates</span>
<span class="linecomment">;;    include a reference to a name under the cursor, a reference to</span>
<span class="linecomment">;;    whatever you then click `mouse-2' on, and a reference to a name</span>
<span class="linecomment">;;    that is the value of a variable.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The inclusion of proxy candidates is controlled by user option</span>
<span class="linecomment">;;    `icicle-add-proxy-candidates-flag'.  You can toggle this</span>
<span class="linecomment">;;    inclusion at any time during completion, using `C-M-_'.  For</span>
<span class="linecomment">;;    performance reasons, you must re-invoke some commands after</span>
<span class="linecomment">;;    toggling the flag on, to make the proxy candidates available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Examples:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . When you read a file name with completion, the proxy</span>
<span class="linecomment">;;       candidates include the following (reading a face name is</span>
<span class="linecomment">;;       similar):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*mouse-2 file name*' - proxy for a file name that you</span>
<span class="linecomment">;;         click with `mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*point file name*' - proxy for the file name at point (if</span>
<span class="linecomment">;;         available).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - Single-quoted names of file-name variables - proxy for the</span>
<span class="linecomment">;;         variable value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . When a command reads input using `icicle-read-number' or</span>
<span class="linecomment">;;       `icicle-read-string-completing', the proxy candidates are all</span>
<span class="linecomment">;;       variables whose values are numbers or strings, respectively.</span>
<span class="linecomment">;;       You can choose such a proxy candidate to use its value.  (All</span>
<span class="linecomment">;;       candidates are proxy candidates for these functions.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . When you use command `icicle-read-color', the proxy</span>
<span class="linecomment">;;       candidates include the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*point foreground*' - proxy for the foreground color at</span>
<span class="linecomment">;;         the cursor position (point).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*mouse-2 foreground*' - proxy for the foreground color</span>
<span class="linecomment">;;         where you then click `mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - `*copied foreground*' - proxy for a previously copied</span>
<span class="linecomment">;;         foreground color, the value of variable</span>
<span class="linecomment">;;         `eyedrop-picked-foreground'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - Background versions of the first three: `*copied</span>
<span class="linecomment">;;         background*' etc.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;       - Single-quoted names of color-valued variables - proxy for</span>
<span class="linecomment">;;         the variable value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    See Also:</span>
<span class="linecomment">;;    (@&gt; "Different Places for Saving and Retrieving Candidates")</span>
<span class="linecomment">;;    for information about using `C-M-{' in the minibuffer to</span>
<span class="linecomment">;;    retrieve the value of any variable as minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Gotcha: Your minibuffer input is matched against proxy</span>
<span class="linecomment">;;    candidates, as usual.  If `insert-default-directory' is</span>
<span class="linecomment">;;    non-`nil' when you use `C-x d' (`icicle-dired') then the default</span>
<span class="linecomment">;;    directory is inserted as part of your input.  If you use `TAB'</span>
<span class="linecomment">;;    for completion then you will first need to use `M-k' to remove</span>
<span class="linecomment">;;    the directory, as it will not match any of the proxy candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Clicking `C-mouse-3' on a candidate in `*Completions*' pops up a</span>
<span class="linecomment">;;    contextual menu for acting on completion candidates.  You can</span>
<span class="linecomment">;;    customize the menu using option</span>
<span class="linecomment">;;    `icicle-Completions-mouse-3-menu-entries'.  By default, the menu</span>
<span class="linecomment">;;    has the following submenus:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . `This Candidate' - Act on the candidate that you clicked to</span>
<span class="linecomment">;;       pop up the menu.  Or act on all current candidates,</span>
<span class="linecomment">;;       individually or collectively.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . `Sorting' - Change the current candidate sort order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . `Save/Retrieve' - Save (mark) candidates or retrieve them,</span>
<span class="linecomment">;;       including to/from a variable or a cache file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . `Sets' - Perform operations on sets of candidates, in</span>
<span class="linecomment">;;       particular, the set of current candidates and the set of</span>
<span class="linecomment">;;       saved candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . `Toggle/Cycle/Change' - Toggle, cycle, or otherwise change an</span>
<span class="linecomment">;;       Icicles setting, altering the behavior on the fly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     . `Miscellaneous' - Other candidate operations and general</span>
<span class="linecomment">;;       help.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The popup menu is contextual.  In particular, the available</span>
<span class="linecomment">;;    items can change depending on whether you use a prefix argument</span>
<span class="linecomment">;;    (`C-u C-mouse-3') and whether you have selected candidates using</span>
<span class="linecomment">;;    the region (e.g. mouse drag).  The menu also provides a good</span>
<span class="linecomment">;;    reminder of key bindings available during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are lots more Icicles features that enhance the display and</span>
<span class="linecomment">;;  behavior of `*Completions*' in some way.  Read on...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: </span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Moving Between the Minibuffer and Other Buffers"), for</span>
<span class="linecomment">;;    information on the `pause' key, which is somewhat related to</span>
<span class="linecomment">;;    using `C-insert'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Candidates with Text Properties")</span>
<span class="linecomment">;;    and (@file :file-name "icicles-doc2.el" :to "Programming Multi-Completions")</span>
<span class="linecomment">;;    for information about using text properties in `*Completions*'.</span>
<span class="linecomment">;;    These sections are for Emacs-Lisp programmers.</span>
 
<span class="linecomment">;;(@* "Icompletion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icompletion</span>
<span class="linecomment">;;  -----------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs incremental completion, or icompletion, provided by standard</span>
<span class="linecomment">;;  library `icomplete.el', displays matching prefix completions in</span>
<span class="linecomment">;;  the minibuffer.  This display is updated incrementally as you type</span>
<span class="linecomment">;;  characters.  In spite of the name, icompletion does not, in fact,</span>
<span class="linecomment">;;  provide any completion; it provides completion help, letting you</span>
<span class="linecomment">;;  know which (prefix) completions are available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances Emacs icompletion in three ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. It works with my library `icomplete+.el' to provide minibuffer</span>
<span class="linecomment">;;     feedback on the number of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. It highlights the part of your input that does not match any</span>
<span class="linecomment">;;     completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. It provides a new kind of icompletion, using buffer</span>
<span class="linecomment">;;     `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "icomplete+.el Displays the Number of Other Prefix Candidates")</span>
<span class="linecomment">;;  ** icomplete+.el Displays the Number of Other Prefix Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `icomplete+.el' enhances `icomplete.el' in various ways.</span>
<span class="linecomment">;;  One of these ways is to complement Icicles by displaying the</span>
<span class="linecomment">;;  number of other prefix-completion candidates when cycling.  This</span>
<span class="linecomment">;;  number is displayed whenever you change direction when cycling.</span>
<span class="linecomment">;;  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      M-x forward-line   [Matched]  (13 more)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like `icomplete.el', `icomplete+.el' provides help for only prefix</span>
<span class="linecomment">;;  completions, not apropos completions.  (Reminder: There is no</span>
<span class="linecomment">;;  icompletion for file-name completion - see standard library</span>
<span class="linecomment">;;  `icomplete.el'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icompletion in *Completions*: Apropos and Prefix Completion")</span>
<span class="linecomment">;;  ** Icompletion in *Completions*: Apropos and Prefix Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Buffer `*Completions*' shows you the current set of candidates for</span>
<span class="linecomment">;;  either prefix or apropos completion.  Together, user options</span>
<span class="linecomment">;;  `icicle-incremental-completion-flag',</span>
<span class="linecomment">;;  `icicle-incremental-completion-delay', and</span>
<span class="linecomment">;;  `icicle-incremental-completion-threshold' control incremental</span>
<span class="linecomment">;;  updating of `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If `icicle-incremental-completion-flag' is non-`nil', then</span>
<span class="linecomment">;;  `*Completions*' is automatically updated when you change your</span>
<span class="linecomment">;;  input in the minibuffer - that is, with each character that you</span>
<span class="linecomment">;;  type or delete.  This is another form of icompletion, unique to</span>
<span class="linecomment">;;  Icicles.  It uses buffer `*Completions*', instead of the</span>
<span class="linecomment">;;  minibuffer, to show the completion help.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The particular non-`nil' value of</span>
<span class="linecomment">;;  `icicle-incremental-completion-flag' determines when</span>
<span class="linecomment">;;  `*Completions*' is displayed and updated.  The default value, `t',</span>
<span class="linecomment">;;  means that `*Completions*' is updated only if it is already</span>
<span class="linecomment">;;  displayed.  Use `t' if you do not want `*Completions*' to be too</span>
<span class="linecomment">;;  intrusive but you want it to provide the most help when you ask</span>
<span class="linecomment">;;  for help (via `TAB' or `S-TAB').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Any other non-`nil' value displays and updates `*Completions*'</span>
<span class="linecomment">;;  whenever there is more than one completion candidate.  That can be</span>
<span class="linecomment">;;  more helpful, but it can also be more distracting.  A value of</span>
<span class="linecomment">;;  `nil' turns off automatic updating altogether - `*Completions*' is</span>
<span class="linecomment">;;  then displayed only upon demand.  I find that `t' represents a</span>
<span class="linecomment">;;  good compromise, providing help when I ask for it, and then</span>
<span class="linecomment">;;  continuing to help until I've finished choosing a candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Option `icicle-incremental-completion-delay' is the number of</span>
<span class="linecomment">;;  seconds to wait before updating `*Completions*' incrementally.  It</span>
<span class="linecomment">;;  has an effect only when the number of completion candidates is</span>
<span class="linecomment">;;  greater than `icicle-incremental-completion-threshold'.  This</span>
<span class="linecomment">;;  delay can improve performance when there are many candidates.  It</span>
<span class="linecomment">;;  lets you type ahead before any redisplay occurs; otherwise,</span>
<span class="linecomment">;;  redisplay occurs for each character you type or delete.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can toggle incremental completion at any time (changing</span>
<span class="linecomment">;;  `icicle-incremental-completion-flag' between `nil' and `t') using</span>
<span class="linecomment">;;  command `icicle-toggle-incremental-completion', which is bound to</span>
<span class="linecomment">;;  `C-#' in the minibuffer.  If the number of completion candidates</span>
<span class="linecomment">;;  is very large, then use `C-#' to toggle incremental completion off</span>
<span class="linecomment">;;  - that will save time by not updating `*Completions*'.  See also</span>
<span class="linecomment">;;  (@&gt; "Dealing With Large Candidate Sets") for other ways to deal</span>
<span class="linecomment">;;  with a large number of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Incremental completion is effectively turned off when a</span>
<span class="linecomment">;;  remote file name is read, that is, whenever your file-name input</span>
<span class="linecomment">;;  matches a remote-file syntax.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are several advantages of using `*Completions*' for</span>
<span class="linecomment">;;  icompletion, as opposed to the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Many more candidates can be displayed in `*Completions*' than</span>
<span class="linecomment">;;     can be displayed by standard icompletion, which uses the</span>
<span class="linecomment">;;     minibuffer for feedback.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Standard (minibuffer) icompletion provides feedback only on</span>
<span class="linecomment">;;     matches for prefix completion.  If you use both standard</span>
<span class="linecomment">;;     icompletion and Icicles icompletion, you can have incremental</span>
<span class="linecomment">;;     help for both prefix completion and apropos completion at the</span>
<span class="linecomment">;;     same time, one in the minibuffer and the other in</span>
<span class="linecomment">;;     `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. The other Icicles `*Completions*' features are available for</span>
<span class="linecomment">;;     the current set of matching candidates: cycling, highlighting</span>
<span class="linecomment">;;     of match root, highlighting of previously used candidates, and</span>
<span class="linecomment">;;     so on.  See (@&gt; "*Completions* Display").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Highlights the Input that Won't Complete")</span>
<span class="linecomment">;;  ** Icicles Highlights the Input that Won't Complete **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you are typing or correcting your input during completion,</span>
<span class="linecomment">;;  Icicles highlights the part of your minibuffer input that prevents</span>
<span class="linecomment">;;  it from matching any completion candidates, by default.  This</span>
<span class="linecomment">;;  works for both prefix completion and apropos completion.  For</span>
<span class="linecomment">;;  both, it highlights your input from the leftmost mismatch through</span>
<span class="linecomment">;;  the input end.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-M-l' to move the cursor to the start of the</span>
<span class="linecomment">;;  highlighted, mismatched part of your input.  Repeat `C-M-l' to</span>
<span class="linecomment">;;  kill the highlighted portion.  (Because it is killed, `C-y' yanks</span>
<span class="linecomment">;;  it back.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  User options `icicle-incremental-completion-flag',</span>
<span class="linecomment">;;  `icicle-test-for-remote-files-flag',</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure',</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure-delay', and</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure-threshold' control this</span>
<span class="linecomment">;;  highlighting, which is done using face</span>
<span class="linecomment">;;  `icicle-input-completion-fail' (for strict completion) or</span>
<span class="linecomment">;;  `icicle-input-completion-fail-lax' (for lax completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If either `icicle-incremental-completion-flag' or</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure' is `nil', then no such</span>
<span class="linecomment">;;  highlighting is done.  Remember that you can toggle incremental</span>
<span class="linecomment">;;  completion using `C-#' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because this highlighting can have a negative impact on</span>
<span class="linecomment">;;  performance, you can fine-tune when you want it to occur.  The</span>
<span class="linecomment">;;  value of `icicle-highlight-input-completion-failure' determines</span>
<span class="linecomment">;;  when this highlighting can take place.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In particular, highlighting the non-matching part of remote file</span>
<span class="linecomment">;;  names can be slow.  Two values of the option allow remote file</span>
<span class="linecomment">;;  name highlighting: `always' and `explicit-remote'.  The other</span>
<span class="linecomment">;;  values do not highlight remote file names.  You probably do not</span>
<span class="linecomment">;;  want to use a value of `always'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the value is `nil', then highlighting never occurs.  If the</span>
<span class="linecomment">;;  value is `explicit-strict', `explicit', or `explicit-remote', then</span>
<span class="linecomment">;;  highlighting occurs only upon demand: when you hit `TAB' or</span>
<span class="linecomment">;;  `S-TAB' to request completion.  If the value is `implicit-strict',</span>
<span class="linecomment">;;  `implicit', or `always', then highlighting occurs also when you</span>
<span class="linecomment">;;  update input during incremental completion (if incremental</span>
<span class="linecomment">;;  completion is turned on).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I use a value of `implicit' myself, but the default value is</span>
<span class="linecomment">;;  `implicit-strict' because, depending on your setup and use cases,</span>
<span class="linecomment">;;  `implicit' can impact performance for file-name completion (which</span>
<span class="linecomment">;;  is lax, not strict).  I suggest you try `implicit' to see - this</span>
<span class="linecomment">;;  feature is especially useful for file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    TIP: An alternative way to be informed about a file name</span>
<span class="linecomment">;;         mismatch (when you use `TAB' or `S-TAB') is to use</span>
<span class="linecomment">;;         `icicle-no-match-hook' to signal you using a visual or</span>
<span class="linecomment">;;         audible cue.  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;         (add-hook 'icicle-no-match-hook</span>
<span class="linecomment">;;                   (lambda ()</span>
<span class="linecomment">;;                     (when (icicle-file-name-input-p) (ding))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Summary of `icicle-highlight-input-completion-failure' choices:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `nil'             Never</span>
<span class="linecomment">;;  `explicit-strict' Only on demand and only during strict completion</span>
<span class="linecomment">;;  `explicit'        Only on demand (lax and strict completion)</span>
<span class="linecomment">;;  `explicit-remote' Only on demand, even for remote file names</span>
<span class="linecomment">;;  `implicit-strict' Incremental or explicit completion - strict only</span>
<span class="linecomment">;;  `implicit'        Incremental/explicit, lax/strict completion</span>
<span class="linecomment">;;  `always'          Always (including for remote file names)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These values are listed here in terms of increasing</span>
<span class="linecomment">;;  permissiveness, which also can mean increasing performance impact.</span>
<span class="linecomment">;;  That is, a value of `implicit' is more likely to affect</span>
<span class="linecomment">;;  performance than a value of `explicit'.  The greatest performance</span>
<span class="linecomment">;;  hit comes from file-name matching, in particular if remote files</span>
<span class="linecomment">;;  are involved.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you know that you will not be using remote file names for a</span>
<span class="linecomment">;;  while, you can let Icicles and Tramp know this by using the toggle</span>
<span class="linecomment">;;  `C-^' in the minibuffer to turn off option</span>
<span class="linecomment">;;  `icicle-test-for-remote-files-flag'.  When this is off, you cannot</span>
<span class="linecomment">;;  use remote files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Turning off `icicle-test-for-remote-files-flag' using `C-^' turns</span>
<span class="linecomment">;;  off Tramp's remote file-name completion and remote file handling.</span>
<span class="linecomment">;;  If you turn off the option using `C-^', then turn it back on using</span>
<span class="linecomment">;;  `C-^' also (instead of just setting the option to non-`nil'), in</span>
<span class="linecomment">;;  order to re-enable Tramp's file-name handling and completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Turning off `icicle-test-for-remote-files-flag' can slightly speed</span>
<span class="linecomment">;;  up file-name completion for local files, by avoiding any check for</span>
<span class="linecomment">;;  remote file names.  If you seldom use remote files, then you might</span>
<span class="linecomment">;;  want to customize `icicle-test-for-remote-files-flag' to `nil' and</span>
<span class="linecomment">;;  use `C-^' to toggle it back on whenever you do use remote files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A `nil' value of `icicle-test-for-remote-files-flag' also</span>
<span class="linecomment">;;  overrides the `icicle-highlight-input-completion-failure' values</span>
<span class="linecomment">;;  `implicit-strict', and `explicit-strict' for file-name completion,</span>
<span class="linecomment">;;  treating them the same as `implicit'.  It is assumed that you use</span>
<span class="linecomment">;;  those values only to avoid the cost of remote file-name matching.</span>
 
<span class="linecomment">;;(@* "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sorting Candidates and Removing Duplicates</span>
<span class="linecomment">;;  ------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, completion candidates are usually presented in buffer</span>
<span class="linecomment">;;  `*Completions*' in alphabetic order.  But some commands use</span>
<span class="linecomment">;;  different sort orders by default.  Whatever sort order is used for</span>
<span class="linecomment">;;  `*Completions*' is also the order of cycling among candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Also, duplicate candidates are typically removed as completion</span>
<span class="linecomment">;;  choices, by default.  But for some commands duplicates are</span>
<span class="linecomment">;;  appropriate, so they are not removed.  For example, command</span>
<span class="linecomment">;;  `icicle-search' (`C-c `') uses completion to navigate among search</span>
<span class="linecomment">;;  hits.  Duplicate search hits are retained.  Although some</span>
<span class="linecomment">;;  search-hit candidates might have the same text, they are located</span>
<span class="linecomment">;;  at different buffer positions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can interactively control the order of candidates and whether</span>
<span class="linecomment">;;  duplicates are removed.  Use `C-,' during completion to choose a</span>
<span class="linecomment">;;  different sort order or to turn off sorting altogether (one of the</span>
<span class="linecomment">;;  available sort orders is in fact called "turned OFF").  Use `C-$'</span>
<span class="linecomment">;;  to toggle the removal of duplicate candidates.  A few commands,</span>
<span class="linecomment">;;  for which sorting is inappropriate, prevent you from sorting.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The available sort orders for `C-,' are those defined by user</span>
<span class="linecomment">;;  option `icicle-sort-orders-alist' - see</span>
<span class="linecomment">;;  (@&gt; "Defining New Sort Orders"), below.  However, some commands</span>
<span class="linecomment">;;  adjust this list of possibilities by adding command-relevant sort</span>
<span class="linecomment">;;  orders or removing some that might be inappropriate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The sort order generally remains as you last set it, for</span>
<span class="linecomment">;;  subsequent commands.  However, if the last order you set is</span>
<span class="linecomment">;;  inappropriate for the current command then sorting is turned off.</span>
<span class="linecomment">;;  You can then use `C-,' to choose a sort order appropriate for the</span>
<span class="linecomment">;;  current command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Changing the Sort Order")</span>
<span class="linecomment">;;  ** Changing the Sort Order **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are a couple of ways to use `C-,' (bound to command</span>
<span class="linecomment">;;  `icicle-change-sort-order').  Its behavior depends on the value of</span>
<span class="linecomment">;;  user option `icicle-change-sort-order-completion-flag', which is</span>
<span class="linecomment">;;  `nil' by default.  This value means to simply cycle to the next</span>
<span class="linecomment">;;  sort order each time you hit `C-,'.  A non-`nil' value means to</span>
<span class="linecomment">;;  use completion to choose another sort order.  If you have many</span>
<span class="linecomment">;;  available sort orders, then you might prefer a non-`nil' value.</span>
<span class="linecomment">;;  In any case, you can also change this behavior on the fly: using</span>
<span class="linecomment">;;  plain `C-u' (no number) with `C-,' reverses the meaning of</span>
<span class="linecomment">;;  `icicle-change-sort-order-completion-flag' for `C-,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, a numeric prefix argument, such as `C-9', means to simply</span>
<span class="linecomment">;;  reverse the direction of the current sort order; it invokes</span>
<span class="linecomment">;;  command `icicle-reverse-sort-order'.  For example, if candidates</span>
<span class="linecomment">;;  are sorted alphabetically from A to Z, then `C-9 C-,' flips the</span>
<span class="linecomment">;;  sort order, so that from then on sorting is from Z to A.  If</span>
<span class="linecomment">;;  buffer names are sorted from small to large buffer size, then `C-9</span>
<span class="linecomment">;;  C-,' sorts large buffers first.  This works for all sort orders.</span>
<span class="linecomment">;;  The new sort order is echoed, so you can use this twice to just</span>
<span class="linecomment">;;  remind yourself of the current sort order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to the current sort order, which is defined by the</span>
<span class="linecomment">;;  value of user option `icicle-sort-comparer', an alternative sort</span>
<span class="linecomment">;;  order is available at all times.  It is the value of option</span>
<span class="linecomment">;;  `icicle-alternative-sort-comparer'.  By default, this sorts</span>
<span class="linecomment">;;  candidates into two alphabetical groups: those previously used as</span>
<span class="linecomment">;;  accepted input, followed by those not yet used.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as you can choose a different current sort order using `C-,',</span>
<span class="linecomment">;;  so you can choose a different alternative sort order using `M-,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  How do you actually use the alternative sort order?  Use `C-M-,'</span>
<span class="linecomment">;;  (command `icicle-toggle-alternative-sorting') to swap the</span>
<span class="linecomment">;;  alternative sort for the current sort.  This is the quickest way</span>
<span class="linecomment">;;  to flip between two sort orders.  If, for example, you set your</span>
<span class="linecomment">;;  alternative sort order to "turned OFF", then this is a quick way</span>
<span class="linecomment">;;  to toggle sorting on and off.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first time during a session that you use a command that</span>
<span class="linecomment">;;  completes a buffer name or a file name, sorting changes to (that</span>
<span class="linecomment">;;  is, `icicle-sort-comparer' is set to) whatever is specified by</span>
<span class="linecomment">;;  user option `icicle-buffer-sort' or `icicle-file-sort',</span>
<span class="linecomment">;;  respectively, provided the option is non-`nil'.  This gives you a</span>
<span class="linecomment">;;  way to privilege a particular sorting method for each of these</span>
<span class="linecomment">;;  kinds of completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Defining New Sort Orders")</span>
<span class="linecomment">;;  ** Defining New Sort Orders **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `C-,' or `M-,', the sort orders that you can choose</span>
<span class="linecomment">;;  from are those in user option `icicle-sort-orders-alist'.  You can</span>
<span class="linecomment">;;  customize this option to add or remove available sort orders.  A</span>
<span class="linecomment">;;  better way to define a new sort order is to use macro</span>
<span class="linecomment">;;  `icicle-define-sort-command' in your Emacs init file (~/.emacs).</span>
<span class="linecomment">;;  This defines a new Icicles command, named `icicle-sort-ORDER',</span>
<span class="linecomment">;;  where `ORDER' is the name of the new sort order.  The definition</span>
<span class="linecomment">;;  of the "alphabetical" sort order provides an example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (icicle-define-sort-command "alphabetical"</span>
<span class="linecomment">;;                                icicle-case-string-less-p</span>
<span class="linecomment">;;      "Sort completion candidates alphabetically.")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first argument, "alphabetical", is a string naming the new</span>
<span class="linecomment">;;  sort order.  When you change to this sort order, a message says</span>
<span class="linecomment">;;  "Sorting is now alphabetical".  Whatever sort-order name you</span>
<span class="linecomment">;;  provide is used in the message.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second argument is the actual function used for sorting.  It</span>
<span class="linecomment">;;  can be any function, including a lambda expression.  The function</span>
<span class="linecomment">;;  takes two string arguments and returns non-`nil' if and only if</span>
<span class="linecomment">;;  the first string sorts before (is "less than") the second.  In</span>
<span class="linecomment">;;  this case, function `icicle-case-string-less-p' is used, which</span>
<span class="linecomment">;;  compares its two arguments alphabetically (lexicographically).</span>
<span class="linecomment">;;  The third argument is the doc string for the new sorting command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The result of this definition is:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. The creation of command `icicle-sort-alphabetical'.</span>
<span class="linecomment">;;  2. The addition of an entry for the new sort order in option</span>
<span class="linecomment">;;     `icicle-sort-orders-alist'.  The entry associates sort order</span>
<span class="linecomment">;;     "alphabetical" with comparison function</span>
<span class="linecomment">;;     `icicle-case-string-less-p'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can invoke the new sorting command any time using `M-x', but</span>
<span class="linecomment">;;  you can also change to the new sort order using `C-,' (or `M-,')</span>
<span class="linecomment">;;  during minibuffer completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Different Sorts for Different Sorts of Uses")</span>
<span class="linecomment">;;  ** Different Sorts for Different Sorts of Uses **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many different uses of completion in Emacs, and this</span>
<span class="linecomment">;;  means that sorting candidates needs to be flexible - there cannot</span>
<span class="linecomment">;;  be a single sort order, or even a single set of sort orders, that</span>
<span class="linecomment">;;  is useful for all purposes.  Completion, and therefore also</span>
<span class="linecomment">;;  sorting of completion candidates, needs to deal with different</span>
<span class="linecomment">;;  types of candidates and different numbers of them, in different</span>
<span class="linecomment">;;  contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles predefines many sort functions, and you can easily define</span>
<span class="linecomment">;;  more of your own.  You can choose a different sort at any time, as</span>
<span class="linecomment">;;  mentioned above.  A good sort order can be a big help, depending</span>
<span class="linecomment">;;  on the context.  However, sorting is not free, and it can be</span>
<span class="linecomment">;;  helpful to think for a moment about some of the consequences of</span>
<span class="linecomment">;;  sorting, in terms of performance.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What does a sort function do?  It determines which of two strings</span>
<span class="linecomment">;;  should come first, that is, which is "less than" the other.</span>
<span class="linecomment">;;  During sorting, pairs of candidates are compared using the sort</span>
<span class="linecomment">;;  function.  And each time you change your input by typing or</span>
<span class="linecomment">;;  deleting a character, the new set of matching candidates is sorted</span>
<span class="linecomment">;;  (if `icicle-incremental-completion-flag' is non-`nil').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The number of candidates to be sorted depends on the kind of</span>
<span class="linecomment">;;  completion and how you use Icicles.  Some Icicles users like to</span>
<span class="linecomment">;;  use cycling more and completion less, which means sorting more</span>
<span class="linecomment">;;  candidates.  Other users favor using completion to narrow down the</span>
<span class="linecomment">;;  number of matches (which I recommend).  Some commands typically</span>
<span class="linecomment">;;  have few possible completion candidates; others have many.</span>
<span class="linecomment">;;  Buffer-name completion, for example, typically involves relatively</span>
<span class="linecomment">;;  few candidates, whereas file-name completion typically involves</span>
<span class="linecomment">;;  many.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If there are many candidates matching your input, then many</span>
<span class="linecomment">;;  comparisons will be made each time the candidate set is sorted.</span>
<span class="linecomment">;;  This means that if your sort function is complex, response can be</span>
<span class="linecomment">;;  slow.  A complex sort function might be OK for sorting a small or</span>
<span class="linecomment">;;  medium set of candidates, but it might not be appropriate for</span>
<span class="linecomment">;;  sorting a very large set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Only you, as a user, can control which sort makes the best sense</span>
<span class="linecomment">;;  for you in any given situation.  If you are likely to have</span>
<span class="linecomment">;;  zillions of candidates in some context, then you probably will</span>
<span class="linecomment">;;  want to change to a sort that computes quickly.  You can, of</span>
<span class="linecomment">;;  course, even choose not to sort at all, but simple sort</span>
<span class="linecomment">;;  comparisons do not noticeably impact performance, even for a very</span>
<span class="linecomment">;;  large number of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles could offer a threshold option similar to</span>
<span class="linecomment">;;  `icicle-incremental-completion-threshold' (or it could reuse that</span>
<span class="linecomment">;;  option), and not bother to sort if the number of candidates passed</span>
<span class="linecomment">;;  the threshold, but there can be many sort orders of differing</span>
<span class="linecomment">;;  complexity, so a set of thresholds would really be needed, perhaps</span>
<span class="linecomment">;;  one per sort order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Rather than having you try to manage such complexity ahead of time</span>
<span class="linecomment">;;  using options, it's better to just let you manage it at completion</span>
<span class="linecomment">;;  time: Choose the sort order with knowledge of the possible</span>
<span class="linecomment">;;  candidate set.  For example, if the set of candidates to sort will</span>
<span class="linecomment">;;  include every file on your file system, then you probably will</span>
<span class="linecomment">;;  want to use a simple sort.  On the other hand, there are</span>
<span class="linecomment">;;  situations where you might nevertheless prefer to wait a few</span>
<span class="linecomment">;;  seconds, in order to perform a complex sort that is of particular</span>
<span class="linecomment">;;  use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In sum, Icicles keeps it simple, and leaves it up to you to choose</span>
<span class="linecomment">;;  the appropriate sort order for any given context.  This design</span>
<span class="linecomment">;;  choice is one reason why Icicles makes it easy to choose a sort</span>
<span class="linecomment">;;  even while you are completing input - each act of completion is</span>
<span class="linecomment">;;  different.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It can help you choose, however, to know which of the predefined</span>
<span class="linecomment">;;  Icicles sort orders are more complex, and therefore tend to be</span>
<span class="linecomment">;;  slower.  Here they are:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Sort Order                      Sort Function Used</span>
<span class="linecomment">;;    ----------                      ------------------</span>
<span class="linecomment">;;    by previous use alphabetically  `icicle-historical-alphabetic-p'</span>
<span class="linecomment">;;    by last use                     `icicle-most-recent-first-p'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The reason these sorts are slower is that they check the current</span>
<span class="linecomment">;;  minibuffer history, to see whether, and where, each candidate is</span>
<span class="linecomment">;;  located in the history list.  If you, like I, have very long</span>
<span class="linecomment">;;  history lists, then this can take a while.  I use histories of</span>
<span class="linecomment">;;  virtually unlimited length - I let library `savehist-20+.el' save</span>
<span class="linecomment">;;  all of my histories from one Emacs session to the next.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some of the Icicles sort orders that exist by default:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - alphabetical - see</span>
<span class="linecomment">;;      (@&gt; "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;    - case-insensitive - (@&gt; "Completion Status Indicators")</span>
<span class="linecomment">;;    - by last use as input</span>
<span class="linecomment">;;    - by previous use alphabetically - see</span>
<span class="linecomment">;;      (@&gt; "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;      by color name (colors) - see</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Candidates with Text Properties")</span>
<span class="linecomment">;;      by hue (colors)</span>
<span class="linecomment">;;      by purity/saturation (colors)</span>
<span class="linecomment">;;      by brightness/value/luminance (colors)</span>
<span class="linecomment">;;      by all HSV components, in order (colors)</span>
<span class="linecomment">;;      by HSV distance from a base color (colors)</span>
<span class="linecomment">;;      by amount of red (colors)</span>
<span class="linecomment">;;      by amount of green (colors)</span>
<span class="linecomment">;;      by amount of blue (colors)</span>
<span class="linecomment">;;      by all RGB components, in order (colors)</span>
<span class="linecomment">;;      by RGB distance from a base color (colors)</span>
<span class="linecomment">;;   22 by key name, prefix keys first (keys)- see (@&gt; "Completing Prefix Keys")</span>
<span class="linecomment">;;   22 by key name, local bindings first (keys)- see</span>
<span class="linecomment">;;      (@&gt; "Local Bindings Are Highlighted")</span>
<span class="linecomment">;;   22 by command name (commands)</span>
<span class="linecomment">;;    - by abbrev frequency (commands) - see</span>
<span class="linecomment">;;      (@&gt; "Multi `M-x' Turns Every Command into a Multi-Command")</span>
<span class="linecomment">;;      by buffer size (buffer names)</span>
<span class="linecomment">;;      *...* buffers last (buffer names)</span>
<span class="linecomment">;;      by major mode name (buffer names)</span>
<span class="linecomment">;;   22 by mode-line mode name (buffer names)</span>
<span class="linecomment">;;      by file/process name (buffer names)</span>
<span class="linecomment">;;    - by last file modification time (file names) - see</span>
<span class="linecomment">;;      (@&gt; "Icicles Commands that Read File Names")</span>
<span class="linecomment">;;    - by file type (extension) (file names)</span>
<span class="linecomment">;;    - by directories first or last (file names)</span>
<span class="linecomment">;;    - in book order (Info) - see</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Icicles Completion for Info")</span>
<span class="linecomment">;;    - special candidates first - see</span>
<span class="linecomment">;;      (@&gt; "Local Bindings Are Highlighted"),</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Candidates with Text Properties"),</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;    - proxy candidates first - see (&gt; "*Completions* Display")</span>
<span class="linecomment">;;    - extra candidates first - see</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Global Filters")</span>
<span class="linecomment">;;    - by second multi-completion part (multi-completions) - see</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc2.el" :to "Sorting Candidates by Their Second Part")</span>
<span class="linecomment">;;    - turned OFF  (does not sort at all)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As you can see, some are appropriate for color-name completion,</span>
<span class="linecomment">;;  some for buffer-name completion, and some for file-name</span>
<span class="linecomment">;;  completion.  Some are general, appropriate for most kinds of</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Those marked above with the label `22' can be used only with Emacs</span>
<span class="linecomment">;;  22 or later.  Those marked with a hyphen (-) are defined using</span>
<span class="linecomment">;;  `icicle-define-sort-command', so they correspond to explicit</span>
<span class="linecomment">;;  commands whose doc you can examine.  The command names in this</span>
<span class="linecomment">;;  case are `icicle-sort-' followed by the sort-order names (with</span>
<span class="linecomment">;;  hyphens substituted for spaces) - for example,</span>
<span class="linecomment">;;  `icicle-sort-by-directories-last' and `icicle-sort-turned-OFF'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Adding a Saved Sort Order")</span>
<span class="linecomment">;;  ** Adding a Saved Sort Order **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many predefined sort orders (see</span>
<span class="linecomment">;;  (@&gt; "Different Sorts for Different Sorts of Uses")), and you can</span>
<span class="linecomment">;;  define your own new sort orders (see</span>
<span class="linecomment">;;  (@&gt; "Defining New Sort Orders")).  This section is about a unique</span>
<span class="linecomment">;;  Icicles feature that lets you combine any number of sort orders</span>
<span class="linecomment">;;  interactively, melding them together.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You do this as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Start with a given sort order (use `C-u C-,' to choose one).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Save the set of candidates you are interested in, using `C-M-&gt;'</span>
<span class="linecomment">;;     (see (@&gt; "Saving and Retrieving Completion Candidates")).  This</span>
<span class="linecomment">;;     saves the candidates in their current order at the time of the</span>
<span class="linecomment">;;     save: the saved order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Choose a different sort order (e.g., use `C-u C-,').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Use `C-M-+' (`icicle-plus-saved-sort') to combine the two sort</span>
<span class="linecomment">;;     orders, that is, the (new) current order and the saved order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What `icicle-plus-saved-sort' does is sum, for each completion</span>
<span class="linecomment">;;  candidate, its ranks (indexes) in the two sort orders, and then</span>
<span class="linecomment">;;  reorder candidates based on the summed ranks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if a given candidate is the 4th candidate in the</span>
<span class="linecomment">;;  current list of candidates, and it is the 7th candidate in the</span>
<span class="linecomment">;;  saved list of candidates, then its combined sort rank is 4 + 7 =</span>
<span class="linecomment">;;  11.  With a score of 11 it sorts after a candidate whose score is,</span>
<span class="linecomment">;;  for example, 6, and before a candidate whose score is, for</span>
<span class="linecomment">;;  example, 13.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The candidates are reordered according to the combined sort</span>
<span class="linecomment">;;  orders, forming a new current order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `C-M-+' it does not matter what order the saved</span>
<span class="linecomment">;;  candidates are in or what order you used to sort the current</span>
<span class="linecomment">;;  candidates.  (But you will generally want to use the same set of</span>
<span class="linecomment">;;  candidates.)  In particular, after using `C-M-+' the candidates</span>
<span class="linecomment">;;  are typically in an order that corresponds to no predefined sort -</span>
<span class="linecomment">;;  that's OK.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-M-+' again if you like, to add in the saved sort</span>
<span class="linecomment">;;  order again with the new current order.  This gives the saved</span>
<span class="linecomment">;;  order more weight than the original current sort order.  Continued</span>
<span class="linecomment">;;  repetition of `C-M-+' gives the saved sort order more and more</span>
<span class="linecomment">;;  weight.  Eventually a fixed point is reached: `C-M-+' produces no</span>
<span class="linecomment">;;  further change in the order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, consider `icicle-read-color'.  With user option</span>
<span class="linecomment">;;  `icicle-WYSIWYG-Completions-flag' non-`nil' (e.g. a string) it</span>
<span class="linecomment">;;  lets you see the effect of `C-M-+' in a striking, graphical way.</span>
<span class="linecomment">;;  However, to see the effect you will first want to use `S-pause'</span>
<span class="linecomment">;;  (`icicle-toggle-highlight-saved-candidates') to turn off</span>
<span class="linecomment">;;  highlighting of the saved candidates, since that highlighting</span>
<span class="linecomment">;;  obscures the color highlighting.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sorting by color hue shows essentially a single rainbow of</span>
<span class="linecomment">;;  candidates in `*Completions*': pinks, followed by magentas,</span>
<span class="linecomment">;;  purples, blues, cyans, greens, yellows, browns, reds, and grays.</span>
<span class="linecomment">;;  Sorting by color brightness shows a single value gamut, the</span>
<span class="linecomment">;;  brightest colors followed by dimmer and dimmer colors, down to the</span>
<span class="linecomment">;;  dimmest (black).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Try `M-x icicle-read-color', sorting (`C-u C-,') first by hue.</span>
<span class="linecomment">;;  Save the completion candidates (`C-M-&gt;').  Now sort by brightness</span>
<span class="linecomment">;;  (`C-u C-,' again).  Now use `C-M-+' to add/merge the two sort</span>
<span class="linecomment">;;  orders.  You now see essentially a series of rainbows, from</span>
<span class="linecomment">;;  brighter to dimmer and dimmer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Use `C-M-+' again, to give hue more prominence in the merged sort</span>
<span class="linecomment">;;  order.  And again.  Keep hitting `C-M-+' until there is no more</span>
<span class="linecomment">;;  apparent change in the sort order - at this point you are back to</span>
<span class="linecomment">;;  a pure hue sort.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also at any time save the candidates again, saving the</span>
<span class="linecomment">;;  latest order as the new sort order.  Then you can reorder the</span>
<span class="linecomment">;;  current candidates using a different sort order (`C-,').  And then</span>
<span class="linecomment">;;  use `C-M-+' again to merge in the newly saved order.  You can play</span>
<span class="linecomment">;;  this way ad infinitem.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Customization and General Tips")</span>
<span class="linecomment">;;    for more about `icicle-buffer-sort' and other buffer-name</span>
<span class="linecomment">;;    completion parameters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Global Filters") for a</span>
<span class="linecomment">;;    way to filter and sort the domain of discourse, that is, all</span>
<span class="linecomment">;;    possible candidates, prior to any use of completion.</span>
 
<span class="linecomment">;;(@* "Get Help on Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Get Help on Candidates</span>
<span class="linecomment">;;  ----------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  General Icicles help is available at any time during minibuffer</span>
<span class="linecomment">;;  input, by hitting `C-?' (`icicle-minibuffer-help').  This section</span>
<span class="linecomment">;;  is about specific help on individual completion candidates</span>
<span class="linecomment">;;  instead.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you cycle among candidates for input, help on the current</span>
<span class="linecomment">;;  candidate is shown in the mode-line, provided user option</span>
<span class="linecomment">;;  `icicle-help-in-mode-line-delay' is greater than zero.  This makes</span>
<span class="linecomment">;;  it easy to see what each candidate means or does.  Similarly, this</span>
<span class="linecomment">;;  help is shown whenever your input is completed entirely to one of</span>
<span class="linecomment">;;  the candidates.  If you use library `lacarte.el', then mode-line</span>
<span class="linecomment">;;  candidate help is even available for menu-item candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Typically, this candidate mode-line help is the first line of the</span>
<span class="linecomment">;;  candidate's doc string, but alternative help sources can be used</span>
<span class="linecomment">;;  (and a doc string is not available for some kinds of candidates).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To see more help than what is shown in the mode-line, for each</span>
<span class="linecomment">;;  candidate or any given candidate as you cycle, press and hold the</span>
<span class="linecomment">;;  Control and Meta keys while using the vertical arrow keys, for</span>
<span class="linecomment">;;  prefix completion, or the `prior' and `next' keys (often labeled</span>
<span class="linecomment">;;  Page Up and Page Down), for apropos completion.  To show help on</span>
<span class="linecomment">;;  any individual candidate, navigate to it (by cycling or using</span>
<span class="linecomment">;;  completion), and hit `C-M-RET' - or press Control and Meta and</span>
<span class="linecomment">;;  click it with `mouse-2' (`C-M-mouse-2') in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you use standard command `switch-to-buffer' and</span>
<span class="linecomment">;;  you cycle among candidate buffer names using `C-M-end' (prefix</span>
<span class="linecomment">;;  completion), then the major and minor modes of each candidate</span>
<span class="linecomment">;;  buffer are described in buffer `*Help*' as the buffer name appears</span>
<span class="linecomment">;;  in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, you need not use the Meta key for candidate help; the</span>
<span class="linecomment">;;  same bindings work with just the Control key.  So, for example,</span>
<span class="linecomment">;;  you can click `C-mouse-2' to get help on a candidate or use</span>
<span class="linecomment">;;  `C-next' to cycle candidate help information.  However, Icicles</span>
<span class="linecomment">;;  multi-commands often have a different use for these bindings that</span>
<span class="linecomment">;;  do not include Meta.  It is only by default, when a multi-command</span>
<span class="linecomment">;;  has not bound a more specific action to the plain Control</span>
<span class="linecomment">;;  bindings, that you can use the sans-Meta bindings for help on</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, Icicles binds `M-x', `C-x b', and `C-x C-f' to</span>
<span class="linecomment">;;  multi-commands that execute a command, switch to a buffer, and</span>
<span class="linecomment">;;  open a file, respectively.  If you use only the Control key,</span>
<span class="linecomment">;;  without the Meta key, when choosing candidates for these commands,</span>
<span class="linecomment">;;  you will not get help on the candidates; instead, you will execute</span>
<span class="linecomment">;;  a candidate command, switch to a candidate buffer, and open a</span>
<span class="linecomment">;;  candidate file, respectively.  For more information, see</span>
<span class="linecomment">;;  (@&gt; "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Use Candidate Help Like You Use Emacs Command `apropos'")</span>
<span class="linecomment">;;  ** Use Candidate Help Like You Use Emacs Command `apropos' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use this candidate-help functionality as a kind of</span>
<span class="linecomment">;;  expanded `apropos' functionality.  As an example, type `C-h v</span>
<span class="linecomment">;;  out', then type `S-TAB' to display all variables that match "out"</span>
<span class="linecomment">;;  (in buffer `*Completions*').  Then use `C-M-next' repeatedly to</span>
<span class="linecomment">;;  cycle among those variables, displaying their documentation in the</span>
<span class="linecomment">;;  `*Help*' buffer as they appear one by one in the minibuffer.  Or</span>
<span class="linecomment">;;  click individual variable names with `C-M-mouse-2', to display</span>
<span class="linecomment">;;  their documentation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The standard `apropos' commands show only the first doc-string</span>
<span class="linecomment">;;  line.  Icicles shows that automatically in the mode-line, and it</span>
<span class="linecomment">;;  shows the complete doc string on demand when you use `C-M-'.  This</span>
<span class="linecomment">;;  can be handy, for instance, when you are unsure which of several</span>
<span class="linecomment">;;  similarly named candidates to choose.  Seeing a candidate's</span>
<span class="linecomment">;;  documentation along with its name can help you decide.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can click links in buffer `*Help*' to look up more info, and</span>
<span class="linecomment">;;  then resume `C-M-next' where you left off, all without leaving</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This also works with menu items, if you load library `lacarte.el'</span>
<span class="linecomment">;;  as well as Icicles.  As you cycle among matching menu items, the</span>
<span class="linecomment">;;  corresponding command documentation is displayed in `*Help*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you also use library `help-fns+.el' (Emacs 22 or later) or</span>
<span class="linecomment">;;  library `help+.el' (or `help+20.el' for Emacs 20), then you can</span>
<span class="linecomment">;;  use these Icicles features with additional help commands such as</span>
<span class="linecomment">;;  `describe-file' (`C-h M-f'), `describe-keymap' (`C-h M-k'),</span>
<span class="linecomment">;;  `describe-command' (`C-h C-c'), `describe-option' (`C-h o'), and</span>
<span class="linecomment">;;  `describe-option-of-type'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-h C-o', which is bound by those libraries to command</span>
<span class="linecomment">;;  `describe-option-of-type', is bound in Icicle mode to</span>
<span class="linecomment">;;  `icicle-describe-option-of-type' instead, which uses</span>
<span class="linecomment">;;  multi-completion and is therefore more powerful.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Multi-Completions").</span>
<span class="linecomment">;;  `C-h C-o' describes a user option that is of a particular custom</span>
<span class="linecomment">;;  type: you match the type and the option name at the same time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example, try `C-h C-o ici C-M-j string S-TAB' (`C-M-j' just</span>
<span class="linecomment">;;  separates the option name and type parts).  In buffer</span>
<span class="linecomment">;;  `*Completions*', you see all options whose name contains `ici' and</span>
<span class="linecomment">;;  whose type (or an inherited type) definition contains `string'.</span>
<span class="linecomment">;;  That means not only options that are strings, but options that are</span>
<span class="linecomment">;;  lists that contain string elements, options that can be a string</span>
<span class="linecomment">;;  or something else, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Browse the doc for these options, one after the other, using</span>
<span class="linecomment">;;  `C-M-next'.  This is a way to see, at the same time, the</span>
<span class="linecomment">;;  documentation for individual options (in buffer `*Help*') and the</span>
<span class="linecomment">;;  types their values must satisfy (in `*Completions*').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And remember that you can leave the option-name part or the type</span>
<span class="linecomment">;;  part empty, to see all options of a certain type or options of all</span>
<span class="linecomment">;;  types with a certain name pattern.  For example, `C-h C-o .* C-M-j</span>
<span class="linecomment">;;  string S-TAB' or `C-h C-o ici S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And you can of course use progressive completion as well, to</span>
<span class="linecomment">;;  match, say, a type that has a `string' component and an `integer'</span>
<span class="linecomment">;;  component - or whatever.  The type part of a completion candidate</span>
<span class="linecomment">;;  is an entire `defcustom' type, so its `:tag' values are also</span>
<span class="linecomment">;;  included.  This means that you can also match against the</span>
<span class="linecomment">;;  descriptive text (tag) that appears next to a value component in</span>
<span class="linecomment">;;  Customize.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-h C-o' is a powerful way to browse options and their</span>
<span class="linecomment">;;  documentation.  See the doc string of</span>
<span class="linecomment">;;  `icicle-describe-option-of-type' for more possibilities.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Candidate help (prefix `C-M-') is available for these types of</span>
<span class="linecomment">;;  completion candidates, by default:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * menu items</span>
<span class="linecomment">;;  * commands and other functions</span>
<span class="linecomment">;;  * keymap variables (if `describe-keymap' is defined - see</span>
<span class="linecomment">;;    library `help-fns+.el')</span>
<span class="linecomment">;;  * user options and other variables</span>
<span class="linecomment">;;  * faces</span>
<span class="linecomment">;;  * fonts (mode-line help only)</span>
<span class="linecomment">;;  * command abbreviations (using `apropos-command' for matches)</span>
<span class="linecomment">;;  * property lists</span>
<span class="linecomment">;;  * buffers</span>
<span class="linecomment">;;  * files</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Starting with Emacs 22, if the candidate names an image file and</span>
<span class="linecomment">;;  you have command-line tool `exiftool' installed and in your</span>
<span class="linecomment">;;  `$PATH' or `exec-path', then EXIF information (metadata) about the</span>
<span class="linecomment">;;  image is included.  See standard Emacs library `image-dired.el'</span>
<span class="linecomment">;;  for more information about `exiftool'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the same candidate names a function, a variable, and a face, or</span>
<span class="linecomment">;;  any two of these, then all such documentation is shown (Emacs 22</span>
<span class="linecomment">;;  and later).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to the candidate types listed above, any command that</span>
<span class="linecomment">;;  uses completion can define its own candidate help action function</span>
<span class="linecomment">;;  and bind it to `icicle-candidate-help-fn'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A command can also provide its own mode-line and tooltip help for</span>
<span class="linecomment">;;  any individual candidate.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Applying Text Properties to a Candidate String").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For more information about the types of candidates and their</span>
<span class="linecomment">;;  associated documentation, see the documentation for command</span>
<span class="linecomment">;;  `icicle-help-on-candidate'.  This command is bound to `C-M-RET',</span>
<span class="linecomment">;;  `C-M-mouse-2', `C-help', `C-M-help', `C-f1', and `C-M-f1'.  When</span>
<span class="linecomment">;;  no specific action is defined for candidates, it is also bound to</span>
<span class="linecomment">;;  `C-RET' and `C-mouse-2'.  You can use this to get help on any</span>
<span class="linecomment">;;  completion candidate during completion.  See also the related</span>
<span class="linecomment">;;  help-cycling commands, `icicle-next-candidate-per-mode-help',</span>
<span class="linecomment">;;  `icicle-help-on-next-apropos-candidate', and so on, bound to</span>
<span class="linecomment">;;  `C-M-down', `C-M-up', `C-M-next', `C-M-prior', `C-M-end', and</span>
<span class="linecomment">;;  `C-M-home'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use one-buffer-per-frame (`pop-up-frames' non-`nil'), then</span>
<span class="linecomment">;;  displaying `*Help*' in one frame might interfere with viewing</span>
<span class="linecomment">;;  `*Completions*' in another.  For that reason, the `*Completions*'</span>
<span class="linecomment">;;  frame is raised to the front.  Also, if user option</span>
<span class="linecomment">;;  `icicle-Completions-frame-at-right-flag' is non-`nil' (default</span>
<span class="linecomment">;;  value: `t'), then the `*Completions*' frame is moved to the right,</span>
<span class="linecomment">;;  out of the way, whenever you access help on a candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Other Icicles Apropos Commands")</span>
<span class="linecomment">;;  ** Other Icicles Apropos Commands **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are also Icicles replacements for the standard Emacs</span>
<span class="linecomment">;;  `apropos' commands.  They act similarly, but they also let you see</span>
<span class="linecomment">;;  the list of regexp matches incrementally (as with all Icicles</span>
<span class="linecomment">;;  commands), using `S-TAB'.  If you also use my library</span>
<span class="linecomment">;;  `apropos-fn+var.el', then these Icicles commands take advantage of</span>
<span class="linecomment">;;  the apropos enhancements in that library.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Icicles apropos commands are: `icicle-apropos',</span>
<span class="linecomment">;;  `icicle-apropos-command', `icicle-apropos-function',</span>
<span class="linecomment">;;  `icicle-apropos-option', `icicle-apropos-variable', and</span>
<span class="linecomment">;;  `icicle-apropos-zippy'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another feature of these Icicles commands is that when more than</span>
<span class="linecomment">;;  one type of object can be a candidate, candidates of a certain</span>
<span class="linecomment">;;  type are shown in buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-special-candidate'.  For example, command `icicle-apropos'</span>
<span class="linecomment">;;  shows function names as special candidates, to help you</span>
<span class="linecomment">;;  distinguish them from variable names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, Icicles commands `icicle-doc', `icicle-fundoc', and</span>
<span class="linecomment">;;  `icicle-vardoc' provide the functionality of standard Emacs</span>
<span class="linecomment">;;  command `apropos-documentation', but with additional features -</span>
<span class="linecomment">;;  see (@file :file-name "icicles-doc2.el" :to "Multi-Completions").</span>
<span class="linecomment">;;  In addition, you can use command `icicle-plist' to find symbols</span>
<span class="linecomment">;;  with certain property-list keys and values, and you can use</span>
<span class="linecomment">;;  command `icicle-describe-option-of-type' (bound to `C-h C-o') to</span>
<span class="linecomment">;;  find user options of a certain type.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-customize-apropos-options-of-type' is similar to</span>
<span class="linecomment">;;  `icicle-describe-option-of-type', in that it lets you specify the</span>
<span class="linecomment">;;  type of matching options.  But instead of describing an option, it</span>
<span class="linecomment">;;  opens Customize for all options of the specified type that match</span>
<span class="linecomment">;;  your input regexp.  (Unlike `icicle-describe-option-of-type',</span>
<span class="linecomment">;;  however, it is not a multi-completion command: you first specify</span>
<span class="linecomment">;;  the type, then the regexp to match.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One difference between Icicles apropos commands and the standard</span>
<span class="linecomment">;;  commands, besides the Icicles enhancements already described, is</span>
<span class="linecomment">;;  that (starting with Emacs 22) the standard commands let you input</span>
<span class="linecomment">;;  a set of keywords, as an alternative to inputting a regexp.</span>
<span class="linecomment">;;  Icicles apropos commands do not allow for keyword input, as such.</span>
<span class="linecomment">;;  However, Icicles progressive completion provides a more powerful</span>
<span class="linecomment">;;  way to search with multiple keywords (in fact, multiple regexps) -</span>
<span class="linecomment">;;  you can of course use it with the Icicles apropos commands.  Also,</span>
<span class="linecomment">;;  there are several problems with the standard Emacs apropos</span>
<span class="linecomment">;;  commands, with respect to interpreting your input as either a set</span>
<span class="linecomment">;;  of keywords or a regexp.  Because they allow two very different</span>
<span class="linecomment">;;  syntaxes as input, the standard apropos commands are forced to</span>
<span class="linecomment">;;  make some limiting compromises for keyword searching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Progressive Completion").</span>
 
<span class="linecomment">;;(@* "Multi-Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-Commands</span>
<span class="linecomment">;;  --------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "What Is a Multi-Command?")</span>
<span class="linecomment">;;  ** What Is a Multi-Command? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A multi-command is a command that lets you make multiple input</span>
<span class="linecomment">;;  choices in a single command execution: a multiple-choice command.</span>
<span class="linecomment">;;  You can choose multiple items from a set of choices, using buffer</span>
<span class="linecomment">;;  `*Completions*' as a multiple-choice "menu".  (It's not necessary</span>
<span class="linecomment">;;  to display `*Completions*', however.)  Instead of asking you</span>
<span class="linecomment">;;  "Which file do you want to delete?", a multi-command asks you, in</span>
<span class="linecomment">;;  effect, "Which file(S) do you want to delete?".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nothing especially new here.  Any Emacs command could be defined</span>
<span class="linecomment">;;  to use an input loop, asking for file names until you do something</span>
<span class="linecomment">;;  to signal that you're done inputting.  It could provide for</span>
<span class="linecomment">;;  file-name completion by calling `read-file-name' to read your</span>
<span class="linecomment">;;  input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * But what if you could also filter the domain of discourse on the</span>
<span class="linecomment">;;    fly, so that the candidate files were only those matching a</span>
<span class="linecomment">;;    regular expression (regexp) that you typed? Then, the command</span>
<span class="linecomment">;;    definition would need to provide for that behavior too.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * And what if you could then take the complement of that set of</span>
<span class="linecomment">;;    candidate file names, with respect to the complete set of files</span>
<span class="linecomment">;;    in the directory? Or subtract (exclude) some set of file names</span>
<span class="linecomment">;;    from the set of matching names, to get the set of possible</span>
<span class="linecomment">;;    choices?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * And what if the set of potential candidates at each step (regexp</span>
<span class="linecomment">;;    match, complement, set difference) could also be displayed in a</span>
<span class="linecomment">;;    multiple-choice menu?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For such multi-command functionality you need Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can tell whether a command is a multi-command when you execute</span>
<span class="linecomment">;;  it: if it is a multi-command, then the prompt is prefixed by `+'.</span>
<span class="linecomment">;;  For example, multi-command `icicle-file' uses this prompt:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    + File or directory:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Normal, non multi-command `find-file' uses this prompt, which has</span>
<span class="linecomment">;;  no `+':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Find file:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just remember that `+' means that you can choose any number of</span>
<span class="linecomment">;;  inputs.  For a list of predefined Icicles multi-commands, use</span>
<span class="linecomment">;;  `C-?' (`icicle-minibuffer-help') in the minibuffer - search for</span>
<span class="linecomment">;;  `+' at the beginning of a line.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "How Does a Multi-Command Work?")</span>
<span class="linecomment">;;  ** How Does a Multi-Command Work? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When an Icicles multi-command prompts you for input, you can make</span>
<span class="linecomment">;;  a single choice and press `RET' to confirm it, as usual, or you</span>
<span class="linecomment">;;  can choose any number of completion candidates, using `C-RET' (or</span>
<span class="linecomment">;;  `C-mouse-2') for each.  You can thus act on multiple candidates,</span>
<span class="linecomment">;;  or even multiple times on the same candidate, during the same</span>
<span class="linecomment">;;  execution of the command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But you do not have to - you can use any multi-command just as if</span>
<span class="linecomment">;;  it were a normal, single-choice command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, command `icicle-delete-file' lets you delete a single</span>
<span class="linecomment">;;  file or a set of files that match your minibuffer input - all in</span>
<span class="linecomment">;;  the same command execution.  If you type no input, then all files</span>
<span class="linecomment">;;  in the current directory match, and you can delete any number of</span>
<span class="linecomment">;;  them individually.  If you type `~$' and hit `S-TAB'</span>
<span class="linecomment">;;  (`icicle-apropos-complete'), then all files that end in `~' match,</span>
<span class="linecomment">;;  and you can delete any number of them.  Similarly, command</span>
<span class="linecomment">;;  `icicle-buffer-other-window' lets you display any number of</span>
<span class="linecomment">;;  buffers, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You make multiple choices this way by cycling through the</span>
<span class="linecomment">;;  candidate completions, as usual, and hitting `C-RET' whenever you</span>
<span class="linecomment">;;  want to choose (act on) the current cycle candidate.  Or just</span>
<span class="linecomment">;;  press and hold Control while clicking each chosen candidate with</span>
<span class="linecomment">;;  `mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similarly, you can use `C-down', `C-up', `C-next', `C-prior',</span>
<span class="linecomment">;;  `C-end', or `C-home' to act on successive candidates, forward or</span>
<span class="linecomment">;;  backward.  You can thus just hold down the Control key while</span>
<span class="linecomment">;;  cycling, to act on each candidate in turn, if you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of, or in addition to, cycling, you can use completion to</span>
<span class="linecomment">;;  get to a particular candidate you want.  No matter how a candidate</span>
<span class="linecomment">;;  is made current, you can choose the current candidate (perform the</span>
<span class="linecomment">;;  action on it) using `C-RET' or `C-mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For lax (permissive) completion, you can use `C-RET' to act on</span>
<span class="linecomment">;;  *any* input text - you need not choose one of the available</span>
<span class="linecomment">;;  candidates.  This means, for example, that you can create any</span>
<span class="linecomment">;;  number of new file buffers with a single `C-x C-f' invocation, as</span>
<span class="linecomment">;;  well as open any number of existing files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As always, hitting `RET' (or `S-RET') ends the command.  For most</span>
<span class="linecomment">;;  multi-commands, hitting `RET' performs the same action as `C-RET',</span>
<span class="linecomment">;;  but it is possible to have a command that acts differently for</span>
<span class="linecomment">;;  `RET' and `C-RET'.  That is the case, for instance, when help is</span>
<span class="linecomment">;;  displayed via `C-RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-RET' or `C-mouse-2' repeatedly to act multiple</span>
<span class="linecomment">;;  times on the same candidate.  A shortcut is to use `C-u' with</span>
<span class="linecomment">;;  `C-RET' or `C-mouse-2'.  That will work if the candidate action</span>
<span class="linecomment">;;  function is designed to be `C-u' sensitive.  This is the case for</span>
<span class="linecomment">;;  the Icicles multi-commands that read the name of a command or</span>
<span class="linecomment">;;  keyboard macro and execute the command or macro:</span>
<span class="linecomment">;;  `icicle-execute-extended-command' (`M-x'), `icicle-kmacro'</span>
<span class="linecomment">;;  (`S-f4'), and `icicle-execute-named-keyboard-macro' (`C-x M-e').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, for example, if you use `C-u 10 C-RET' on command</span>
<span class="linecomment">;;  `forward-char' during `M-x' command completion, the cursor</span>
<span class="linecomment">;;  advances 10 characters.  Another example: `C-x M-e C-u 200 C-RET'</span>
<span class="linecomment">;;  on a keyboard-macro candidate `foo' executes `foo' 200 times.  You</span>
<span class="linecomment">;;  can use all of the numeric prefix argument shortcuts, such as</span>
<span class="linecomment">;;  `M--', `M-7', and `C-6', with the exception of `C--', which has a</span>
<span class="linecomment">;;  different meaning (`icicle-candidate-set-difference') in the</span>
<span class="linecomment">;;  Icicles minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that you can supply a prefix argument for both the</span>
<span class="linecomment">;;  multi-command and any of its individual actions.  The command is</span>
<span class="linecomment">;;  free to interpret these differently.  For example, a prefix arg</span>
<span class="linecomment">;;  for `icicle-kmacro' provides a default repeat factor, which can</span>
<span class="linecomment">;;  then be overridden for any individual action by providing a</span>
<span class="linecomment">;;  different prefix arg.  As another example, a prefix arg used with</span>
<span class="linecomment">;;  any file-name candidate for command `icicle-find-file' visits the</span>
<span class="linecomment">;;  file in read-only mode.  But a prefix arg for the command itself</span>
<span class="linecomment">;;  reverses this effect: read-only becomes the default so that a</span>
<span class="linecomment">;;  prefix arg for a candidate means visit not read-only.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-use-candidates-only-once-flag' is</span>
<span class="linecomment">;;  non-`nil', then, when you act on a candidate, it is removed from</span>
<span class="linecomment">;;  the list of available candidates, for clarity.  Commands where</span>
<span class="linecomment">;;  this behavior is appropriate bind this option to a non-`nil'</span>
<span class="linecomment">;;  value.  This is a user option, but you normally will not customize</span>
<span class="linecomment">;;  it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-g' to exit a multi-command at any time, without</span>
<span class="linecomment">;;  making a final choice using `RET'.  If the actions performed by a</span>
<span class="linecomment">;;  multi-command are easily reversible, `C-g' will often restore</span>
<span class="linecomment">;;  things to the way they were before performing the actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Does this `C-RET' stuff sound familiar?  Using a multi-command is</span>
<span class="linecomment">;;  similar to accessing help on a candidate</span>
<span class="linecomment">;;  (see (@&gt; "Get Help on Candidates")).  A multi-command is any</span>
<span class="linecomment">;;  command that has a special action defined for use with `C-RET'</span>
<span class="linecomment">;;  (command `icicle-candidate-action') on the current cycle</span>
<span class="linecomment">;;  candidate.  If no such special action is defined, then help on the</span>
<span class="linecomment">;;  candidate is displayed - displaying help is just the default</span>
<span class="linecomment">;;  action for `C-RET', used when no other action is defined.  You can</span>
<span class="linecomment">;;  always access candidate help using the `C-M-' prefix: `C-M-help',</span>
<span class="linecomment">;;  `C-M-f1', `C-M-RET', `C-M-mouse-2', `C-M-down', `C-M-up',</span>
<span class="linecomment">;;  `C-M-next', `C-M-prior', `C-M-end', and `C-M-home'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also cycle among elements of a set, performing actions, if</span>
<span class="linecomment">;;  you use my libraries `doremi.el', `doremi-cmd.el', and</span>
<span class="linecomment">;;  `doremi-frm.el'.  Like Icicles, Do Re Mi lets you see the effect</span>
<span class="linecomment">;;  of a choice immediately, whenever you make changes.  Each library</span>
<span class="linecomment">;;  has its own advantages and special uses.  Advantages of Icicles</span>
<span class="linecomment">;;  include:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - completion to candidate values</span>
<span class="linecomment">;;    - restoration after making changes, letting you preview changes</span>
<span class="linecomment">;;      without actually applying them</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "More about Multi-Commands") for more about using</span>
<span class="linecomment">;;    multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;    for how to define your own multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Moving Between the Minibuffer and Other Buffers").</span>
 
<span class="linecomment">;;(@* "More about Multi-Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  More about Multi-Commands</span>
<span class="linecomment">;;  -------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A multi-command is any command that uses input completion and lets</span>
<span class="linecomment">;;  you perform actions on any number of individual completion</span>
<span class="linecomment">;;  candidates without exiting completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The default action is invoked on the current candidate by `C-RET'</span>
<span class="linecomment">;;  (`icicle-candidate-action').  There are three other kinds of</span>
<span class="linecomment">;;  actions on individual candidates:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * alternative actions, invoked by `C-S-RET'</span>
<span class="linecomment">;;  * deletion actions, invoked by `S-delete'</span>
<span class="linecomment">;;  * help actions, invoked by `C-M-RET'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A given command can define any combination of these four kinds of</span>
<span class="linecomment">;;  actions: none of them, any one of them, any two of them, any three</span>
<span class="linecomment">;;  of them, or all four kinds.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section provides information about alternative actions and</span>
<span class="linecomment">;;  deletion actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Get Help on Candidates") for information about using</span>
<span class="linecomment">;;    candidate help.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;    for information about defining a custom candidate-help action</span>
<span class="linecomment">;;    for a command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Alternative Actions")</span>
<span class="linecomment">;;  ** Alternative Actions **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as you can use `C-RET', `C-mouse-2', `C-next', and so on to</span>
<span class="linecomment">;;  invoke a command's default action on multiple completion</span>
<span class="linecomment">;;  candidates individually, so you can use `C-S-RET'</span>
<span class="linecomment">;;  (`icicle-candidate-alt-action'), `C-S-mouse-2', `C-S-next', and so</span>
<span class="linecomment">;;  on to invoke an alternative action that is associated with the</span>
<span class="linecomment">;;  command.  If the main action of a command `my-find-file' is to</span>
<span class="linecomment">;;  visit a file, and the alternative action is to print a file, then</span>
<span class="linecomment">;;  you can use `C-S-RET' to print one or more files on the fly, even</span>
<span class="linecomment">;;  as you are completing the name of a file to be visited.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keys `C-|' and `M-|' apply the alternative action defined for a</span>
<span class="linecomment">;;  given multi-command to *all* matching candidates at once, in the</span>
<span class="linecomment">;;  same way that `C-!' and `M-!' apply the main action defined for it</span>
<span class="linecomment">;;  to all candidates.  For example, in Icicles search (e.g. `C-c `'),</span>
<span class="linecomment">;;  the alternative action (e.g. `C-S-RET') replaces all or part of</span>
<span class="linecomment">;;  the current search hit, and `M-|' does the same for all search</span>
<span class="linecomment">;;  hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is the particular command that defines its alternative action.</span>
<span class="linecomment">;;  Some commands define no such action.  Some commands, as their</span>
<span class="linecomment">;;  alternative action, prompt you to choose (using completion) a</span>
<span class="linecomment">;;  function to be applied to the current completion candidate.  In</span>
<span class="linecomment">;;  this case, a single alternative action effectively provides a set</span>
<span class="linecomment">;;  of possible actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To achieve this, such commands use the value of user option</span>
<span class="linecomment">;;  `icicle-type-actions-alist', which associates lists of possible</span>
<span class="linecomment">;;  functions with specific candidate types.  For example, for</span>
<span class="linecomment">;;  file-name candidates, you can choose among functions that act on</span>
<span class="linecomment">;;  file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Choosing such a function to apply is itself a multi-command</span>
<span class="linecomment">;;  operation.  You can thus apply any number of functions to any</span>
<span class="linecomment">;;  number of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, while you are using `C-x C-f', you can, say, print</span>
<span class="linecomment">;;  one or more candidate files on the fly, or invoke a shell command</span>
<span class="linecomment">;;  on selected files, or byte-compile them...  This is a particularly</span>
<span class="linecomment">;;  handy feature, especially if you customize</span>
<span class="linecomment">;;  `icicle-type-actions-alist' for your own particular use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some such functions you can choose produce no side effect; they</span>
<span class="linecomment">;;  simply return a value.  But if you use `C-u' before `C-S-RET',</span>
<span class="linecomment">;;  then the result of applying the function is pretty-printed (in the</span>
<span class="linecomment">;;  echo area or buffer `*Pp Eval Output*').  For example, if you use</span>
<span class="linecomment">;;  `C-x C-f', you hit `C-u C-S-RET' on the candidate file name</span>
<span class="linecomment">;;  `icicles-doc1.el', and you choose the function candidate</span>
<span class="linecomment">;;  `file-attributes' at the completion prompt `How (action): ', then</span>
<span class="linecomment">;;  the properties of the candidate file (`icicles-doc1.el') are</span>
<span class="linecomment">;;  displayed.  With just `C-S-RET' (no prefix arg), the list of</span>
<span class="linecomment">;;  properties is computed, but not displayed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Be aware of this gotcha: The alternative action for commands that</span>
<span class="linecomment">;;  use `icicle-type-actions-alist' prompts for a function.  If you</span>
<span class="linecomment">;;  want to apply that function to all current completion candidates,</span>
<span class="linecomment">;;  then you must use `M-|', not `C-|', because `C-|' prompts you for</span>
<span class="linecomment">;;  each candidate.  `M-|' is designed to do the right thing here: it</span>
<span class="linecomment">;;  prompts you once for the function to apply, and then applies it to</span>
<span class="linecomment">;;  each of the current candidates.  Andyou can filter the set of</span>
<span class="linecomment">;;  current candidates (progressive completion and so on), or retrieve</span>
<span class="linecomment">;;  a saved set of candidates to operate on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that completion while you choose a function to apply is lax.</span>
<span class="linecomment">;;  This means that you can really enter any function, including a</span>
<span class="linecomment">;;  lambda expression that you invent on the fly.  Of course, the</span>
<span class="linecomment">;;  function must accept an object of the appropriate type, (but it</span>
<span class="linecomment">;;  need not actually use that argument).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using a lambda expression here is a good way to curry a function</span>
<span class="linecomment">;;  that requires multiple arguments, so that it adapts to expect just</span>
<span class="linecomment">;;  a single argument of the appropriate object type.  For example,</span>
<span class="linecomment">;;  (lambda (sym-name) (get (intern (sym-name)) 'invisible))</span>
<span class="linecomment">;;  transforms function `get', which takes a symbol and a property as</span>
<span class="linecomment">;;  arguments, to a function that takes a symbol name and looks up the</span>
<span class="linecomment">;;  `invisible' property of the symbol.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Option `icicle-type-actions-alist' is predefined with a number of</span>
<span class="linecomment">;;  candidate types (buffer, color, command, face, file, frame,</span>
<span class="linecomment">;;  function, option, process, variable, and window) and their</span>
<span class="linecomment">;;  associated action functions, but you can add new types or modify</span>
<span class="linecomment">;;  their associated function lists.  Any Emacs-Lisp functions can be</span>
<span class="linecomment">;;  used, including lambda expressions.  But each function must accept</span>
<span class="linecomment">;;  a value of the appropriate type as its sole required argument</span>
<span class="linecomment">;;  (additional, optional arguments are OK).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes, you might want to define your own alternative action</span>
<span class="linecomment">;;  function for some command.  Do this if you always want the same</span>
<span class="linecomment">;;  alternative action, and it is not the predefined one.  To do this,</span>
<span class="linecomment">;;  just customize option `icicle-alternative-actions-alist'.  The</span>
<span class="linecomment">;;  associations defined by this option always override any predefined</span>
<span class="linecomment">;;  alternative actions for the corresponding commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  An alternative to using option `icicle-alternative-actions-alist'</span>
<span class="linecomment">;;  is to define a new command, wrapping an existing command with a</span>
<span class="linecomment">;;  `let' binding that defines the action you want.  I recommend using</span>
<span class="linecomment">;;  the option instead, but you might sometimes prefer this approach.</span>
<span class="linecomment">;;  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun my-icicle-find-file (f)</span>
<span class="linecomment">;;    "`icicle-find-file', but with `w32-browser' as the alt action."</span>
<span class="linecomment">;;    (interactive</span>
<span class="linecomment">;;      (let ((icicle-candidate-alt-action-fn  'w32-browser))</span>
<span class="linecomment">;;        (list (read-file-name "File: "))))</span>
<span class="linecomment">;;    (icicle-find-file f))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are familiar with Icicles object-action commands (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles OO: Object-Action Interaction")),</span>
<span class="linecomment">;;  then this idea of choosing an object (completion candidate) and</span>
<span class="linecomment">;;  then choosing a function to act on it will ring a bell.  And just</span>
<span class="linecomment">;;  as for the object-action commands, here too Icicles exploits any</span>
<span class="linecomment">;;  object-action associations ("sources" and "types") defined by</span>
<span class="linecomment">;;  library Anything (`anything.el'), if you happen to use that, in</span>
<span class="linecomment">;;  addition to the associations defined by</span>
<span class="linecomment">;;  `icicle-type-actions-alist'.  And when you do use the Icicles</span>
<span class="linecomment">;;  object-action commands, the same behavior is available as for</span>
<span class="linecomment">;;  alternative actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You might have noticed, above, that a type/actions association is</span>
<span class="linecomment">;;  predefined for type `function'.  Since the actions you can choose</span>
<span class="linecomment">;;  are themselves functions, you can even use `C-S-RET' on one of</span>
<span class="linecomment">;;  them, to apply a function-for-functions (e.g. `find-function' or</span>
<span class="linecomment">;;  `symbol-function') to it.  This is a curiosity, but it can</span>
<span class="linecomment">;;  sometimes be useful.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Finally, note that the completion candidate to which you apply an</span>
<span class="linecomment">;;  alternative action is in most cases a string.  In some cases, the</span>
<span class="linecomment">;;  alternative action functions expect a non-string object, and they</span>
<span class="linecomment">;;  will raise an error if applied to a string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles takes care of this in the case of buffer-name candidates.</span>
<span class="linecomment">;;  It assumes that you really want to operate on a buffer, not its</span>
<span class="linecomment">;;  name (a string), so it automatically calls `get-buffer' before</span>
<span class="linecomment">;;  applying the alternative action function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@* "Perform Alternative Operations on the Fly")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Search and Replace")</span>
<span class="linecomment">;;  * (@* "Choose All Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Deleting Objects")</span>
<span class="linecomment">;;  ** Deleting Objects **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When it is defined for a particular command, minibuffer command</span>
<span class="linecomment">;;  `icicle-delete-candidate-object', bound to `S-delete' (that's the</span>
<span class="linecomment">;;  `delete' key, Shifted), deletes the object or objects named by the</span>
<span class="linecomment">;;  completion candidate on which it operates.  (At least that is the</span>
<span class="linecomment">;;  default behavior - if you customize `icicle-deletion-action-flag'</span>
<span class="linecomment">;;  to `nil', then `S-delete' has no effect.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Which objects are thus targeted by a given candidate (name) is</span>
<span class="linecomment">;;  something that must be defined by the particular command.  The doc</span>
<span class="linecomment">;;  string of a command should always indicate the effect of using</span>
<span class="linecomment">;;  `S-delete', if a deletion action is defined.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of a deletion action, Icicles command</span>
<span class="linecomment">;;  `icicle-buffer-other-window', bound to `C-x 4 b', opens buffers</span>
<span class="linecomment">;;  named by the individual candidates you act on, using `C-RET'.  But</span>
<span class="linecomment">;;  it also lets you kill any buffer that you act on, using</span>
<span class="linecomment">;;  `S-delete'.  This is not the alternative action for the command</span>
<span class="linecomment">;;  (which is bound to `C-S-RET'); it is the deletion action.</span>
<span class="linecomment">;;  Similarly, command `icicle-bookmark' jumps to a bookmark, but you</span>
<span class="linecomment">;;  can also use `S-delete' with it to delete individual bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `S-delete' with a command that allows duplicate</span>
<span class="linecomment">;;  candidate names that represent different candidate objects, it</span>
<span class="linecomment">;;  deletes only the object associated with the current candidate</span>
<span class="linecomment">;;  (name).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some multi-commands define a deletion action, so that `S-delete'</span>
<span class="linecomment">;;  works; some do not.  Consult the doc for any given command to see</span>
<span class="linecomment">;;  if it does.  Whenever it is defined, the meaning of "delete"</span>
<span class="linecomment">;;  depends on the particular command you use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `S-delete' deletes only the objects named by the current</span>
<span class="linecomment">;;  completion candidate.  However, with a prefix argument, it deletes</span>
<span class="linecomment">;;  *ALL* objects named by the current set of completion candidates,</span>
<span class="linecomment">;;  after you confirm that this is really what you want to do.  This</span>
<span class="linecomment">;;  is a quick way to delete things whenever `S-delete' is available:</span>
<span class="linecomment">;;  Use input patterns, with progressive completion, chipping away,</span>
<span class="linecomment">;;  and so on, to define the candidates to delete, then use `C-u</span>
<span class="linecomment">;;  S-delete' and confirm their deletion.  Bye-bye.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Do not confuse the unshifted `delete' key with `S-delete'.</span>
<span class="linecomment">;;  `delete' does not delete any objects; it just removes a completion</span>
<span class="linecomment">;;  candidate so that you cannot complete to it.  `S-delete' deletes</span>
<span class="linecomment">;;  an object and removes its name as a completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are an Emacs-Lisp programmer, then you can define your own</span>
<span class="linecomment">;;  multi-commands that provide a deletion action via `S-delete'.</span>
<span class="linecomment">;;  There are two ways to do this.  Both involve binding</span>
<span class="linecomment">;;  `icicle-delete-candidate-object':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Bind it to a deletion function.  The function must accept a</span>
<span class="linecomment">;;    completion candidate string and perform the deletion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Bind it to a symbol (variable) whose value is a list of</span>
<span class="linecomment">;;    completion-candidate objects.  The entries in the list must be</span>
<span class="linecomment">;;    completion candidates for the current call to `completing-read',</span>
<span class="linecomment">;;    but the list itself need not be the COLLECTION argument to</span>
<span class="linecomment">;;    `completing-read'.  The list can be an alist, a list of strings,</span>
<span class="linecomment">;;    or a list of symbols.  The object that corresponds to the</span>
<span class="linecomment">;;    current candidate when `S-delete' is invoked is deleted from the</span>
<span class="linecomment">;;    list.  If, in addition, the list variable is a user option, then</span>
<span class="linecomment">;;    the updated list value is saved in the user's custom file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For more information about using this feature in Emacs-Lisp code,</span>
<span class="linecomment">;;  see the doc of function `icicle-delete-current-candidate-object'</span>
<span class="linecomment">;;  (`S-delete') and variable `icicle-delete-candidate-object'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Option `icicle-use-C-for-actions-flag'")</span>
<span class="linecomment">;;  ** Option `icicle-use-C-for-actions-flag' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In some contexts, you end up using `C-next' more than `next', and</span>
<span class="linecomment">;;  likewise for the other keys that combine candidate action and</span>
<span class="linecomment">;;  cycling.  This is especially true for Icicles multi-commands that</span>
<span class="linecomment">;;  act like a browser, such as `icicle-search', `icicle-imenu',</span>
<span class="linecomment">;;  `icicle-find-tag', `icicle-Info-goto-node', and</span>
<span class="linecomment">;;  `icicle-compilation-search'.  In these cases, you use the action</span>
<span class="linecomment">;;  keys to navigate among the locations indicated by the completion</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you set user option `icicle-use-C-for-actions-flag' to `nil',</span>
<span class="linecomment">;;  then the keys that cycle are swapped with the keys that both cycle</span>
<span class="linecomment">;;  and act on a candidate.  You can then use `down', `up', `next',</span>
<span class="linecomment">;;  `prior', `end', and `home' to both cycle and act (e.g. navigate),</span>
<span class="linecomment">;;  and `C-down', `C-up', `C-next', `C-prior', `C-end', and `C-home'</span>
<span class="linecomment">;;  to merely cycle, without acting.  The option has no effect on</span>
<span class="linecomment">;;  other keys.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can toggle `icicle-use-C-for-actions-flag' at any time using</span>
<span class="linecomment">;;  `M-g' (`icicle-toggle-C-for-actions') in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Accessing Saved Locations (Bookmarks) on the Fly")</span>
<span class="linecomment">;;  ** Accessing Saved Locations (Bookmarks) on the Fly **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you complete the names of some kinds of objects, you can use</span>
<span class="linecomment">;;  `C-x m' to follow bookmarks to objects of that type.  This is</span>
<span class="linecomment">;;  available only if you use library `bookmark+.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, when you invoke a command that completes file names,</span>
<span class="linecomment">;;  you can use `C-x m' to interrupt that operation and complete</span>
<span class="linecomment">;;  against the names of file bookmarks.  This is a multi-command, so</span>
<span class="linecomment">;;  you can actually visit any number of file bookmarks.  When</span>
<span class="linecomment">;;  finished, you can continue with non-bookmark file-name completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The same thing holds for Info bookmarks when you use</span>
<span class="linecomment">;;  `icicle-Info-goto-node' (`g' in Info mode); for buffer (non-file)</span>
<span class="linecomment">;;  bookmarks when you use `icicle-buffer' (`C-x b'); and for Dired</span>
<span class="linecomment">;;  bookmarks when you use `icicle-dired' (`C-x d').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Bookmark Enhancements")</span>
 
<span class="linecomment">;;(@* "Icicles Tripping")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tripping with Icicles</span>
<span class="linecomment">;;  ---------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Among the more useful multi-commands are those whose actions take</span>
<span class="linecomment">;;  you to some location indicated by the completion candidate.  This</span>
<span class="linecomment">;;  is the way commands such as `icicle-bookmark', `icicle-find-tag',</span>
<span class="linecomment">;;  `icicle-Info-goto-node', and `icicle-occur' work - you can use</span>
<span class="linecomment">;;  `next' and so on to move among candidates to choose them to act</span>
<span class="linecomment">;;  on, but when you do act on them, Icicles takes you to the places</span>
<span class="linecomment">;;  they name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So just holding down both the Control key and `next' takes you</span>
<span class="linecomment">;;  from one place to the next.  And `C-mouse-2' takes you directly to</span>
<span class="linecomment">;;  the location you click.  Typically, `C-g' aborts the trip and puts</span>
<span class="linecomment">;;  you back at your starting point, and `RET' ends the trip at the</span>
<span class="linecomment">;;  chosen destination.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many such Icicles tripping (or navigation or browsing)</span>
<span class="linecomment">;;  commands, and they all work similarly.  They give you the normal</span>
<span class="linecomment">;;  cycling behavior provided by vanilla Emacs commands such as</span>
<span class="linecomment">;;  `find-tag' (via `M-.', `C-u M-.', `M-*' etc.) or</span>
<span class="linecomment">;;  `set-mark-command' (via `C-u C-SPC').  But unlike the vanilla</span>
<span class="linecomment">;;  Emacs commands, the keys for this cycling are always the same.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  More importantly, you need not cycle through all possibilities.</span>
<span class="linecomment">;;  You can go directly to particular locations with `C-RET',</span>
<span class="linecomment">;;  `C-mouse-2' or using completion.  And your input filters the</span>
<span class="linecomment">;;  available candidates, as always.  And you can, as always, use</span>
<span class="linecomment">;;  progressive completion, chipping away, and so on to define your</span>
<span class="linecomment">;;  `C-next' trip itinerary using a process of refinement.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whereas vanilla Emacs gives you some commands that let you use</span>
<span class="linecomment">;;  completion to enter a destination and go there, and it gives you</span>
<span class="linecomment">;;  other commands that let you cycle among locations, Icicles rolls</span>
<span class="linecomment">;;  all of that into one.  And you use the same keys, always, to</span>
<span class="linecomment">;;  navigate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some of the Icicles tripping commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Trips among tagged files (delicious-style tagging - requires</span>
<span class="linecomment">;;    library `bookmark+.el').</span>
<span class="linecomment">;;    (Use prefix key `C-x 4 j' for other-window commands.)</span>
<span class="linecomment">;;    `icicle-find-file-all-tags'                (`C-x j t a *')</span>
<span class="linecomment">;;    `icicle-find-file-all-tags-regexp'         (`C-x j t a % *')</span>
<span class="linecomment">;;    `icicle-find-file-some-tags'               (`C-x j t a +')</span>
<span class="linecomment">;;    `icicle-find-file-some-tags-regexp'        (`C-x j t a % +')</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-bookmark-other-window' - (`C-- C-x r m')</span>
<span class="linecomment">;;    Trip among bookmarks of all types.  (Also bound to `C-x 4 j j'</span>
<span class="linecomment">;;    if library `bookmark+.el' is used.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Type-specific bookmark trips (requires library `bookmark+.el').</span>
<span class="linecomment">;;    (Use prefix key `C-x 4 j' for other-window commands.)</span>
<span class="linecomment">;;    `icicle-bookmark-non-file'                 (`C-x j b')</span>
<span class="linecomment">;;    `icicle-bookmark-bookmark-list'            (`C-x j B')</span>
<span class="linecomment">;;    `icicle-bookmark-dired'                    (`C-x j d')</span>
<span class="linecomment">;;    `icicle-bookmark-file'                     (`C-x j f')</span>
<span class="linecomment">;;    `icicle-bookmark-gnus'                     (`C-x j g')</span>
<span class="linecomment">;;    `icicle-bookmark-info'                     (`C-x j i')</span>
<span class="linecomment">;;    `icicle-bookmark-desktop'                  (`C-x j K')</span>
<span class="linecomment">;;    `icicle-bookmark-local-file'               (`C-x j l')</span>
<span class="linecomment">;;    `icicle-bookmark-man'                      (`C-x j m')</span>
<span class="linecomment">;;    `icicle-bookmark-region'                   (`C-x j r',</span>
<span class="linecomment">;;                                                `C-u C-x C-x')</span>
<span class="linecomment">;;    `icicle-bookmark-remote-file'              (`C-x j n')</span>
<span class="linecomment">;;    `icicle-bookmark-all-tags'                 (`C-x j t *')</span>
<span class="linecomment">;;    `icicle-bookmark-some-tags'                (`C-x j t +')</span>
<span class="linecomment">;;    `icicle-bookmark-all-tags-regexp'          (`C-x j t % *')</span>
<span class="linecomment">;;    `icicle-bookmark-some-tags-regexp'         (`C-x j t % +')</span>
<span class="linecomment">;;    `icicle-bookmark-file-all-tags'            (`C-x j t f *')</span>
<span class="linecomment">;;    `icicle-bookmark-file-all-tags-regexp'     (`C-x j t f % *')</span>
<span class="linecomment">;;    `icicle-bookmark-file-some-tags'           (`C-x j t f +')</span>
<span class="linecomment">;;    `icicle-bookmark-file-some-tags-regexp'    (`C-x j t f % +')</span>
<span class="linecomment">;;    `icicle-bookmark-url'                      (`C-x j u')</span>
<span class="linecomment">;;    `icicle-bookmark-w3m'                      (`C-x j w')</span>
<span class="linecomment">;;    `icicle-bookmark-this-buffer'              (`C-x j .')</span>
<span class="linecomment">;;    `icicle-bookmark-specific-buffers'         (`C-x j = b')</span>
<span class="linecomment">;;    `icicle-bookmark-specific-files'           (`C-x j = f')</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-buffer' (`C-x b')        - Trip among buffers</span>
<span class="linecomment">;;  * `icicle-compilation-search' (`C-c `') - Trip among `grep' hits</span>
<span class="linecomment">;;  * `icicle-dired'                   - Trip among directories</span>
<span class="linecomment">;;  * `icicle-find-file' (`C-x C-f')   - Trip among files</span>
<span class="linecomment">;;  * `icicle-find-file-absolute' (`C-u C-x C-f') - Trip among files</span>
<span class="linecomment">;;  * `icicle-find-file-in-tags-table' - Trip among files listed in</span>
<span class="linecomment">;;                                       current tags table (project)</span>
<span class="linecomment">;;  * `icicle-find-file-read-only' (`C-x C-r') - Visit read-only</span>
<span class="linecomment">;;  * `icicle-find-first-tag' (`C-x 4 .') - Trip among tag hits</span>
<span class="linecomment">;;  * `icicle-find-tag' (`M-.')        - Trip among tag hits</span>
<span class="linecomment">;;  * `icicle-goto-global-marker' (`C-- C-x C-SPC') - Trip among</span>
<span class="linecomment">;;                                       global markers</span>
<span class="linecomment">;;  * `icicle-goto-marker' (`C-- C-SPC') - Trip among local markers</span>
<span class="linecomment">;;  * `icicle-imenu' (`C-c ='), `icicle-imenu-command',</span>
<span class="linecomment">;;    `icicle-imenu-non-interactive-function' - Trip among definitions</span>
<span class="linecomment">;;  * `icicle-Info-goto-node' (`g' in Info)- Trip among Info nodes</span>
<span class="linecomment">;;  * `icicle-Info-index' (`i' in Info) - Trip among Info nodes</span>
<span class="linecomment">;;  * `icicle-Info-menu' (`m' in Info) - Trip among Info nodes</span>
<span class="linecomment">;;  * `icicle-locate-file'             - Trip among files</span>
<span class="linecomment">;;  * `icicle-occur' (`C-c '')         - Trip among `occur' hits</span>
<span class="linecomment">;;                                       (`icicle-search' among</span>
<span class="linecomment">;;                                       single-line hits)</span>
<span class="linecomment">;;  * `icicle-recent-file'             - Trip among recent files</span>
<span class="linecomment">;;  * `icicle-search' (`C-c `')        - Trip among regexp search hits</span>
<span class="linecomment">;;  * `icicle-search-bookmarks-together' (`C-u C-c `'),</span>
<span class="linecomment">;;    `icicle-search-bookmark',        - Search multiple bookmarks</span>
<span class="linecomment">;;  * Type-specific bookmark searches</span>
<span class="linecomment">;;    `icicle-search-bookmark-list-bookmark' - Search bookmark lists</span>
<span class="linecomment">;;    `icicle-search-dired-bookmark'   - Search Dired bookmarks</span>
<span class="linecomment">;;    `icicle-search-file-bookmark'    - Search file bookmarks</span>
<span class="linecomment">;;    `icicle-search-gnus-bookmark'    - Search Gnus bookmarks</span>
<span class="linecomment">;;    `icicle-search-info-bookmark'    - Search Info bookmarks</span>
<span class="linecomment">;;    `icicle-search-local-file-bookmark'- Search local-file bookmarks</span>
<span class="linecomment">;;    `icicle-search-man-bookmark'     - Search `man'-page bookmarks</span>
<span class="linecomment">;;    `icicle-search-non-file-bookmark' - Search non-file bookmarks</span>
<span class="linecomment">;;    `icicle-search-region-bookmark'  - Search bookmarked regions</span>
<span class="linecomment">;;    `icicle-search-remote-file-bookmark' - Search remote bookmarks</span>
<span class="linecomment">;;    `icicle-search-url-bookmark'     - Search URL bookmarks</span>
<span class="linecomment">;;  * `icicle-search-char-property'    - Trip among buffer strings with</span>
<span class="linecomment">;;                                       with a text/overlay property</span>
<span class="linecomment">;;  * `icicle-search-dired-marked'     - Search marked files in Dired</span>
<span class="linecomment">;;  * `icicle-search-file'             - Search multiple files</span>
<span class="linecomment">;;  * `icicle-search-ibuffer-marked'   - Search marked bufs in Ibuffer</span>
<span class="linecomment">;;  * `icicle-search-keywords' (`C-c ^') - Trip among keyword search</span>
<span class="linecomment">;;                                       hits.</span>
<span class="linecomment">;;  * `icicle-search-overlay-property' - Trip among buffer strings</span>
<span class="linecomment">;;    with some overlay property.</span>
<span class="linecomment">;;  * `icicle-search-pages'            - Search Emacs pages</span>
<span class="linecomment">;;  * `icicle-search-paragraphs'       - Search Emacs paragraphs</span>
<span class="linecomment">;;  * `icicle-search-sentences'        - Search sentences as contexts</span>
<span class="linecomment">;;  * `icicle-search-text-property' (`C-c "') - Trip among buffer</span>
<span class="linecomment">;;                                       strings with a text property</span>
<span class="linecomment">;;  * `icicle-search-thing'            - Search thing-at-point things</span>
<span class="linecomment">;;  * `icicle-search-word' (`C-c $')   - Trip among word-search hits</span>
<span class="linecomment">;;  * `icicle-search-xml-element'      - Trip among XML elements</span>
<span class="linecomment">;;  * `icicle-select-frame' (`C-x 5 o') - Trip among frames, by name</span>
<span class="linecomment">;;  * `icicle-select-window' (`C-0 C-x o') - Trip among windows, by</span>
<span class="linecomment">;;                                       buffer name</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Highlighting the Destination")</span>
<span class="linecomment">;;  ** Highlighting the Destination **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-bookmark-region-other-window' activates the bookmarked</span>
<span class="linecomment">;;  region (highlighting it) when you visit it, if you use Transient</span>
<span class="linecomment">;;  Mark mode (or, e.g., Delete Selection mode).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Starting with Emacs 22, most Icicles commands that have single</span>
<span class="linecomment">;;  positions as their trip visits (e.g. `icicle-bookmark',</span>
<span class="linecomment">;;  `icicle-Info-goto-node', `icicle-goto-marker', `icicle-find-tag')</span>
<span class="linecomment">;;  highlight those positions temporarily as they are visited.  Except</span>
<span class="linecomment">;;  for the Icicles search commands, this highlighting is provided by</span>
<span class="linecomment">;;  library `crosshairs.el'.  If `crosshairs.el' and the libraries it</span>
<span class="linecomment">;;  requires are not in your `load-path', then no such highlighting</span>
<span class="linecomment">;;  occurs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@* "Icicles Commands that Read File Names") for information</span>
<span class="linecomment">;;    about `icicle-find-file', `icicle-find-file-absolute',</span>
<span class="linecomment">;;    `icicle-find-file-in-tags-table', `icicle-locate-file', and</span>
<span class="linecomment">;;    `icicle-recent-file'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Enhancements for Emacs Tags")</span>
<span class="linecomment">;;    for information about `icicle-find-first-tag' and</span>
<span class="linecomment">;;    `icicle-find-tag'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Bookmark Enhancements")</span>
<span class="linecomment">;;    for information about the bookmark browsing commands.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Info Enhancements")</span>
<span class="linecomment">;;    for information about `icicle-Info-goto-node',</span>
<span class="linecomment">;;    `icicle-Info-index', and `icicle-Info-menu'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    for information about `icicle-occur' and `icicle-search'.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Other Icicles Search Commands")</span>
<span class="linecomment">;;    for information about `icicle-compilation-search',</span>
<span class="linecomment">;;    `icicle-imenu', `icicle-imenu-command',</span>
<span class="linecomment">;;    `icicle-imenu-non-interactive-function',</span>
<span class="linecomment">;;    `icicle-search-char-property', `icicle-search-keywords',</span>
<span class="linecomment">;;    `icicle-search-overlay-property', and</span>
<span class="linecomment">;;    `icicle-search-text-property'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Defining Icicles Tripping Commands")</span>
<span class="linecomment">;;    for information about defining your own tripping commands.</span>
 
<span class="linecomment">;;(@* "Key Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Key Completion</span>
<span class="linecomment">;;  --------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's another weird Icicles feature: completing key sequences,</span>
<span class="linecomment">;;  instead of commands.  (This feature works only for Emacs 22 and</span>
<span class="linecomment">;;  later.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What on earth for?  Ever want to use one of those myriad `C-x' key</span>
<span class="linecomment">;;  sequences, but forget just what it was?  The standard solution to</span>
<span class="linecomment">;;  that is to use `C-x C-h', to display all of the `C-x' bindings</span>
<span class="linecomment">;;  together with their commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  OK, but then you have to scroll down the list of bindings,</span>
<span class="linecomment">;;  searching for the command you want, and then use its key binding.</span>
<span class="linecomment">;;  You can use `C-M-s' to search for a substring of the command name,</span>
<span class="linecomment">;;  in case you do not recall the exact name, but why not use Icicles</span>
<span class="linecomment">;;  completion for this?  Why not match against possible key sequences</span>
<span class="linecomment">;;  and commands?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Keys")</span>
<span class="linecomment">;;  ** Completing Keys **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To complete keys in Icicles, start the key sequence as usual, and</span>
<span class="linecomment">;;  then hit `S-TAB' (command `icicle-complete-keys').  For example,</span>
<span class="linecomment">;;  use `C-x' or `C-x 4', and then hit `S-TAB' to complete the prefix</span>
<span class="linecomment">;;  `C-x' or `C-x 4' (or whatever).  You're then completing against</span>
<span class="linecomment">;;  candidates that are composed of two parts, separated by "  =  ":</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * a key binding that completes what you've typed so far -</span>
<span class="linecomment">;;    e.g. `C-j' (that is, `C-x C-j')</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * the command it is bound to - e.g. `dired-jump-other-window'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, for example, this is a single completion candidate:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-j  =  dired-jump-other-window</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can match your minibuffer input against the key name, the</span>
<span class="linecomment">;;  command name, or both.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Suppose, for instance, that you want to use a version-control</span>
<span class="linecomment">;;  command, and you remember that all such commands are bound to key</span>
<span class="linecomment">;;  sequences that begin with `C-x v'.  You enter as much of the key</span>
<span class="linecomment">;;  sequence as you remember (`C-x v'), and then you hit `S-TAB'.  You</span>
<span class="linecomment">;;  can then use completion (either apropos or prefix) against the</span>
<span class="linecomment">;;  matching key sequences and command names to invoke the right</span>
<span class="linecomment">;;  command.  And, as a bonus, you are reminded of its key sequence.</span>
<span class="linecomment">;;  You can thus use Icicles key completion to execute a command and,</span>
<span class="linecomment">;;  at the same time, learn its key binding.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs key</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option `icicle-key-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`S-TAB' Is Everywhere - Start With It")</span>
<span class="linecomment">;;  ** `S-TAB' Is Everywhere - Start With It **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicle mode, whenever you are not in the minibuffer or buffer</span>
<span class="linecomment">;;  `*Completions*', key `S-TAB' initiates key completion.  That is,</span>
<span class="linecomment">;;  you do not need to first type part of a key sequence to use it -</span>
<span class="linecomment">;;  you can start with it.  Hit `S-TAB' at any time, and you're</span>
<span class="linecomment">;;  completing a key sequence, even if you have not yet hit any keys.</span>
<span class="linecomment">;;  This lets you see all key sequences that are available in a given</span>
<span class="linecomment">;;  context.  For example, in Dired, keys special to that mode are</span>
<span class="linecomment">;;  included (and are highlighted as local bindings -</span>
<span class="linecomment">;;  see (@&gt; "Local Bindings Are Highlighted")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When completing a key sequence, you can type part of a command</span>
<span class="linecomment">;;  name, then hit `S-TAB' to apropos-complete against the command</span>
<span class="linecomment">;;  name.  In this respect, `S-TAB' acts like `M-x', but the key</span>
<span class="linecomment">;;  binding is also part of the completion candidate, so you can also</span>
<span class="linecomment">;;  match key names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Keys By Name")</span>
<span class="linecomment">;;  ** Completing Keys By Name **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, just how do you complete input against a set of</span>
<span class="linecomment">;;  binding-plus-command completion candidates?  You can always cycle</span>
<span class="linecomment">;;  among the candidates, of course, and then choose one.  But what</span>
<span class="linecomment">;;  about completion?  Just type text to match candidates, then use</span>
<span class="linecomment">;;  `S-TAB' or `TAB' as usual to complete the text.  Text?  Yes.</span>
<span class="linecomment">;;  Completion candidates are always, ultimately, strings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Suppose that you type `C-x S-TAB' to show all key sequences that</span>
<span class="linecomment">;;  begin with `C-x'.  You might see a candidate that looks like this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-q  =  toggle-read-only</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can then type "C-q" or "d-onl" or any other substring, and</span>
<span class="linecomment">;;  then use `S-TAB' to complete the candidate.  (This second use of</span>
<span class="linecomment">;;  `S-TAB' invokes the command `icicle-apropos-complete', which has</span>
<span class="linecomment">;;  nothing to do with `icicle-complete-keys', which was invoked by</span>
<span class="linecomment">;;  the first `S-TAB'.  The first was invoked outside the minibuffer;</span>
<span class="linecomment">;;  the second was invoked from the minibuffer, during completion.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Prefix Keys")</span>
<span class="linecomment">;;  ** Completing Prefix Keys **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What happens if the completion candidate is itself a prefix key?</span>
<span class="linecomment">;;  For example, `C-x S-TAB' shows some candidates whose commands are</span>
<span class="linecomment">;;  shown as "...", like this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    4  =  ...      5  =  ...</span>
<span class="linecomment">;;    6  =  ...      C-k  =  ...</span>
<span class="linecomment">;;    ESC  =  ...    RET  =  ...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These represent prefix keys (`C-x 4', `C-x C-k', and so on).  If</span>
<span class="linecomment">;;  you choose such a candidate, then you just continue completing -</span>
<span class="linecomment">;;  buffer `*Completions*' is updated to show the completions of the</span>
<span class="linecomment">;;  compound prefix: `C-x 4', `C-x RET', or whichever you choose.  The</span>
<span class="linecomment">;;  minibuffer prompt shows the completion so far; if you choose</span>
<span class="linecomment">;;  `RET', for instance, then it shows `C-x RET' while prompting you</span>
<span class="linecomment">;;  for the rest of the key sequence.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, completion candidates are sorted in buffer</span>
<span class="linecomment">;;  `*Completions*' with local bindings listed first.  You can use</span>
<span class="linecomment">;;  `C-M-,' at any time during key completion to toggle between this</span>
<span class="linecomment">;;  order and sorting with the prefix-key candidates shown first.  You</span>
<span class="linecomment">;;  can use `C-,' at any time to change the sort order among these two</span>
<span class="linecomment">;;  orders and sorting by command name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Gotcha: Commands that are remapped do not show up with the</span>
<span class="linecomment">;;  bindings you think they have.  For example, `C-x C-f' is bound to</span>
<span class="linecomment">;;  `icicle-file' in Icicle mode, by default, but `C-x S-TAB' does not</span>
<span class="linecomment">;;  include the completion candidate `C-f = icicle-file'.  Instead,</span>
<span class="linecomment">;;  `S-TAB' at the top level (without first doing `C-x') shows a</span>
<span class="linecomment">;;  (pseudo) prefix key `remap = ..', and if you follow that then</span>
<span class="linecomment">;;  you'll see the candidate `find-file = icicle-file'.  The binding</span>
<span class="linecomment">;;  of `C-x C-f' does not appear as such, because `find-file' is</span>
<span class="linecomment">;;  remapped to command `icicle-file': whatever `find-file' was bound</span>
<span class="linecomment">;;  to is indirectly bound to `icicle-file'. This indirection shows up</span>
<span class="linecomment">;;  in Icicles key completion as (pseudo) prefix key `remap = ..'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Meta Key Bindings")</span>
<span class="linecomment">;;  ** Meta Key Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `S-TAB' at the top level, and you look for the key</span>
<span class="linecomment">;;  sequence `M-x' or `M-d', you will not find it.  Meta key bindings</span>
<span class="linecomment">;;  are there, but many of them are disguised as keys in the `ESC'</span>
<span class="linecomment">;;  prefix keymap - e.g. `ESC x' for `M-x'.  That is, you must first</span>
<span class="linecomment">;;  choose the `ESC` prefix key: `ESC = ...', and then choose the `x'</span>
<span class="linecomment">;;  key or whatever.  That's just the way Emacs works.  So, yes, you</span>
<span class="linecomment">;;  can use Icicles key completion to execute any Emacs command, even</span>
<span class="linecomment">;;  one that is not bound to a key sequence, and you can use it to</span>
<span class="linecomment">;;  evaluate any EmacsLisp expression.  See (@&gt; "Three-Key Emacs").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Navigate the Key-Binding Hierarchy")</span>
<span class="linecomment">;;  ** Navigate the Key-Binding Hierarchy **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Choosing a completion candidate such as `C-x  =  ...' effectively</span>
<span class="linecomment">;;  navigates down the key-binding hierachy (prefix-key hierarchy), to</span>
<span class="linecomment">;;  complete against all keys with prefix `C-x'.  Choosing `5  =  ...'</span>
<span class="linecomment">;;  to complete the prefix `C-x' then navigates down another level, to</span>
<span class="linecomment">;;  complete keys that have prefix `C-x 5'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What about navigating back up the hierarchy, say from the `C-x 5'</span>
<span class="linecomment">;;  keys to the `C-x' keys, or from the `C-x' keys to the keys with no</span>
<span class="linecomment">;;  prefix?  The special completion candidate `..' does that.  By</span>
<span class="linecomment">;;  default, it is always the first candidate in the `*Completions*'</span>
<span class="linecomment">;;  list.  It is of course not available unless you are completing a</span>
<span class="linecomment">;;  prefix; that is, it is not available at the top level.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This feature means that you can navigate the key-binding hierachy</span>
<span class="linecomment">;;  just as you would navigate the file-system hierarchy (using, say,</span>
<span class="linecomment">;;  `C-x C-f') or the menu-bar hierarchy (using library `lacarte.el').</span>
<span class="linecomment">;;  (In fact, since menu-bar bindings are also key bindings, you can</span>
<span class="linecomment">;;  also use key completion to navigate the menu-bar hierarchy - just</span>
<span class="linecomment">;;  complete the prefix key `menu-bar'!  Start with `S-TAB', choose</span>
<span class="linecomment">;;  `menu-bar  =  ...', then choose a menu, and so on.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles key completion thus provides a general browser for key</span>
<span class="linecomment">;;  bindings, which you can also use to learn about keys and their</span>
<span class="linecomment">;;  associated comands, without necessarily executing them - see</span>
<span class="linecomment">;;  (@&gt; "Key and Command Help").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Gotcha: `S-TAB' uses apropos completion, by default, so remember</span>
<span class="linecomment">;;  that typing `.' matches any character (except a newline).  To</span>
<span class="linecomment">;;  match only the literal string `..' (to go up a level), do one of</span>
<span class="linecomment">;;  the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Turn on escaping of regexp special characters - use `C-`' in the</span>
<span class="linecomment">;;    minibuffer to toggle this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Use prefix completion (`TAB').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Escape the regexp special character explicitly: `\.\.' (or use</span>
<span class="linecomment">;;    `^\.').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Cycle to candidate `..'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Local Bindings Are Highlighted")</span>
<span class="linecomment">;;  ** Local Bindings Are Highlighted **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes it helps to know which key sequences are local bindings,</span>
<span class="linecomment">;;  that is, bindings that are specific to the current mode.  For</span>
<span class="linecomment">;;  example, Dired mode defines keys specific to Dired buffer, such as</span>
<span class="linecomment">;;  `* %', `% g', and `!'.  To help you distinguish local key bindings</span>
<span class="linecomment">;;  from others (global and minor-mode bindings), local bindings are</span>
<span class="linecomment">;;  highlighted in buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-special-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Keys By Just Hitting Them")</span>
<span class="linecomment">;;  ** Completing Keys By Just Hitting Them **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It may seem odd that you must complete a key sequence by entering</span>
<span class="linecomment">;;  the names of keys, rather than just hitting the keys themselves:</span>
<span class="linecomment">;;  e.g. typing "C-f" rather than hitting `C-f'.  However, if keys</span>
<span class="linecomment">;;  themselves were used for completing, then they could not be used</span>
<span class="linecomment">;;  normally during key-sequence completion.  You could not move the</span>
<span class="linecomment">;;  cursor around the minibuffer using `C-f' or `right' (right arrow),</span>
<span class="linecomment">;;  because those keys would be treated as input for completion.  You</span>
<span class="linecomment">;;  could not use `up' or `down' to cycle among completion candidates</span>
<span class="linecomment">;;  for the same reason.  Likewise, you could not use printing</span>
<span class="linecomment">;;  (self-inserting) keys, such as `a' and `$', to match command</span>
<span class="linecomment">;;  names.  Having to use key names, instead of keys, for completion</span>
<span class="linecomment">;;  is a small price to pay for being able to complete key sequences.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nevertheless, Icicles also provides a way for you to type key</span>
<span class="linecomment">;;  sequences directly, even if it is something of a workaround:</span>
<span class="linecomment">;;  precede each key with `M-q' (`icicle-insert-key-description',</span>
<span class="linecomment">;;  during key completion) - think of `q' for "quote".  This inserts</span>
<span class="linecomment">;;  the key description of whatever key you hit next.  This key</span>
<span class="linecomment">;;  description (name) can be used to match key-completion candidates.</span>
<span class="linecomment">;;  So, for example, instead of typing "C-f", you can hit `M-q' and</span>
<span class="linecomment">;;  then hit `C-f'.  The key description "C-f" is inserted in the</span>
<span class="linecomment">;;  minibuffer.  If you use `M-q C-M-right', then "C-M-right" is</span>
<span class="linecomment">;;  inserted.  Try it: `S-TAB M-q C-M-right' -&gt; "C-M-right".  Then hit</span>
<span class="linecomment">;;  `TAB' or `S-TAB' to complete the candidate all the way to this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-M-right  =  enlarge-frame-horizontally</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Whether or not angle brackets are used is governed by user</span>
<span class="linecomment">;;  option `icicle-key-descriptions-use-&lt;&gt;-flag'.  By default, this is</span>
<span class="linecomment">;;  `nil', so angle brackets are not used, which I think improves</span>
<span class="linecomment">;;  readability.  If you set this to non-`nil', then you will see</span>
<span class="linecomment">;;  "&lt;C-M-right&gt;" instead of "C-M-right", both as a completion</span>
<span class="linecomment">;;  candidate and as what is inserted when you use `M-q'.  You can</span>
<span class="linecomment">;;  also provide a prefix argument to `M-q' to flip the behavior of</span>
<span class="linecomment">;;  `icicle-key-descriptions-use-&lt;&gt;-flag' for that occurrence only.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Key and Command Help")</span>
<span class="linecomment">;;  ** Key and Command Help **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That points out another use of key completion, opposite to</span>
<span class="linecomment">;;  learning the bindings of commands: learning the commands bound to</span>
<span class="linecomment">;;  given keys.  In other words, `S-TAB M-q' does both what `C-h w'</span>
<span class="linecomment">;;  (`where-is') does and what `C-h c' (`describe-key-briefly') does.</span>
<span class="linecomment">;;  It also does what `C-h b' (`describe-bindings') does.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The point here is not that `S-TAB M-q' is quicker than `C-h w' or</span>
<span class="linecomment">;;  `C-h c' or `C-h b' - it's not.  The point is that key completion</span>
<span class="linecomment">;;  can be handy in several ways, and it can teach you various things</span>
<span class="linecomment">;;  about keys and commands as you use it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to this key-completion help about bindings, you can</span>
<span class="linecomment">;;  display help on the commands that are the right sides of the</span>
<span class="linecomment">;;  `S-TAB' completion-candidate equations, by using the multi-command</span>
<span class="linecomment">;;  help keys (see (@&gt; "Help on Completion Candidates")).  That is,</span>
<span class="linecomment">;;  while completing, you can use `C-M-mouse-2', `C-M-RET',</span>
<span class="linecomment">;;  `C-M-next', and so on to describe the command named in the current</span>
<span class="linecomment">;;  completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`S-TAB' Is a Multi-Command")</span>
<span class="linecomment">;;  ** `S-TAB' Is a Multi-Command **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Yes, `S-TAB' as `icicle-complete-keys' is a multi-command - see</span>
<span class="linecomment">;;  (@&gt; "Multi-Commands")).  This means that you can, within the same</span>
<span class="linecomment">;;  execution of `S-TAB', invoke any number of keys by clicking</span>
<span class="linecomment">;;  (`C-mouse-2') their names in buffer `*Completions*' or choosing</span>
<span class="linecomment">;;  them any other way (`C-RET', `C-next', and so on).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Since you can navigate up and down the key-binding hierarchy, you</span>
<span class="linecomment">;;  could even stay within a single `S-TAB' invocation to do nearly</span>
<span class="linecomment">;;  everything you want in Emacs (see (@&gt; "Three-Key Emacs"))!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Possible Source of Confusion")</span>
<span class="linecomment">;;  ** Possible Source of Confusion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keep in mind that `S-TAB' has two different uses in Icicles when</span>
<span class="linecomment">;;  you are providing input in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If input completion is available, then `S-TAB' performs apropos</span>
<span class="linecomment">;;    completion (it is, in effect, bound to</span>
<span class="linecomment">;;    `icicle-apropos-complete').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If input completion is not available, then `S-TAB' performs key</span>
<span class="linecomment">;;    completion (it is, in effect, bound to `icicle-complete-keys').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, in buffer `*Completions*' `S-TAB' moves backward</span>
<span class="linecomment">;;  among the candidate completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is by design; it takes advantage of the fact that these</span>
<span class="linecomment">;;  contexts are mutually exclusive.  However, this economy comes at a</span>
<span class="linecomment">;;  risk of potential confusion.  It's important that you know whether</span>
<span class="linecomment">;;  or not completion is available when you are inputting text.  If</span>
<span class="linecomment">;;  input completion is not available, but you think it is, then</span>
<span class="linecomment">;;  hitting `S-TAB' might give you a surprise by key completing.  That</span>
<span class="linecomment">;;  behavior is normal - you can use key-completion to input special</span>
<span class="linecomment">;;  characters, for instance.  But if you think that you are instead</span>
<span class="linecomment">;;  completing the original input requested, then you can become</span>
<span class="linecomment">;;  confused.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides completion status indicators so that you can</span>
<span class="linecomment">;;  easily tell when completion is available for minibuffer input.</span>
<span class="linecomment">;;  There are two indicators: (1) at the beginning of the minibuffer</span>
<span class="linecomment">;;  prompt and (2) in the `Icy' minor-mode lighter in the mode line.</span>
<span class="linecomment">;;  See (@&gt; "Completion Status Indicators").  If completion is not</span>
<span class="linecomment">;;  indicated when you are prompted for input, it means that `S-TAB'</span>
<span class="linecomment">;;  is available, not for input completion, but for key completion.</span>
<span class="linecomment">;;  Another clue can be found in the prompt text.  For key completion,</span>
<span class="linecomment">;;  it says "Complete keys: ".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you nevertheless find the overloaded use of `S-TAB' confusing,</span>
<span class="linecomment">;;  you can change the bindings of the key `S-TAB' in these different</span>
<span class="linecomment">;;  contexts.  To do that, you can customize options</span>
<span class="linecomment">;;  `icicle-apropos-complete-keys', `icicle-key-complete-keys', and</span>
<span class="linecomment">;;  `icicle-previous-candidate-keys'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Three-Key Emacs")</span>
<span class="linecomment">;;  ** Three-Key Emacs **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles key completion piles a lot of stuff into `S-TAB'.  Just as</span>
<span class="linecomment">;;  `M-x' lets you execute any Emacs command, so does `S-TAB'.  But</span>
<span class="linecomment">;;  `S-TAB' also lets you insert characters.  With the exception of</span>
<span class="linecomment">;;  inserting multi-byte characters, you might say that it gives you</span>
<span class="linecomment">;;  all of Emacs in one key binding.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, you need a couple other keys, as well.  How many?</span>
<span class="linecomment">;;  Suppose you had limited accessibility in terms of input devices.</span>
<span class="linecomment">;;  Maybe you use Emacs on a cell phone, without voice recognition -</span>
<span class="linecomment">;;  or whatever.  How many keys, buttons, or whatnot do you need to</span>
<span class="linecomment">;;  use Emacs?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. You need one for `C-g', to interrupt commands.</span>
<span class="linecomment">;;  2. You need one to start telling Emacs what to do.</span>
<span class="linecomment">;;  3. You might need one to choose from a set of possible things to</span>
<span class="linecomment">;;     do.</span>
<span class="linecomment">;;  4. You need one to tell Emacs that you're done telling it what to</span>
<span class="linecomment">;;     do.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (#2 and #3 might be combined somehow.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What does vanilla Emacs offer out of the box in this regard?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can get by with just `mouse-1' and the menu-bar menus, but</span>
<span class="linecomment">;;    they do not cover all of Emacs.  You cannot use them to enter</span>
<span class="linecomment">;;    text, for instance.  Of course, you could add more menus, to be</span>
<span class="linecomment">;;    able to do more.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `M-x' plus `RET' to execute any command.  But how</span>
<span class="linecomment">;;    would you insert text?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Similarly, for `M-:', which lets you evaluate any Emacs-Lisp</span>
<span class="linecomment">;;    sexp.  You still need a way to type characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles key completion lets you do almost anything in Emacs with</span>
<span class="linecomment">;;  three or four keys, buttons, or whatever:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `S-TAB' - Offers every key sequence as a possible choice to</span>
<span class="linecomment">;;              execute.</span>
<span class="linecomment">;;  * `next'  - Cycles among candidates, for choosing.</span>
<span class="linecomment">;;  * `RET'   - Chooses the current candidate.</span>
<span class="linecomment">;;  * And of course `C-g', to cancel the current operation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `S-TAB' includes key `M-x (represented as prefix key `ESC'</span>
<span class="linecomment">;;  followed by `x'), which offers all commands (even those not bound)</span>
<span class="linecomment">;;  as possible choices.  It also includes key `M-:' (`ESC' followed</span>
<span class="linecomment">;;  by `:'), which lets you execute any Emacs-Lisp expression.  That's</span>
<span class="linecomment">;;  almost all of Emacs!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You could even perhaps get away with only three mouse buttons, and</span>
<span class="linecomment">;;  no keyboard:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `mouse-1' - Choose candidates, scroll, and so on (direct access,</span>
<span class="linecomment">;;    no cycling).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `mouse-2' - Do what `S-TAB' does (bind it to</span>
<span class="linecomment">;;    `icicle-complete-keys' and `icicle-apropos-complete').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `mouse-3' - Do what `C-g' does (bind it to `keyboard-quit' and</span>
<span class="linecomment">;;    `icicle-abort-recursive-edit').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here, `mouse-2' and `mouse-3' are not even used as mouse (pointer)</span>
<span class="linecomment">;;  functions; any keys or buttons would do.  You could use just</span>
<span class="linecomment">;;  `mouse-1' plus a Shift key and a Control key.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Would you want to use Emacs only this way?  Of course not, if you</span>
<span class="linecomment">;;  had a choice.  Typing the character `a' by cycling through every</span>
<span class="linecomment">;;  possible key binding/command combination and hitting `RET' when</span>
<span class="linecomment">;;  you get to `a  =  self-insert-command' would be the epitome of</span>
<span class="linecomment">;;  tedium.  Likewise, doing everything with a single pointer-device</span>
<span class="linecomment">;;  button.  Using only three or four keys or buttons is definitely</span>
<span class="linecomment">;;  not the ideal way to take advantage of Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But you are probably not limited to just 3 or 4 keys or buttons.</span>
<span class="linecomment">;;  The real point here is that Icicles `S-TAB' opens the door to</span>
<span class="linecomment">;;  almost everything in Emacs.  And if you do have a normal keyboard,</span>
<span class="linecomment">;;  then you can type letters and such to match command names and key</span>
<span class="linecomment">;;  sequences.  Key `next' matches substrings (regexps, actually),</span>
<span class="linecomment">;;  which makes choice even quicker.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Why only "almost" everything in Emacs?  Because you cannot use</span>
<span class="linecomment">;;  Icicles `S-TAB' to input multi-byte characters (e.g. Chinese,</span>
<span class="linecomment">;;  Japanese, Unicode).  Such characters are grouped in Emacs into</span>
<span class="linecomment">;;  character groups called "generic characters", and it is the</span>
<span class="linecomment">;;  generic characters, not the individual multi-byte characters that</span>
<span class="linecomment">;;  are bound to `self-insert-command'.  Icicles excludes these</span>
<span class="linecomment">;;  special key bindings, because you cannot simply execute</span>
<span class="linecomment">;;  `self-insert-command' to insert these characters.  (It is possible</span>
<span class="linecomment">;;  to implement a completion extension to input such characters, but</span>
<span class="linecomment">;;  that feature has not yet been implemented in Icicles.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Enjoy!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Entering Special and Foreign Characters")</span>
<span class="linecomment">;;  ** Entering Special and Foreign Characters **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `self-insert-command' is bound to each key that is</span>
<span class="linecomment">;;  associated with a character that can be inserted in text.  It is</span>
<span class="linecomment">;;  the binding of the key `a' and the key `$'.  It is also the</span>
<span class="linecomment">;;  binding of keys that your keyboard might not even have - keys that</span>
<span class="linecomment">;;  correspond to special or odd characters and characters in other</span>
<span class="linecomment">;;  languages.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To Icicles key completion, these keys are like any other keys, and</span>
<span class="linecomment">;;  `self-insert-command' is like any other command.  However, because</span>
<span class="linecomment">;;  there are many, many keys bound to it, it can be distracting to</span>
<span class="linecomment">;;  allow such keys as completion candidates.  If option</span>
<span class="linecomment">;;  `icicle-complete-keys-self-insert-flag' is `nil' (the default</span>
<span class="linecomment">;;  value), then such keys are excluded as candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If it is non-`nil', then you can use key completion to insert</span>
<span class="linecomment">;;  characters that your keyboard has no keys for.  This provides a</span>
<span class="linecomment">;;  sort of universal input-method feature that works, in principle,</span>
<span class="linecomment">;;  for all characters (but see below, for exceptions).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To use this feature, just choose a character description (name)</span>
<span class="linecomment">;;  with the mouse or by cycling, if you cannot type its description</span>
<span class="linecomment">;;  (name) with your keyboard.  You can even insert characters this</span>
<span class="linecomment">;;  way that your system has no font for - they will be displayed as</span>
<span class="linecomment">;;  empty boxes, but they will be correctly inserted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There is an exception, however.  There are some characters that</span>
<span class="linecomment">;;  you cannot insert this way, because they do not have a one-to-one</span>
<span class="linecomment">;;  relation with keys that are bound to `self-insert-command'.  In</span>
<span class="linecomment">;;  such cases, "keys" are bound to `self-insert-command' that</span>
<span class="linecomment">;;  represent not single characters but groups of characters.  Icicles</span>
<span class="linecomment">;;  filters out these keys, so they are not available as completion</span>
<span class="linecomment">;;  candidates.  The problematic keys are in Korean, Chinese,</span>
<span class="linecomment">;;  Japanese, Ethiopic, Indian, Tibetan, and some Unicode character</span>
<span class="linecomment">;;  sets.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because insertion of special characters is useful, but is a</span>
<span class="linecomment">;;  special case of key completion, there is a separate Icicles</span>
<span class="linecomment">;;  command that you can use just for that: `icicle-insert-char'.  It</span>
<span class="linecomment">;;  is a specialized version of `icicle-complete-keys' that uses</span>
<span class="linecomment">;;  `self-insert-command' as the only possible command for completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Handling Keymaps That Are Inaccessible From the Global Map")</span>
<span class="linecomment">;;  ** Handling Keymaps That Are Inaccessible From the Global Map **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Actually, `S-TAB' is not bound to `icicle-complete-keys' in every</span>
<span class="linecomment">;;  keymap.  That would be inconvenient, in general.  By default, it</span>
<span class="linecomment">;;  is so bound in each keymap that is accessible from the global</span>
<span class="linecomment">;;  keymap, as determined by function `accessible-keymaps'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You've seen, above, how you can navigate through prefix keys,</span>
<span class="linecomment">;;  starting with the global map.  In Dired, for instance, you can use</span>
<span class="linecomment">;;  `S-TAB' at the top level, then choose the prefix key `*' in</span>
<span class="linecomment">;;  `*Completions*', then choose a key, such as `/' (to mark</span>
<span class="linecomment">;;  directories), in the `*' keymap.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, the act of binding of `S-TAB' in keymaps that are</span>
<span class="linecomment">;;  accessible from the global map does not bind it in the `*' prefix</span>
<span class="linecomment">;;  keymap itself.  To handle this case, Icicles explicitly does for</span>
<span class="linecomment">;;  `dired-mode-map' what it does for the global map: it binds `S-TAB'</span>
<span class="linecomment">;;  in each keymap that is accessible from `dired-mode-map'.  Because</span>
<span class="linecomment">;;  of this, you can use `* S-TAB' to show all key completions of `*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This treatment of `dired-mode-map' is done by default.  Similarly</span>
<span class="linecomment">;;  for a few other keymaps.  But you might have other keymaps that</span>
<span class="linecomment">;;  you would like to treat similarly - keymaps that Icicles might be</span>
<span class="linecomment">;;  unaware of.  You do this by including them in the list value of</span>
<span class="linecomment">;;  user option `icicle-keymaps-for-key-completion', along with</span>
<span class="linecomment">;;  `dired-mode-map' and the others provided in the default value.</span>
<span class="linecomment">;;  The list entries are Emacs-Lisp symbols that are bound to keymaps,</span>
<span class="linecomment">;;  each of which should define at least one prefix key.  If you add a</span>
<span class="linecomment">;;  keymap variable to this list, then `S-TAB' will be bound so that</span>
<span class="linecomment">;;  you can use it to complete the prefix keys defined by that map.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Notice that there is no keymap variable that corresponds to prefix</span>
<span class="linecomment">;;  key `*' in Dired mode.  You need only provide a keymap (variable</span>
<span class="linecomment">;;  `dired-mode-map') from which the prefix key is accessible; it is</span>
<span class="linecomment">;;  not necessary to also provide a variable that corresponds to the</span>
<span class="linecomment">;;  prefix keymap itself.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If a keymap listed in `icicle-keymaps-for-key-completion' is not</span>
<span class="linecomment">;;  defined when Icicle mode is entered, then it is ignored.  If you</span>
<span class="linecomment">;;  later define that keymap, then just exit and reenter Icicle mode</span>
<span class="linecomment">;;  for the `S-TAB' binding to take effect.  For example, use `M-x</span>
<span class="linecomment">;;  icy-mode' twice after entering Calendar mode, to be able to</span>
<span class="linecomment">;;  complete `calendar-mode' prefix keys such as `t' - `t S-TAB'.</span>
 
<span class="linecomment">;;(@* "Icicles Multi `M-x'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Multi `M-x'</span>
<span class="linecomment">;;  -------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  How about a multi-command replacement for `M-x'?  Instead of</span>
<span class="linecomment">;;  executing a single command, it would execute any number of</span>
<span class="linecomment">;;  commands.  This section describes two such multi-commands,</span>
<span class="linecomment">;;  `icicle-execute-extended-command' and `icicle-command-abbrev',</span>
<span class="linecomment">;;  which by default are bound in Icicle mode to `M-x' and `C-x SPC',</span>
<span class="linecomment">;;  respectively.  See Also:</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Defining Icicles Multi `M-x'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi `M-x': `icicle-execute-extended-command'")</span>
<span class="linecomment">;;  ** Multi `M-x': `icicle-execute-extended-command' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `M-x' in vanilla Emacs, you are actually executing</span>
<span class="linecomment">;;  the standard Emacs command `execute-extended-command'.  That</span>
<span class="linecomment">;;  command prompts you for the name of another command, which you</span>
<span class="linecomment">;;  input.  It uses `completing-read' to do this, which is why you can</span>
<span class="linecomment">;;  take advantage of Icicles features when you use `M-x'.  Nothing</span>
<span class="linecomment">;;  new here.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-execute-extended-command' is simply a</span>
<span class="linecomment">;;  multi-command version of `execute-extended-command'.  It does the</span>
<span class="linecomment">;;  same thing, except that it also lets you execute multiple</span>
<span class="linecomment">;;  commands, one by one, using `C-RET' (or `C-next' and so on),</span>
<span class="linecomment">;;  without ever exiting the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With the default value of option `icicle-top-level-key-bindings',</span>
<span class="linecomment">;;  `M-x' is bound to `icicle-execute-extended-command' whenever you</span>
<span class="linecomment">;;  are in Icicle mode.  If you never use it as a multi-command, you</span>
<span class="linecomment">;;  will not notice any difference from `execute-extended-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Examples of Using Multi `M-x'")</span>
<span class="linecomment">;;  *** Examples of Using Multi `M-x' ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Example: Repeat a command multiple times.  Yes, `C-x z' does this</span>
<span class="linecomment">;;  already (and better) - this is just an illustration.  `M-x</span>
<span class="linecomment">;;  forward-ch TAB' completes to `forward-char'.  Then, use `C-RET' to</span>
<span class="linecomment">;;  execute that command.  Repeat as many times as you want.  Use a</span>
<span class="linecomment">;;  prefix arg if you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To switch to another command in the same `M-x' invocation: Erase</span>
<span class="linecomment">;;  the minibuffer (`M-k'), complete the second command, then use</span>
<span class="linecomment">;;  `C-RET'.  As long as you have not yet used `RET', `S-RET', `C-g'</span>
<span class="linecomment">;;  (or, say, `C-]'), you remain within the same invocation of `M-x'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What about executing a command that, itself, reads an input</span>
<span class="linecomment">;;  argument?  That's OK.  And if that command reads its input with</span>
<span class="linecomment">;;  completion, then you can use `C-RET' on the completion candidates</span>
<span class="linecomment">;;  for that input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Example: `M-x describe-fa TAB C-RET' gives you the prompt for</span>
<span class="linecomment">;;  command `describe-face'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Type `ici S-TAB' to see the available Icicles faces.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Hit `next' until face `icicle-complete-input' is highlighted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Hit `C-RET' to display its documentation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Type `C-next' a few times to see the doc of other Icicles</span>
<span class="linecomment">;;     faces.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Use `M-k' to erase the minibuffer, then type `search S-TAB' to</span>
<span class="linecomment">;;     see faces about searching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. Cycle through them with `next', then use `C-RET' on</span>
<span class="linecomment">;;     `icicle-search-main-regexp-current' to show its documentation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7. Use `C-next' to do the same for face</span>
<span class="linecomment">;;     `icicle-search-main-regexp-others'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  8. Use `RET' to finish with command `describe-face' - but you're</span>
<span class="linecomment">;;     still in the same invocation of `M-x'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  9. Change the input to `describe-coding-system' and play again,</span>
<span class="linecomment">;;     this time with coding-system names...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Remember, if you get confused or lost: `C-]'</span>
<span class="linecomment">;;  (`abort-recursive-edit') or `M-x top-level' should always</span>
<span class="linecomment">;;  straighten you out.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "What about describe-variable and describe-function?")</span>
<span class="linecomment">;;  *** What about describe-variable and describe-function? ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sadly, if you try the last example with `describe-variable' or</span>
<span class="linecomment">;;  `describe-function', you might be in for a surprise.  In Emacs 20,</span>
<span class="linecomment">;;  they both work fine.  In later Emacs versions, `describe-variable'</span>
<span class="linecomment">;;  gives you the message "You did not specify a variable", and</span>
<span class="linecomment">;;  `describe-function' displays a `*Help*' buffer that says that each</span>
<span class="linecomment">;;  function you choose is really a keyboard macro!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Why?  It's a bit complex, but worth hearing about if you want to</span>
<span class="linecomment">;;  understand multi M-x better.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you choose a command that reads an argument in the minibuffer</span>
<span class="linecomment">;;  and you then hit a multi-command key such as `C-RET' to choose an</span>
<span class="linecomment">;;  argument, Icicles tries to apply the command you chose to the</span>
<span class="linecomment">;;  argument you chose.  However, completion candidates are always</span>
<span class="linecomment">;;  strings, and the command you chose might expect something other</span>
<span class="linecomment">;;  than a string.  That is the case for `describe-variable', for</span>
<span class="linecomment">;;  instance.  The case of describe-function' is special: it</span>
<span class="linecomment">;;  interprets a string argument blindly as a keyboard macro sequence.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles is smart enough to pick up a `wrong-type-argument' error,</span>
<span class="linecomment">;;  if the command you choose barfs on a string argument.  In that</span>
<span class="linecomment">;;  case, Icicles converts the string to a symbol (or a number) and</span>
<span class="linecomment">;;  tries again, using the symbol (or the number).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And that's why `describe-variable' works in Emacs 20 but not in</span>
<span class="linecomment">;;  later versions: In Emacs 20, `describe-variable' (sanely) raises a</span>
<span class="linecomment">;;  type error if you pass it a string, and Icicles is able to save</span>
<span class="linecomment">;;  the day by then passing it the corresponding symbol.  In later</span>
<span class="linecomment">;;  versions of Emacs, however, instead of raising an error with the</span>
<span class="linecomment">;;  message "You did not specify a variable", `describe-variable' just</span>
<span class="linecomment">;;  displays the message - no error, so there is no way for Icicles to</span>
<span class="linecomment">;;  recuperate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I've reported this design misfeature to the Emacs developers, and</span>
<span class="linecomment">;;  I hope it will be fixed in a future Emacs version.  Until then, at</span>
<span class="linecomment">;;  least you know...  The more general lesson is this: Icicles can</span>
<span class="linecomment">;;  turn every command into a multi-command, but multi-command actions</span>
<span class="linecomment">;;  will not work for every command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi `M-x' Turns Every Command into a Multi-Command")</span>
<span class="linecomment">;;  *** Multi `M-x' Turns Every Command into a Multi-Command ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most of the time, of course, you do not execute commands</span>
<span class="linecomment">;;  successively by name; instead, you use key bindings.  The point</span>
<span class="linecomment">;;  here is that even if you have a binding for a command, Icicles</span>
<span class="linecomment">;;  `M-x' lets you use any command as a multi-command, which can</span>
<span class="linecomment">;;  sometimes be advantageous.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, Icicles defines and binds a real multi-command to</span>
<span class="linecomment">;;  `C-x 0' in Icicle mode, which lets you delete any number of</span>
<span class="linecomment">;;  windows.  But, even without such a multi-command, you can get a</span>
<span class="linecomment">;;  similar effect by using `M-x delete-windows-on'.  In this way, you</span>
<span class="linecomment">;;  can turn ordinary Emacs commands that use completion into</span>
<span class="linecomment">;;  multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The other point is that you can move from one command to another</span>
<span class="linecomment">;;  within the same execution of `M-x'.  This is a different feature</span>
<span class="linecomment">;;  from being able to use any command that uses completion as a</span>
<span class="linecomment">;;  multi-command.  Both features have their uses.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi `M-x' with Abbreviations: `icicle-command-abbrev'")</span>
<span class="linecomment">;;  ** Multi `M-x' with Abbreviations: `icicle-command-abbrev' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second multi-command that you can use in place of</span>
<span class="linecomment">;;  `execute-extended-command' is `icicle-command-abbrev', bound in</span>
<span class="linecomment">;;  Icicle mode to `C-x SPC'.  It is similar to `M-x'</span>
<span class="linecomment">;;  (`icicle-execute-extended-command'), with the added twist that it</span>
<span class="linecomment">;;  lets you input command abbreviations, as well as commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If option `icicle-add-proxy-candidates-flag' is non-`nil', then</span>
<span class="linecomment">;;  command abbreviations, as well as commands, are available as</span>
<span class="linecomment">;;  completion candidates.  Otherwise, only commands are available.</span>
<span class="linecomment">;;  You can toggle this user option using `C-M-_' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs partial completion and some other libraries provide ways for</span>
<span class="linecomment">;;  you to enter command abbreviations instead of command names at the</span>
<span class="linecomment">;;  command prompt (`M-x').  Library `exec-abbrev-cmd.el' by Tassilo</span>
<span class="linecomment">;;  Horn &lt;tassilo@member.fsf.org&gt; is an example.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So just what is a command abbreviation?  Hyphens (`-') in command</span>
<span class="linecomment">;;  names divide them into parts.  For example, `find-file' has two</span>
<span class="linecomment">;;  parts: `find' and `file'.  Each character of a command</span>
<span class="linecomment">;;  abbreviation corresponds to one part of each of the commands that</span>
<span class="linecomment">;;  match the abbreviation.  For example, abbreviation `ff' matches</span>
<span class="linecomment">;;  commands `find-file' and `focus-frame', and abbreviation `fg'</span>
<span class="linecomment">;;  matches `find-grep'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-command-abbrev-match-all-parts-flag' is</span>
<span class="linecomment">;;  `nil', then an abbreviation need not match all parts of a command</span>
<span class="linecomment">;;  name; it need match only a prefix.  For example, `nil' means that</span>
<span class="linecomment">;;  abbreviation `ff' also matches `find-file-other-window' and `fg'</span>
<span class="linecomment">;;  also matches `find-grep-dired'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can input both abbreviations and commands at the</span>
<span class="linecomment">;;  same prompt, and you can take advantage of the multi-command</span>
<span class="linecomment">;;  feature to execute multiple commands.  You can thus treat command</span>
<span class="linecomment">;;  abbreviations just like commands.  If an abbreviation matches a</span>
<span class="linecomment">;;  single command name, then that command is invoked immediately.  If</span>
<span class="linecomment">;;  it matches more than one, then you can use completion to choose</span>
<span class="linecomment">;;  one.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One or more, that is - multi-command completion is available for</span>
<span class="linecomment">;;  both abbreviations and commands.  That is, you can invoke any</span>
<span class="linecomment">;;  number of them within the same use of `C-x SPC'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What happens if your input matches a command name but it is also</span>
<span class="linecomment">;;  an abbreviation for other command names?  By default, command</span>
<span class="linecomment">;;  names take precedence: if your input matches a command name then</span>
<span class="linecomment">;;  that command is invoked.  So, for example, by default the command</span>
<span class="linecomment">;;  `cd' takes precedence over `cd' as an abbreviation for commands</span>
<span class="linecomment">;;  such as `compile-defun' and `cancel-debug-on-entry'.  If you</span>
<span class="linecomment">;;  instead want abbreviations to take precedence over command names,</span>
<span class="linecomment">;;  then set option `icicle-command-abbrev-priority-flag' to `t'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Abbreviations are completed against the (persistent) list of</span>
<span class="linecomment">;;  abbreviations you have used in the past.  That list is also</span>
<span class="linecomment">;;  directly customizable as option `icicle-command-abbrev-alist'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Besides completing against past abbreviations, you can enter new</span>
<span class="linecomment">;;  abbreviations (the completion is thus lax).  When you exit Emacs,</span>
<span class="linecomment">;;  your abbreviations list is updated and saved, along with the</span>
<span class="linecomment">;;  number of times you've used each abbreviation.  The latter</span>
<span class="linecomment">;;  information is used to sort your abbreviations for completion, so</span>
<span class="linecomment">;;  that those used most frequently are available first.</span>
 
<span class="linecomment">;;(@* "Choose All Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Choose All Completion Candidates</span>
<span class="linecomment">;;  --------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The previous section describes how you can use `C-RET'</span>
<span class="linecomment">;;  (`icicle-candidate-action') to choose (act on) multiple completion</span>
<span class="linecomment">;;  candidates, individually.  If you hold down the Control key while</span>
<span class="linecomment">;;  you cycle through the candidates, you can run through each of</span>
<span class="linecomment">;;  them, one by one.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-all-candidates-action', which is bound to `C-!' in</span>
<span class="linecomment">;;  the minibuffer, is a shorthand way of doing that: act on all</span>
<span class="linecomment">;;  candidates that match the current input.  In many contexts, `C-!'</span>
<span class="linecomment">;;  reports on any objects that were not acted upon successfully (in</span>
<span class="linecomment">;;  buffer `*Help*').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All multi-commands let you use `C-!' in this way.  Whenever a</span>
<span class="linecomment">;;  command defines a special action for `C-RET' to perform on the</span>
<span class="linecomment">;;  current completion candidate, you can use `C-!' to perform it on</span>
<span class="linecomment">;;  all candidates at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Perhaps you already use `% m' (command `dired-mark-files-regexp')</span>
<span class="linecomment">;;  in Dired to mark all files that match a given regular expression,</span>
<span class="linecomment">;;  and then operate on all of the marked files in some way (search</span>
<span class="linecomment">;;  with `A', query-replace with `Q', open with `F', delete with `D',</span>
<span class="linecomment">;;  and so on).  When you execute a multi-command, `C-!' lets you do</span>
<span class="linecomment">;;  something similar.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  How does it work?  It applies `icicle-candidate-action-fn' to each</span>
<span class="linecomment">;;  completion candidate that (apropos- or prefix-) matches the</span>
<span class="linecomment">;;  current input in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most top-level Icicles commands are multi-commands.  Command</span>
<span class="linecomment">;;  `icicle-delete-file' is an example.  Instead of entering a file</span>
<span class="linecomment">;;  name at the prompt (e.g. using completion or cycling), you can</span>
<span class="linecomment">;;  type a regular expression, use `S-TAB' to see all matching files,</span>
<span class="linecomment">;;  and then use `C-!' to delete all of them at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You get the idea: Use the minibuffer to determine a set of objects</span>
<span class="linecomment">;;  by pattern matching, and then act on all elements of the set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to `C-!', keys `M-!', `C-|', and `M-|' act similarly:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-!' is like `C-!', but it acts on the list of matching</span>
<span class="linecomment">;;    candidates as a whole, rather than acting individually on each</span>
<span class="linecomment">;;    candidate.  For example, with command `icicle-customize-face',</span>
<span class="linecomment">;;    `M-!' opens a single Customize buffer for all of the matching</span>
<span class="linecomment">;;    faces, while `C-!' opens a separate Customize buffer for each</span>
<span class="linecomment">;;    face.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-|' and `M-|' are like `C-!' and `M-!', respectively, but they</span>
<span class="linecomment">;;    apply an alternative action, not the main action, whenever one</span>
<span class="linecomment">;;    is available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the definition of a given multi-command, the appropriate action</span>
<span class="linecomment">;;  functions are bound to variables:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-action-fn' (`C-!') - normal single-candidate</span>
<span class="linecomment">;;    action</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-alt-action-fn' (`C-|') - alternative</span>
<span class="linecomment">;;    single-candidate action</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-all-candidates-list-action-fn' (`M-!') - normal</span>
<span class="linecomment">;;    list-of-candidates action</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-all-candidates-list-alt-action-fn' (`M-|') - alternative</span>
<span class="linecomment">;;    list-of-candidates action</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For most multi-commands, however, only the normal single-candidate</span>
<span class="linecomment">;;  action is defined.  In this case, `M-!' duplicates what `C-!'</span>
<span class="linecomment">;;  does.  If the corresponding function is not available, each of the</span>
<span class="linecomment">;;  list-action keys (`M-!', `M-|') behaves the same as the</span>
<span class="linecomment">;;  corresponding single-candidate key (`C-!', `C-|), and vice versa.</span>
<span class="linecomment">;;  So for instance, if `icicle-all-candidates-list-action-fn' is</span>
<span class="linecomment">;;  `nil' when reading some input, then `M-!' acts the same as `C-!'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, if you have saved completion candidates and they</span>
<span class="linecomment">;;  all belong to the current set of completion candidates, then `C-!'</span>
<span class="linecomment">;;  acts on the saved candidates instead of the complete set of</span>
<span class="linecomment">;;  candidates.  This means that you need not first do `C-M-&lt;' to</span>
<span class="linecomment">;;  retrieve the saved candidates; you can do `C-!' directly to act on</span>
<span class="linecomment">;;  them.  `C-|', `M-!', and `M-|' work the same way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All of the all-candidates actions inhibit candidate help display</span>
<span class="linecomment">;;  in the mode line and minibuffer messages that the individual</span>
<span class="linecomment">;;  actions might effect.  This is to avoid unnecessary delays.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    for an Icicles alternative to both `A' and `Q' (search and</span>
<span class="linecomment">;;    replace) in Dired.</span>
 
<span class="linecomment">;;(@* "Sets of Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sets of Completion Candidates</span>
<span class="linecomment">;;  -----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whereas `C-RET' acts on individual objects, `C-!'  acts on an</span>
<span class="linecomment">;;  entire set of objects at once, via their names: the set of all</span>
<span class="linecomment">;;  current completion candidates.  There are additional Icicles</span>
<span class="linecomment">;;  commands that also act, not on individual completion candidates,</span>
<span class="linecomment">;;  but on one or more sets of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One of these is `M-*', which effectively narrows the set of</span>
<span class="linecomment">;;  completion candidates by taking the intersection of the candidate</span>
<span class="linecomment">;;  sets defined by various input regexps.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section presents some more Icicles commands that act on sets</span>
<span class="linecomment">;;  of completion candidates.  The basic idea is that you can perform</span>
<span class="linecomment">;;  set operations using the current set of completion candidates,</span>
<span class="linecomment">;;  changing it into a different set.  You can, then, for example, use</span>
<span class="linecomment">;;  `C-!' to act on everything in a custom-defined set.  Or you can</span>
<span class="linecomment">;;  define a custom set that you want to use often (for example, a</span>
<span class="linecomment">;;  list of project files), save it persistently, and then retrieve it</span>
<span class="linecomment">;;  later to use for completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Saving and Retrieving Completion Candidates")</span>
<span class="linecomment">;;  ** Saving and Retrieving Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Set operations such as union and difference act on two sets.  The</span>
<span class="linecomment">;;  current set of completion candidates is always one of these sets.</span>
<span class="linecomment">;;  If an operation, such as set complement, acts on a single set,</span>
<span class="linecomment">;;  then it acts on the current set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When two sets are involved, the other set is called the "saved</span>
<span class="linecomment">;;  set".  This just means that at some previous time in your sesssion</span>
<span class="linecomment">;;  you saved some completion candidates as the value of variable</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In buffer `*Completions*', candidates that have been saved are</span>
<span class="linecomment">;;  highlighted using face `icicle-saved-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, the saved set is not persistent; it is saved only</span>
<span class="linecomment">;;  until the next save in the same Emacs session overwrites it or</span>
<span class="linecomment">;;  adds to it.  See (@&gt; "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;  for ways to save candidates persistently.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One way you can save candidates is to use</span>
<span class="linecomment">;;  `icicle-candidate-set-save', bound to `C-M-&gt;'.  This saves all of</span>
<span class="linecomment">;;  the current candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Gotcha: If you use progressive completion and you have not yet</span>
<span class="linecomment">;;          typed anything after `M-*' or `S-SPC', then there is not</span>
<span class="linecomment">;;          yet a set of candidates to save.  If you use `C-M-&gt;' at</span>
<span class="linecomment">;;          that point, you will reset the saved candidates to none.</span>
<span class="linecomment">;;          To define the current candidates, either type something or</span>
<span class="linecomment">;;          use `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way to save candidates, besides `C-M-&gt;', is to select</span>
<span class="linecomment">;;  candidates in buffer `*Completions*' using the (active) region,</span>
<span class="linecomment">;;  and then use `icicle-candidate-set-save-selected', bound to</span>
<span class="linecomment">;;  `C-M-)'.  This saves any candidates that are at least partially in</span>
<span class="linecomment">;;  the region.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also use `C-M-)' to UNsave all candidates: just select no</span>
<span class="linecomment">;;  candidates before you hit `C-M-)', to reset the set of saved</span>
<span class="linecomment">;;  completions to none.  Think of this as replacing the saved set</span>
<span class="linecomment">;;  with the empty set (no candidates).  And you need not use `TAB' or</span>
<span class="linecomment">;;  `S-TAB' first to use this, since the current set of candidates is</span>
<span class="linecomment">;;  not used in any way when you reset the saved set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-mouse-candidate-set-save', bound to `M-S-mouse-3'</span>
<span class="linecomment">;;  in `*Completions*' combines these two: if the region is active,</span>
<span class="linecomment">;;  then the selected candidates become the saved set; otherwise, all</span>
<span class="linecomment">;;  candidates are saved.  This binding makes it easy to save</span>
<span class="linecomment">;;  candidates using the mouse: select them (e.g. drag or double-click</span>
<span class="linecomment">;;  `mouse-1', or click `mouse-1' then `mouse-3'), then use</span>
<span class="linecomment">;;  `M-S-mouse-3' to save. [*]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can process the list of saved candidates in any way you like</span>
<span class="linecomment">;;  using Emacs Lisp.  For example, you can save a list of file names</span>
<span class="linecomment">;;  that match a regexp, then print the list or process the individual</span>
<span class="linecomment">;;  files in some way.  Here, for instance, is how to save the set of</span>
<span class="linecomment">;;  file names that contain either `dir' or `ici':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x C-f \(dir\|ici\) S-TAB C-M-&gt; C-g'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can retrieve a set of saved candidates with command</span>
<span class="linecomment">;;  `icicle-candidate-set-retrieve', bound to `C-M-&lt;'.  This replaces</span>
<span class="linecomment">;;  the current set of candidates with those retrieved.  It also acts</span>
<span class="linecomment">;;  like `M-*' by entering a recursive minibuffer, which removes any</span>
<span class="linecomment">;;  saved-candidates highlighting.  Using `TAB' or `S-TAB' restores</span>
<span class="linecomment">;;  the highlighting.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-&lt;' to retrieve a set of saved candidates and add</span>
<span class="linecomment">;;  them to the current candidates, instead of replacing those</span>
<span class="linecomment">;;  candidates.  This way, you can build up the current set of</span>
<span class="linecomment">;;  candidates by retrieving (combining) several saved sets.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the other direction, you can save additional candidates, adding</span>
<span class="linecomment">;;  them to a set of candidates already saved, in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-&gt;' (`icicle-candidate-set-save-more') adds all of the current</span>
<span class="linecomment">;;    candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-)' (`icicle-candidate-set-save-more-selected') adds any</span>
<span class="linecomment">;;    candidates that you have selected using the region in</span>
<span class="linecomment">;;    `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-mouse-3' (`icicle-mouse-candidate-set-save-more') acts the</span>
<span class="linecomment">;;    same as `C-)' or `C-&gt;', depending on whether or not the region</span>
<span class="linecomment">;;    is active in `*Completions*': it adds selected or all</span>
<span class="linecomment">;;    candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Extending the region with `mouse-3', and then clicking `mouse-3'</span>
<span class="linecomment">;;    again in the same place, acts the same as `C-)'.  That is, click</span>
<span class="linecomment">;;    `mouse-1', then click `mouse-3' twice in another location, to</span>
<span class="linecomment">;;    save all candidates between the `mouse-1' and `mouse-3'</span>
<span class="linecomment">;;    positions. [*]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The `insert' key (`icicle-save/unsave-candidate') adds just the</span>
<span class="linecomment">;;    current completion candidate (e.g. during cycling).  Clicking a</span>
<span class="linecomment">;;    candidate in `*Completions*' with `M-S-mouse-2'</span>
<span class="linecomment">;;    (`icicle-mouse-save/unsave-candidate') does the same thing.  If</span>
<span class="linecomment">;;    you do this to a candidate that has already been saved, then it</span>
<span class="linecomment">;;    is UNsaved (no longer saved).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that the `insert' key and `M-S-mouse-2' are toggles for a</span>
<span class="linecomment">;;  given candidate, saving or unsaving it.  In this sense each is its</span>
<span class="linecomment">;;  own opposite.  In another sense, the opposite operation of saving</span>
<span class="linecomment">;;  is simply removing a candidate from the current set of candidates.</span>
<span class="linecomment">;;  You do that using the `delete' key or `S-mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Matching, saving, and retrieving candidates is a powerful way to</span>
<span class="linecomment">;;  interact with completion.  One important use is to prepare a list</span>
<span class="linecomment">;;  of candidates on which to act, and then act on them all at once</span>
<span class="linecomment">;;  using `C-!'.  This is a good way to proceed when you want to</span>
<span class="linecomment">;;  double-check what to act on, before you actually act.  This is the</span>
<span class="linecomment">;;  same idea behind marking files in Dired and then operating on the</span>
<span class="linecomment">;;  marked files, using `x'.  It corresponds to what is represented in</span>
<span class="linecomment">;;  some user interfaces by filling out a checklist followed by</span>
<span class="linecomment">;;  clicking `OK'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  [* If you click `mouse-1' on a candidate and (starting with Emacs</span>
<span class="linecomment">;;  22) `mouse-1-click-follows-link' is an integer, then you will need</span>
<span class="linecomment">;;  to hold the mouse button depressed longer than that many seconds,</span>
<span class="linecomment">;;  or else that candidate will simply by chosen.  If the value is</span>
<span class="linecomment">;;  `t', then this will not work at all.  Any other value presents no</span>
<span class="linecomment">;;  problem.  (Personally, I use `nil'.)]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Different Places for Saving and Retrieving Candidates")</span>
<span class="linecomment">;;  ** Different Places for Saving and Retrieving Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can save completion candidates to a different variable from</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates' by using a numeric prefix</span>
<span class="linecomment">;;  argument to command `icicle-candidate-set-save'; that is, use `C-u</span>
<span class="linecomment">;;  N C-M-&gt;'.  Alternatively, use `C-M-}', which is bound to command</span>
<span class="linecomment">;;  `icicle-candidate-set-save-to-variable'.  You are prompted for the</span>
<span class="linecomment">;;  name of the variable, and you can use completion when inputting</span>
<span class="linecomment">;;  it.  During this completion, the only available candidates are</span>
<span class="linecomment">;;  variables that you have used for saved candidates (but completion</span>
<span class="linecomment">;;  is lax, so you can type a new variable name).  The same behavior</span>
<span class="linecomment">;;  works also for `C-&gt;', `C-M-)', and `C-)'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To retrieve completion candidates that were previously saved to a</span>
<span class="linecomment">;;  variable other than `icicle-saved-completion-candidates', so that</span>
<span class="linecomment">;;  they become the current set of candidates, use `C-u N C-M-&lt;',</span>
<span class="linecomment">;;  where N is an integer, or `C-M-{' (`icicle-candidate-set-retrieve'</span>
<span class="linecomment">;;  or `icicle-candidate-set-retrieve-from-variable').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using a plain prefix argument (`C-u' without a number) with</span>
<span class="linecomment">;;  `C-M-&gt;' and `C-M-&lt;' saves or retrieves a candidate set using a</span>
<span class="linecomment">;;  cache file, not a variable.  Alternatively, as a shortcut you can</span>
<span class="linecomment">;;  use `C-}' and `C-{' for this.</span>
<span class="linecomment">;;  See (@&gt; "Persistent Sets of Completion Candidates") and</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Support for Projects").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you save candidates to a different variable from</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates', they are not shown in buffer</span>
<span class="linecomment">;;  `*Completions*' using face `icicle-saved-candidate'.  When you</span>
<span class="linecomment">;;  save candidates to a cache file, they are also saved to</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates', so they are shown in</span>
<span class="linecomment">;;  `*Completions*' using face `icicle-saved-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-&gt;' and `C-&lt;' accept the same prefix arguments as `C-M-&gt;' and</span>
<span class="linecomment">;;  `C-M-&lt;' , letting you specify the source or destination (variable,</span>
<span class="linecomment">;;  cache file) when you save or retrieve additional candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Set Operations")</span>
<span class="linecomment">;;  ** Set Operations **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The other available set-operation commands for use with completion</span>
<span class="linecomment">;;  candidates, besides saving and retrieving, are these:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-swap', bound to `C-%'.  Swap the saved and</span>
<span class="linecomment">;;    current sets of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-define', bound to `C-:'.  Define the</span>
<span class="linecomment">;;    current set of completion candidates by evaluating an input</span>
<span class="linecomment">;;    sexp.  The sexp must evaluate to a list of strings, such as is</span>
<span class="linecomment">;;    returned by `all-completions'.  You can use this to substitute</span>
<span class="linecomment">;;    any list of strings, and then operate on them as completions,</span>
<span class="linecomment">;;    using any Icicles functionalities.  Keep in mind, however, that</span>
<span class="linecomment">;;    the completions must be of the proper type for the context in</span>
<span class="linecomment">;;    which they are used.  For example, if you are executing a</span>
<span class="linecomment">;;    command, they must be command names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-complement', bound to `C-~'.  Complement</span>
<span class="linecomment">;;    the current set of candidates: replace the current candidate set</span>
<span class="linecomment">;;    with its set complement.  This means all possible completions of</span>
<span class="linecomment">;;    the appropriate type that do *not* match the current input.  You</span>
<span class="linecomment">;;    can combine this with progressive completion (`M-*') to</span>
<span class="linecomment">;;    progressively eliminate candidates that match different inputs.</span>
<span class="linecomment">;;    This process-of-elimination matching is a common Icicles usage</span>
<span class="linecomment">;;    idiom.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-union', bound to `C-+'.  Replace the</span>
<span class="linecomment">;;    current candidate set by its union with the saved set of</span>
<span class="linecomment">;;    candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-difference', bound to `C--'.  Replace the</span>
<span class="linecomment">;;    current candidate set by its set difference with the saved set</span>
<span class="linecomment">;;    of candidates.  That is, the saved candidates are subtracted</span>
<span class="linecomment">;;    from the current candidates, and the result becomes the current</span>
<span class="linecomment">;;    candidate set.  To obtain the opposite set difference,</span>
<span class="linecomment">;;    subtracting the current candidates from the saved candidates,</span>
<span class="linecomment">;;    just use `icicle-candidate-set-swap' followed by</span>
<span class="linecomment">;;    `icicle-candidate-set-difference'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-intersection', bound to `C-*'.  Replace</span>
<span class="linecomment">;;    the current candidate set by its intersection with the saved set</span>
<span class="linecomment">;;    of candidates.  Unlike the set intersection provided by `M-*',</span>
<span class="linecomment">;;    `C-*' is, in itself, a one-time operation.  `M-*' can be</span>
<span class="linecomment">;;    repeated, using the previous intersection as one of the sets to</span>
<span class="linecomment">;;    be intersected in a new operation.  Both `C-*' and `M-*' use the</span>
<span class="linecomment">;;    current set of matching candidates as one of the sets being</span>
<span class="linecomment">;;    intersected.  But `M-*' reads another input regexp to define the</span>
<span class="linecomment">;;    other set to be intersected, whereas `C-*' uses the saved</span>
<span class="linecomment">;;    candidates set as the other set.  `M-*' is useful for chaining,</span>
<span class="linecomment">;;    to achieve progressive approximation.  `C-*' is useful to</span>
<span class="linecomment">;;    perform an intersection on a set from a previous input reading.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-candidate-set-truncate', bound to `M-$'.  Truncate the</span>
<span class="linecomment">;;    set of completion candidates, so that it includes only the first</span>
<span class="linecomment">;;    N candidates (as displayed in `*Completions*').  You are</span>
<span class="linecomment">;;    prompted for N.  You can use this when the order of candidates</span>
<span class="linecomment">;;    represents priority in some way, so that you are interested only</span>
<span class="linecomment">;;    in the topmost candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can operate on or choose from all input values in the set that</span>
<span class="linecomment">;;  results from any of these set operations.  For example, you can</span>
<span class="linecomment">;;  use `C-~' to see the list of objects that do not match the current</span>
<span class="linecomment">;;  input, to cycle among those objects, or to operate on any or all</span>
<span class="linecomment">;;  of them.  Use `C-~' at any time to switch to the complement of the</span>
<span class="linecomment">;;  current set of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Example: To cycle through all files whose names do not end in</span>
<span class="linecomment">;;           `el', you can do the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Use `C-f' to read a file name.</span>
<span class="linecomment">;;  2. Type `el$' to match all file names that end in `el'.</span>
<span class="linecomment">;;  3. Use `S-TAB' to show the matching files.</span>
<span class="linecomment">;;  4. Use `C-~' to flip to the complement: files not ending in `el'.</span>
<span class="linecomment">;;  5. Use `next' or `prior' to cycle among the new set of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A minibuffer message briefly confirms each of the set operations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When buffer `*Completions*' is displayed, the union, difference,</span>
<span class="linecomment">;;  and intersection commands scroll the buffer when repeated.</span>
<span class="linecomment">;;  Repeating `icicle-candidate-set-complement' complements the</span>
<span class="linecomment">;;  complement, of course, giving the original set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Once you have established a set of completion candidates using any</span>
<span class="linecomment">;;  of the candidate-set commands, you can cycle among the candidates</span>
<span class="linecomment">;;  of that set using either prefix or apropos cycling (`down', `up',</span>
<span class="linecomment">;;  `next', `prior', `end', or `home').  However, switching from</span>
<span class="linecomment">;;  prefix to apropos cycling (or completion), or vice versa,</span>
<span class="linecomment">;;  establishes a new completion set of the appropriate type, as</span>
<span class="linecomment">;;  usual.  Switching completion type signifies that you are finished</span>
<span class="linecomment">;;  with the specially defined completion set, and you want to</span>
<span class="linecomment">;;  redefine it using apropos or prefix cycling or completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Prefix icompletion (`icomplete.el' or `icomplete+.el' - see</span>
<span class="linecomment">;;        (@&gt; "Icompletion")) does not take into account the candidate</span>
<span class="linecomment">;;        set resulting from a set operation: it always displays the</span>
<span class="linecomment">;;        normal set of prefix completions in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: You might have noticed that, as a mnemonic device, the keys</span>
<span class="linecomment">;;        bound to the various set operations use the corresponding</span>
<span class="linecomment">;;        binary arithmetic or Boolean operators: `~' (unary negation)</span>
<span class="linecomment">;;        for complement (not); `*' (multiplication) for intersection</span>
<span class="linecomment">;;        (and); `+' (addition) for union (or); and `-' (subtraction)</span>
<span class="linecomment">;;        for difference.  Note too that the `C--' and `C-+' bindings</span>
<span class="linecomment">;;        mean that you cannot use these key sequences for prefix</span>
<span class="linecomment">;;        arguments - you must use `C-u N', or `M-N' instead, where N</span>
<span class="linecomment">;;        is a possibly signed integer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Multi-Commands") for information about `C-RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Choose All Completion Candidates") for information about</span>
<span class="linecomment">;;    `C-!'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Progressive Completion") for information about `M-*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "File-Name Input and Locating Files Anywhere") and</span>
<span class="linecomment">;;    (@&gt; "Persistent Sets of Completion Candidates"), for information</span>
<span class="linecomment">;;    about saving completion candidates persistently and retrieving</span>
<span class="linecomment">;;    them later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "History Enhancements"), (@&gt; "Google Matching"), and</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    for examples of other set operations on input candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    for information about saving and reusing sets of file-name</span>
<span class="linecomment">;;    candidates with Dired.</span>
 
<span class="linecomment">;;(@* "Google Matching")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Google Matching</span>
<span class="linecomment">;;  ---------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section presents nothing new - but you might not want to skip</span>
<span class="linecomment">;;  it.  It points out something that you might not have picked up</span>
<span class="linecomment">;;  yet.  You've learned about Icicles regexp matching and candidate</span>
<span class="linecomment">;;  set operations, but it can be worthwhile to compare how Icicles</span>
<span class="linecomment">;;  matches inputs against completion candidates with how Google</span>
<span class="linecomment">;;  matches search strings against Web pages.  Summary: You can do</span>
<span class="linecomment">;;  pretty much the same things, but the way you accomplish them is</span>
<span class="linecomment">;;  different.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Domain of Discourse")</span>
<span class="linecomment">;;  ** Domain of Discourse **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Google, the domain of discourse, that is, the possible set of</span>
<span class="linecomment">;;  search hits, is the set of Web pages.  There are also search</span>
<span class="linecomment">;;  fields that limit the domain of discourse by file type, page</span>
<span class="linecomment">;;  number, update date, page position, freedom of use, and even</span>
<span class="linecomment">;;  morality ("Safe Search").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles (Emacs), the domain of discourse changes automatically,</span>
<span class="linecomment">;;  depending on the current context.  For command-name input, it is</span>
<span class="linecomment">;;  the set of all named commands; for variable-name input, it is the</span>
<span class="linecomment">;;  set of variable names; and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Global Filtering")</span>
<span class="linecomment">;;  ** Global Filtering **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Google, you can limit searching to specific Web sites, or</span>
<span class="linecomment">;;  exclude certain Web sites from searching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can add extra completion candidates using variable</span>
<span class="linecomment">;;  `icicle-extra-candidates', and you can filter out (other)</span>
<span class="linecomment">;;  candidates globally using filter variables</span>
<span class="linecomment">;;  `icicle-must-match-regexp', `icicle-must-not-match-regexp',</span>
<span class="linecomment">;;  `icicle-must-pass-predicate', and</span>
<span class="linecomment">;;  `icicle-must-pass-after-match-predicate'.  These are internal</span>
<span class="linecomment">;;  Icicles variables.  Normally, you do not change them directly;</span>
<span class="linecomment">;;  instead, a command can use them to limit or extend the effective</span>
<span class="linecomment">;;  domain of discourse.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Global Filters").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variables `icicle-must-pass-predicate' and</span>
<span class="linecomment">;;  `icicle-must-pass-after-match-predicate' apply to the textual</span>
<span class="linecomment">;;  candidates that can be displayed in buffer `*Completions*'.  You</span>
<span class="linecomment">;;  can also apply a predicate to the full alist-entry or</span>
<span class="linecomment">;;  obarray-symbol candidates that are supplied to `completing-read'</span>
<span class="linecomment">;;  or `read-file-name' as its COLLECTION argument.  As a programmer,</span>
<span class="linecomment">;;  you can of course do that when your code calls these functions.</span>
<span class="linecomment">;;  As an Icicles user, you can use `M-&' to define and apply</span>
<span class="linecomment">;;  predicates to such alist-entry candidates on the fly, while</span>
<span class="linecomment">;;  completing.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Word Matching and String Matching")</span>
<span class="linecomment">;;  ** Word Matching and String Matching **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Google matches words, by default, but you can specify an "exact</span>
<span class="linecomment">;;  phrase" to get literal string matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, Icicles (apropos-)matches regexps, but you can use</span>
<span class="linecomment">;;  `\b' in a regexp to perform word matching, and you can use `C-`'</span>
<span class="linecomment">;;  (`icicle-toggle-regexp-quote') to perform exact (literal)</span>
<span class="linecomment">;;  matching.  See (@&gt; "What About Special-Character Conflicts?").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "AND Matching and OR Matching")</span>
<span class="linecomment">;;  ** AND Matching and OR Matching **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Google has search fields for AND matching ("with all of the</span>
<span class="linecomment">;;  words") and OR matching ("with at least one of the words").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can use progressive completion to perform AND</span>
<span class="linecomment">;;  matching: use `M-*' to introduce each term to match.</span>
<span class="linecomment">;;  Alternatively, you can use `C-*'</span>
<span class="linecomment">;;  (`icicle-candidate-set-intersection').  You can use `C-+'</span>
<span class="linecomment">;;  (`icicle-candidate-set-union') to perform OR matching.  Note that,</span>
<span class="linecomment">;;  by definition, unordered AND matching is not possible using a</span>
<span class="linecomment">;;  single regexp.  See (@&gt; "Progressive Completion") and</span>
<span class="linecomment">;;  (@&gt; "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "NOT Matching")</span>
<span class="linecomment">;;  ** NOT Matching **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Google has a search field for terms that must not occur in search</span>
<span class="linecomment">;;  hits: "without the words".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can use `C-~' (`icicle-candidate-set-complement')</span>
<span class="linecomment">;;  to exclude matching completion candidates.  You can combine this</span>
<span class="linecomment">;;  with progressive completion, to exclude any number of terms: `toto</span>
<span class="linecomment">;;  C-~ M-* titi C-~ M-* foobar' excludes all candidates matching</span>
<span class="linecomment">;;  toto, titi, or foobar.  Use this process-of-eliminiation technique</span>
<span class="linecomment">;;  to progressively pare down the set of possible candidates.  Note</span>
<span class="linecomment">;;  that such generalized complementing (as opposed to complementing a</span>
<span class="linecomment">;;  character set) is not possible using a single regexp - you cannot</span>
<span class="linecomment">;;  use a regular expression to say "Show me everything that does</span>
<span class="linecomment">;;  *not* match this".  See (@&gt; "Sets of Completion Candidates") and</span>
<span class="linecomment">;;  (@&gt; "Progressive Completion").</span>
 
<span class="linecomment">;;(@* "Buffer-Name Input")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Buffer-Name Input</span>
<span class="linecomment">;;  -----------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Icicles commands that read buffer names are multi-commands</span>
<span class="linecomment">;;  (see (@&gt; "Multi-Commands")), so you can act on more than one</span>
<span class="linecomment">;;  buffer during a given command invocation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These commands all let you use a prefix argument to control which</span>
<span class="linecomment">;;  buffers are completion candidates.  It is the numeric value of the</span>
<span class="linecomment">;;  prefix arg that matters:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Positive: only buffers visiting files</span>
<span class="linecomment">;;  * Zero:     only buffers with the same mode as the current buffer</span>
<span class="linecomment">;;  * Negative: only buffers associated with the selected frame</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to the usual Icicles key bindings, during buffer-name</span>
<span class="linecomment">;;  completion you can use the following keys:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-x M' (`icicle-filter-buffer-cands-for-mode') to filter the</span>
<span class="linecomment">;;    buffer-name candidates to keep only those with a given major</span>
<span class="linecomment">;;    mode.  You are prompted for the mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-x m' (`icicle-bookmark-non-file-other-window') to visit a</span>
<span class="linecomment">;;    bookmarked buffer.  This is available only if you use library</span>
<span class="linecomment">;;    `bookmark+.el'.  This too is a multi-command, so you can</span>
<span class="linecomment">;;    actually visit any number of buffer bookmarks with one use of</span>
<span class="linecomment">;;    `C-x m'.  When finished, you can continue with non-bookmark</span>
<span class="linecomment">;;    buffer-name completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `S-delete' to kill the buffer named by the current completion</span>
<span class="linecomment">;;    candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During completion, candidate sorting is specific to buffer names.</span>
<span class="linecomment">;;  `C-,' cycles among the following sort orders:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * by last access</span>
<span class="linecomment">;;  * `*...*' last: put buffers such as `*Messages*' and `*Help*' last</span>
<span class="linecomment">;;  * by buffer size</span>
<span class="linecomment">;;  * by major mode name</span>
<span class="linecomment">;;  * by mode-line mode name (mode name that appears in the mode line)</span>
<span class="linecomment">;;  * by (absolute) file or process name</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Finally, several user options control the completion behavior.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc2.el" :to "Customization and General Tips")</span>
<span class="linecomment">;;  and (@file :file-name "icicles-doc2.el" :to "Global Filters").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Ido and IswitchB") to use Icicles with a buffer-switching</span>
<span class="linecomment">;;    behavior that is similar to Ido and IswitchB</span>
<span class="linecomment">;;  * (@&gt; "`M-&': Satisfying Additional Predicates") to filter the</span>
<span class="linecomment">;;    buffer candidates on the fly in multiple ways (e.g. size)</span>
 
<span class="linecomment">;;(@* "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  File-Name Input and Locating Files Anywhere</span>
<span class="linecomment">;;  -------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs offers two main functions for reading minibuffer input with</span>
<span class="linecomment">;;  completion: `completing-read' and `read-file-name'.  Icicles uses</span>
<span class="linecomment">;;  both of these, and it enhances each of them in various ways for</span>
<span class="linecomment">;;  use in your own Emacs-Lisp code.  These two functions can each be</span>
<span class="linecomment">;;  used to read file-name input, but they do so in very different</span>
<span class="linecomment">;;  ways.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to the usual Icicles key bindings, during file-name</span>
<span class="linecomment">;;  completion you can use the following keys:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-backspace' (`icicle-up-directory') to navigate up the</span>
<span class="linecomment">;;    directory hierarchy.  It removes the last directory component</span>
<span class="linecomment">;;    (and any partial file name) from your minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (For Emacs versions before Emacs 22, this feature is available</span>
<span class="linecomment">;;    only for completion of absolute file names.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-c +' (`icicle-make-directory') to create a directory on the</span>
<span class="linecomment">;;    fly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-x m' (`icicle-bookmark-file-other-window') to visit a</span>
<span class="linecomment">;;    bookmarked file or directory.  This is available only if you use</span>
<span class="linecomment">;;    library `bookmark+.el'.  It is a multi-command, so you can</span>
<span class="linecomment">;;    actually visit any number of file bookmarks.  When finished, you</span>
<span class="linecomment">;;    can continue with non-bookmark file-name completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `S-delete' to delete the file named by the current completion</span>
<span class="linecomment">;;    candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-|' (`icicle-all-candidates-list-alt-action') to open Dired on</span>
<span class="linecomment">;;    the currently matching file names.  That is, it opens a special</span>
<span class="linecomment">;;    Dired buffer that contains only the matching files.  You are</span>
<span class="linecomment">;;    prompted for the Dired buffer name.  See (@&gt; "Alternative Actions").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In many cases for Icicles multi-commands that read a file name,</span>
<span class="linecomment">;;  you can use `M-n' to pick up the file name at point, or if none</span>
<span class="linecomment">;;  then the name of the file you are currently visiting.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Whether a command supports file-name globbing wildcards such</span>
<span class="linecomment">;;  as `*' is independent of whether it uses `read-file-name' or</span>
<span class="linecomment">;;  `completing-read'.  It is the command itself that offers such</span>
<span class="linecomment">;;  support or not.  Globbing takes place only after the file name</span>
<span class="linecomment">;;  (with wildcards) is read.  All Icicles commands that visit files</span>
<span class="linecomment">;;  (all of the commands mentioned in this section) let you use</span>
<span class="linecomment">;;  globbing wildcards.  Remember also that file-name globbing, with</span>
<span class="linecomment">;;  its special wildcards, has nothing to do with regexp completion</span>
<span class="linecomment">;;  matching.  See (@&gt; "What About Special-Character Conflicts?") for</span>
<span class="linecomment">;;  more information about file-name globbing.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Function `read-file-name'")</span>
<span class="linecomment">;;  ** Function `read-file-name' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `read-file-name' is specialized for file-name input with</span>
<span class="linecomment">;;  completion.  It knows about files and file names for your current</span>
<span class="linecomment">;;  platform.  It knows about Emacs remote file name syntax (Tramp,</span>
<span class="linecomment">;;  Ange FTP).  And starting with Emacs 23, `TAB' also completes</span>
<span class="linecomment">;;  environment variables during `read-file-name' completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using `read-file-name' is the most flexible way to read a file</span>
<span class="linecomment">;;  name in Emacs, and it is the traditional way.  Unless stated</span>
<span class="linecomment">;;  otherwise, "file-name completion", even in the Icicles doc, refers</span>
<span class="linecomment">;;  to `read-file-name' completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When `read-file-name' reads input, only the file name itself, not</span>
<span class="linecomment">;;  the directory portion, is used for matching.  The directory is</span>
<span class="linecomment">;;  understood to be the value of variable `default-directory' (which</span>
<span class="linecomment">;;  you can change using command `cd', for instance).  The behavior is</span>
<span class="linecomment">;;  thus the same whether or not the directory name is present in the</span>
<span class="linecomment">;;  minibuffer.  If you prefer, you can delete the directory name</span>
<span class="linecomment">;;  first, using `M-k'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With `read-file-name', you can thus use apropos completion to</span>
<span class="linecomment">;;  match a file-name substring, without needing to prefix the</span>
<span class="linecomment">;;  substring with `.*' in the minibuffer.  For example, to match the</span>
<span class="linecomment">;;  file named `favorite-foo-file.bar' in directory</span>
<span class="linecomment">;;  `/some/path/to/my/', you need not use `/some/path/to/my/.*foo'; it</span>
<span class="linecomment">;;  is sufficient to use either `foo' or `/some/path/to/my/foo'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  An additional feature of `read-file-name' in Icicle mode is that</span>
<span class="linecomment">;;  candidates that are directory names are highlighted in buffer</span>
<span class="linecomment">;;  `*Completions*' using face `icicle-special-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Function `completing-read'")</span>
<span class="linecomment">;;  ** Function `completing-read' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `completing-read' is a general function for reading input</span>
<span class="linecomment">;;  with completion.  It is not specially designed for reading file</span>
<span class="linecomment">;;  names.  It knows nothing about files and file names. It knows</span>
<span class="linecomment">;;  nothing about remote file-name syntax.  When `completing-read'</span>
<span class="linecomment">;;  reads input, it makes no use of `default-directory'.  The</span>
<span class="linecomment">;;  completion candidates are treated as simple strings; they are not</span>
<span class="linecomment">;;  really treated as file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles commands that use `completing-read' to read a file name</span>
<span class="linecomment">;;  typically read an absolute name, that is, a name that includes the</span>
<span class="linecomment">;;  directory portion.  This means that you can match against any part</span>
<span class="linecomment">;;  of the full name, including any directory components.  The</span>
<span class="linecomment">;;  directory portions of the candidate file names need not be the</span>
<span class="linecomment">;;  same - you can thus complete against a set of files in multiple</span>
<span class="linecomment">;;  directories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Commands that Read File Names")</span>
<span class="linecomment">;;  ** Icicles Commands that Read File Names **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles commands that use `read-file-name' include all</span>
<span class="linecomment">;;  multi-commands, such as `icicle-find-file', that are defined using</span>
<span class="linecomment">;;  `icicle-define-file-command'.  Vanilla Emacs command `find-file'</span>
<span class="linecomment">;;  is another example of a command that uses `read-file-name'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles commands that use `completing-read' to read file names</span>
<span class="linecomment">;;  include the multi-commands `icicle-find-file-absolute',</span>
<span class="linecomment">;;  `icicle-find-file-in-tags-table', `icicle-recent-file',</span>
<span class="linecomment">;;  `icicle-locate-file', and `icicle-locate-file-no-symlinks'.  These</span>
<span class="linecomment">;;  are defined using `icicle-define-command', not</span>
<span class="linecomment">;;  `icicle-define-file-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are also `-other-window' versions of all of the Icicles</span>
<span class="linecomment">;;  commands that read file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Icicles commands that use `completing-read' to read file names</span>
<span class="linecomment">;;  have an additional feature: you can use a prefix argument to tell</span>
<span class="linecomment">;;  them to combine the last modification date with the file name, as</span>
<span class="linecomment">;;  a multi-completion - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Multi-Completions").</span>
<span class="linecomment">;;  This means that you can easily look up files whose modification</span>
<span class="linecomment">;;  time or date matches some (regexp) criterion, such as being</span>
<span class="linecomment">;;  sometime in July 2008.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When using a command that reads an absolute file name, remember</span>
<span class="linecomment">;;  that, to save space, you can use `C-x .' to toggle hiding of the</span>
<span class="linecomment">;;  common match portions of the candidates in `*Completions*'.  This</span>
<span class="linecomment">;;  portion is often a long directory substring.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-file' is bound, by default, to `C-x C-f' in Icicle</span>
<span class="linecomment">;;  mode, thus taking the place of `find-file'.  It combines</span>
<span class="linecomment">;;  `icicle-find-file' and `icicle-find-file-absolute'.  With no</span>
<span class="linecomment">;;  prefix argument, it matches relative file names; with a prefix</span>
<span class="linecomment">;;  argument, it matches absolute names (as ordinary strings).  With a</span>
<span class="linecomment">;;  negative prefix argument, you can match also the modification</span>
<span class="linecomment">;;  date.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  An additional feature of `icicle-find-file-absolute' and</span>
<span class="linecomment">;;  `icicle-find-file-absolute-other-window' is that candidates that</span>
<span class="linecomment">;;  are directory names are highlighted in buffer `*Completions*'</span>
<span class="linecomment">;;  using face `icicle-special-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Commands `icicle-find-file-in-tags-table' and</span>
<span class="linecomment">;;  `icicle-find-file-in-tags-table-other-window' let you visit files</span>
<span class="linecomment">;;  that are listed in the current Emacs tags table.  You can think of</span>
<span class="linecomment">;;  these potential completion candidates as all of the files in a</span>
<span class="linecomment">;;  project defined by the tags table.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `icicle-recent-file' to open any file that you have</span>
<span class="linecomment">;;  visited recently, perhaps in a previous Emacs session.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `icicle-locate-file' to find a file when you do not</span>
<span class="linecomment">;;  know what directory it is in.  It looks throughout a given</span>
<span class="linecomment">;;  directory, including throughout all of its subdirectories.</span>
<span class="linecomment">;;  Command `icicle-locate-file-no-symlinks' is the same, except that</span>
<span class="linecomment">;;  it does not follow symbolic links.  Both of these locate commands</span>
<span class="linecomment">;;  respect option `icicle-ignored-directories', which is a list of</span>
<span class="linecomment">;;  directories to ignore - by default, version-control directories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, the target directory for `icicle-locate-file' is the</span>
<span class="linecomment">;;  current directory, but if you supply a non-negative numeric prefix</span>
<span class="linecomment">;;  argument (non-positive means include the date), then you are</span>
<span class="linecomment">;;  prompted for the directory to search.  If you use the root of your</span>
<span class="linecomment">;;  file system as the search directory, then the locate-file commands</span>
<span class="linecomment">;;  will match completion candidates anywhere in your file system.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This can be quite useful.  It gives you much of the power of the</span>
<span class="linecomment">;;  Unix `find' command just for completing input!  And with</span>
<span class="linecomment">;;  incremental completion (see (@&gt; "Icompletion")), you can see what</span>
<span class="linecomment">;;  matches your input as you type.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Obviously, if you use your entire file system as the set of</span>
<span class="linecomment">;;  completion candidates, then gathering and matching such a large</span>
<span class="linecomment">;;  set of file names can take some time.  On my hard drive, for</span>
<span class="linecomment">;;  instance, there are 36 GB full of files, and it takes about 40</span>
<span class="linecomment">;;  seconds to gather all of the file names.  In spite of this</span>
<span class="linecomment">;;  inconvenience, this functionality can be useful.  And of course</span>
<span class="linecomment">;;  searching a shallower directory tree presents less of a</span>
<span class="linecomment">;;  performance penalty - you pay for what you get.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There is a way, however, of having your cake and eating it too.</span>
<span class="linecomment">;;  You can gather all of the file names in your file system once, and</span>
<span class="linecomment">;;  save that list of completion candidates to a cache file on disk,</span>
<span class="linecomment">;;  as a snapshot.</span>
<span class="linecomment">;;  See (@&gt; "Persistent Sets of Completion Candidates"), for how to do</span>
<span class="linecomment">;;  this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Absolute File Names and Different Directories")</span>
<span class="linecomment">;;  ** Absolute File Names and Different Directories **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Since `completing-read' has no understanding of file-name syntax,</span>
<span class="linecomment">;;  including remote file-name syntax, `icicle-find-file-absolute'</span>
<span class="linecomment">;;  (`C-u C-x C-f') and similar commands are similarly ignorant.  (You</span>
<span class="linecomment">;;  can nevertheless use `C-.' with these Icicles commands, to toggle</span>
<span class="linecomment">;;  respect of `completion-ignored-extensions'.)  In particular, these</span>
<span class="linecomment">;;  commands will not let you complete to a remote file name if the</span>
<span class="linecomment">;;  current directory is local.  They also will not let you complete</span>
<span class="linecomment">;;  to a file name in a different local directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because all Icicles commands that read file names use lax</span>
<span class="linecomment">;;  completion, you can nevertheless visit a file in a different</span>
<span class="linecomment">;;  directory (remote or local) from the current one, even though you</span>
<span class="linecomment">;;  cannot complete your input to such a name.  That is, you can</span>
<span class="linecomment">;;  always use `RET' with any file name as minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So how can you complete your input to an absolute file-name in a</span>
<span class="linecomment">;;  different directory?  By retrieving a saved candidate set that has</span>
<span class="linecomment">;;  such absolute names and then completing against that set.  For</span>
<span class="linecomment">;;  example, you can retrieve a set that represents files on a remote</span>
<span class="linecomment">;;  machine and complete to their names even from a local directory.</span>
<span class="linecomment">;;  All that counts for `completing-read' is that your input can match</span>
<span class="linecomment">;;  candidates, where that matching is ordinary (apropos or prefix)</span>
<span class="linecomment">;;  string matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To create such a saved set of names, you can visit the directory</span>
<span class="linecomment">;;  (perhaps remote) that contains the files and then use `C-u C-x</span>
<span class="linecomment">;;  C-f' and `C-}' to save the candidates.  You can later retrieve</span>
<span class="linecomment">;;  this saved set for completion, no matter what the current</span>
<span class="linecomment">;;  directory is.  As another example, you can use</span>
<span class="linecomment">;;  `icicle-locate-file' in a remote directory to create a saved set</span>
<span class="linecomment">;;  that includes remote files that are all somewhere under that</span>
<span class="linecomment">;;  remote directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, you can add more file names to an existing saved set</span>
<span class="linecomment">;;  using `C-&gt;', `C-)', `M-mouse-3', `insert', or `M-S-mouse-2' - see</span>
<span class="linecomment">;;  (@&gt; "Sets of Completion Candidates"). The added names can come</span>
<span class="linecomment">;;  from a different directory than files already in the saved set. In</span>
<span class="linecomment">;;  this way, you can build up a saved set that includes files from</span>
<span class="linecomment">;;  any directories, some of which can be local and some remote, some</span>
<span class="linecomment">;;  remote from one host, some remote from another, and so on. You can</span>
<span class="linecomment">;;  create a saved set with any mix of absolute file names from any</span>
<span class="linecomment">;;  locations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Remember this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * To create and add to a saved set of absolute file names, use a</span>
<span class="linecomment">;;    command that expects absolute file names, and do this from the</span>
<span class="linecomment">;;    directory that contains the files you want to add.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * When you retrieve a saved set of file-name candidates for</span>
<span class="linecomment">;;    completion, use a command that expects the same kind of file</span>
<span class="linecomment">;;    names, relative or absolute, as the saved names.  For example,</span>
<span class="linecomment">;;    if you save a set of project files that are spread over</span>
<span class="linecomment">;;    different directories (and hence are absolute), then retrieve</span>
<span class="linecomment">;;    that candidate set using, say, `C-u C-x C-f' (absolute), not</span>
<span class="linecomment">;;    `C-x C-f' (relative).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Finally, although the commands that read absolute file names are</span>
<span class="linecomment">;;  essentially ignorant of directory hierarchies and of file names as</span>
<span class="linecomment">;;  such, so that they treat their candidates only as simple strings,</span>
<span class="linecomment">;;  a few of these commands nevertheless define their domain of</span>
<span class="linecomment">;;  possible file-name candidates relative to some starting directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is the case for `icicle-find-file-absolute' and</span>
<span class="linecomment">;;  `icicle-locate-file' (and their variants).  For these commands,</span>
<span class="linecomment">;;  you can use `C-c C-d' (think UNIX command `cd') during completion</span>
<span class="linecomment">;;  to change the current working directory (`default-directory') on</span>
<span class="linecomment">;;  the fly.  You are prompted for the directory.  The domain of</span>
<span class="linecomment">;;  possible candidates is recomputed relative to the new</span>
<span class="linecomment">;;  `default-directory'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Use `C-c C-d' this way as many times as you like.  You can use</span>
<span class="linecomment">;;  this feature to add file names from different directories to a</span>
<span class="linecomment">;;  saved set of candidates.  When the command is finished, the</span>
<span class="linecomment">;;  original `default-directory' is restored.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Persistent Sets of Completion Candidates") for information</span>
<span class="linecomment">;;    about saving a set of file names persistently</span>
<span class="linecomment">;;  * (@&gt; "Sets of Completion Candidates") for information about</span>
<span class="linecomment">;;    creating, saving, and retrieving sets of file names</span>
<span class="linecomment">;;  * (@&gt; "Dealing With Large Candidate Sets") for ways to deal with a</span>
<span class="linecomment">;;    large number of candidates</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Multi-Completions")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Support for Projects")</span>
<span class="linecomment">;;    for more about `icicle-find-file-in-tags-table'</span>
<span class="linecomment">;;  * (@&gt; "Completion On Demand") for information about on-demand</span>
<span class="linecomment">;;    insertion of file names, using completion, from any minibuffer</span>

 
<span class="linecomment">;;(@* "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Persistent Sets of Completion Candidates</span>
<span class="linecomment">;;  ----------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Section (@&gt; "Sets of Completion Candidates") describes how you can</span>
<span class="linecomment">;;  save the current set of completion candidates and reuse it later.</span>
<span class="linecomment">;;  This is not a persistent save, however; the candidates are simply</span>
<span class="linecomment">;;  saved in variable `icicle-saved-completion-candidates' for the</span>
<span class="linecomment">;;  duration of your Emacs session (or until you save candidates</span>
<span class="linecomment">;;  again).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can save the current set of completions (whatever it is)</span>
<span class="linecomment">;;  persistently by supplying a plain prefix argument (`C-u') when you</span>
<span class="linecomment">;;  use `C-M-&gt;' (`icicle-candidate-set-save') during completion.</span>
<span class="linecomment">;;  Alternatively, you can use `C-}', bound to</span>
<span class="linecomment">;;  `icicle-candidate-set-save-persistently', which does the same</span>
<span class="linecomment">;;  thing.  To retrieve completion candidates that were previously</span>
<span class="linecomment">;;  saved to a cache file, so that they become the current set of</span>
<span class="linecomment">;;  candidates, use either `C-u C-M-&lt;' or `C-{'</span>
<span class="linecomment">;;  (`icicle-candidate-set-retrieve' or</span>
<span class="linecomment">;;  `icicle-candidate-set-retrieve-persistent').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tip: Suppose you have already saved a set of candidates, but not</span>
<span class="linecomment">;;       persistently, and you now want to write this saved set to a</span>
<span class="linecomment">;;       cache file.  Use `C-M-&lt;' followed by `TAB' or `S-TAB',</span>
<span class="linecomment">;;       followed by `C-}'.  That is, retrieve the saved candidates</span>
<span class="linecomment">;;       and then save the retrieved candidates persistently.  (You</span>
<span class="linecomment">;;       use `TAB' or `S-TAB' because retrieval opens a recursive</span>
<span class="linecomment">;;       minibuffer.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that using a numeric prefix argument (`C-u' with a number)</span>
<span class="linecomment">;;  with `C-M-&gt;' and `C-M-&lt;' saves or retrieves a</span>
<span class="linecomment">;;  completion-candidates set using a variable that you name, not a</span>
<span class="linecomment">;;  cache file.  See (@&gt; "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Saving Candidates in Cache Files")</span>
<span class="linecomment">;;  ** Saving Candidates in Cache Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you have used the Emacs file-name cache (see the Emacs manual,</span>
<span class="linecomment">;;  node "File Name Cache"), then you have already used a cache file</span>
<span class="linecomment">;;  of (file-name) completion candidates.  In vanilla Emacs, you use</span>
<span class="linecomment">;;  `C-TAB' during file-name input to complete to a cached file name.</span>
<span class="linecomment">;;  In Icicles, you use `C-{'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, the cached candidates are not limited to file names,</span>
<span class="linecomment">;;  and you can have any number of cache files, to save different sets</span>
<span class="linecomment">;;  of completion candidates.  Each cache file saves the set of</span>
<span class="linecomment">;;  candidates that was current when you created (saved) the set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The fact that a cache file can contain just those candidates that</span>
<span class="linecomment">;;  were current when you saved it is a considerable advantage, when</span>
<span class="linecomment">;;  combined with Icicles features for sculpting the current set of</span>
<span class="linecomment">;;  matching candidates.  As far as I know, Icicles is the only</span>
<span class="linecomment">;;  package to offer this feature.  You spend a few moments to</span>
<span class="linecomment">;;  fine-tune a set of candidates, using, for example, `M-*', `C-~',</span>
<span class="linecomment">;;  and `delete', and then save it for later use.  From then on, you</span>
<span class="linecomment">;;  can match against exactly those candidates anytime you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, you might have a software project that involves only</span>
<span class="linecomment">;;  certain directories and perhaps only certain kinds of files in</span>
<span class="linecomment">;;  those directories are of interest as completion candidates.  Those</span>
<span class="linecomment">;;  directories and files can even be in disparate locations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Start with command `icicle-locate-file' (or</span>
<span class="linecomment">;;  `icicle-locate-file-no-symlinks').  Then use progressive</span>
<span class="linecomment">;;  completion to match the directories and files you want and chip</span>
<span class="linecomment">;;  away at those you do not want.  Once you get just the set you need</span>
<span class="linecomment">;;  for your project, save that set using `C-}'.  You can have any</span>
<span class="linecomment">;;  number of saved sets, for different projects or different purposes</span>
<span class="linecomment">;;  in the same project.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You name the sets of saved candidates, and these names are</span>
<span class="linecomment">;;  associated with the cache files in user option</span>
<span class="linecomment">;;  `icicle-saved-completion-sets'.  This is an alist of entries, each</span>
<span class="linecomment">;;  of which is of the form (SET-NAME . CACHE-FILE-NAME).  You can</span>
<span class="linecomment">;;  customize this option, or set it in your init file (~/.emacs).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use command `icicle-add/update-saved-completion-set' to</span>
<span class="linecomment">;;  add a new set to `icicle-saved-completion-sets' or update</span>
<span class="linecomment">;;  (replace) an existing such set.  You can use command</span>
<span class="linecomment">;;  `icicle-remove-saved-completion-set' to remove a saved set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an alternative to customizing `icicle-saved-completion-sets' or</span>
<span class="linecomment">;;  using command `icicle-add/update-saved-completion-set', you can</span>
<span class="linecomment">;;  simply try to save a set of completion candidates persistently,</span>
<span class="linecomment">;;  using `C-u C-M-&gt;' or `C-}'.  You are then prompted for the names</span>
<span class="linecomment">;;  of the candidate set and cache file to use, and the names you</span>
<span class="linecomment">;;  enter are automatically entered in option</span>
<span class="linecomment">;;  `icicle-saved-completion-sets'.  That option is automatically</span>
<span class="linecomment">;;  saved to your custom file, so the next time you use Emacs you can</span>
<span class="linecomment">;;  retrieve any saved set of candidates that you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you try to retrieve a persistent set of completion</span>
<span class="linecomment">;;  candidates, you are similarly prompted for the candidate-set name</span>
<span class="linecomment">;;  and the cache-file name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to saving the current set of completion candidates to</span>
<span class="linecomment">;;  a cache file, you can add individual strings as future completion</span>
<span class="linecomment">;;  candidates to any cache file, and you can remove candidates from a</span>
<span class="linecomment">;;  cache file individually.  You do this using commands</span>
<span class="linecomment">;;  `icicle-add-entry-to-saved-completion-set' and</span>
<span class="linecomment">;;  `icicle-remove-entry-from-saved-completion-set'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Adding an individual candidate is similar to using the Emacs</span>
<span class="linecomment">;;  file-name cache commands that add file names to the cache, but it</span>
<span class="linecomment">;;  adds only a single candidate.  For file names, adding a directory</span>
<span class="linecomment">;;  name effectively provides completion for all of its files as well,</span>
<span class="linecomment">;;  so there is no need to add each file name as well as the directory</span>
<span class="linecomment">;;  name.  Alternatively, you can always use `C-}' to add all file</span>
<span class="linecomment">;;  names that match your current input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Filesets and Icicles Saved Completion Sets")</span>
<span class="linecomment">;;  ** Filesets and Icicles Saved Completion Sets **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Starting with release 22, GNU Emacs includes a filesets feature</span>
<span class="linecomment">;;  that lets you create named sets of file names, called "filesets".</span>
<span class="linecomment">;;  It is a powerful feature, letting you define such sets by</span>
<span class="linecomment">;;  intension, using regexp patterns, as well as by extension, listing</span>
<span class="linecomment">;;  file names explicitly.  You can easily use a fileset to define a</span>
<span class="linecomment">;;  project of files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you use an Emacs fileset any time you can use an</span>
<span class="linecomment">;;  Icicles saved completion set, provided that option</span>
<span class="linecomment">;;  `icicle-filesets-as-saved-completion-sets-flag' is non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, you can retrieve fileset file names as the current set of</span>
<span class="linecomment">;;  completion candidates or save the current completion candidates to</span>
<span class="linecomment">;;  a fileset.  Provided</span>
<span class="linecomment">;;  `icicle-filesets-as-saved-completion-sets-flag' is non-`nil', you</span>
<span class="linecomment">;;  can always choose a fileset as the set to retrieve.  To save to a</span>
<span class="linecomment">;;  fileset, use a prefix arg with `C-}' or a zero prefix arg with</span>
<span class="linecomment">;;  `C-M-&gt;'.  Saving candidates to a fileset gives you an alternative</span>
<span class="linecomment">;;  to customizing option `filesets-data'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Being able to use an Emacs fileset in place of an Icicles saved</span>
<span class="linecomment">;;  set lets you use filesets in additional ways.  For example, it</span>
<span class="linecomment">;;  lets you open Dired on only the files in a fileset, for easy</span>
<span class="linecomment">;;  manipulation of the member files.  Conversely, you can save all of</span>
<span class="linecomment">;;  the marked files in a Dired buffer as a fileset. See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Dired Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Beyond letting you use a fileset in place of a persistent Icicles</span>
<span class="linecomment">;;  saved completion set, you can include filesets in such saved</span>
<span class="linecomment">;;  Icicles sets.  That is, you can save one or more filesets of any</span>
<span class="linecomment">;;  kind (`:files', `:tree', etc.) in an Icicles persistent saved set</span>
<span class="linecomment">;;  (cache file).  When you then retrieve such a saved set, all of the</span>
<span class="linecomment">;;  file names specified by all of the included filesets become</span>
<span class="linecomment">;;  completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, this could be a saved Icicles set that combines a</span>
<span class="linecomment">;;  `:tree' fileset with an explicit `:files' fileset and with two</span>
<span class="linecomment">;;  additional files:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  ((:fileset "set1" (:tree "~/my/dir" "^ici.+\\.el$"))</span>
<span class="linecomment">;;   (:fileset "set2" (:files "dired+.el" "c:/my/dir/buff-menu+.el"))</span>
<span class="linecomment">;;   "c:/some/other/dir/foobar.el"</span>
<span class="linecomment">;;   "c:/somewhere/else/toto.el")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is a great way to put together a project of files from</span>
<span class="linecomment">;;  different directory trees.  And even aside from the use of such a</span>
<span class="linecomment">;;  saved set for completion, this combining of filesets is something</span>
<span class="linecomment">;;  that you cannot do with Emacs filesets alone, as far as I know -</span>
<span class="linecomment">;;  you cannot combine different filesets into super filesets, and a</span>
<span class="linecomment">;;  given fileset can specify files in only one way (`:files',</span>
<span class="linecomment">;;  `:tree', etc.).  Icicles gives you a way to associate related</span>
<span class="linecomment">;;  filesets and use them together as a single set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use commands</span>
<span class="linecomment">;;  `icicle-remove-entry-from-saved-completion-set' and</span>
<span class="linecomment">;;  `icicle-add-entry-to-saved-completion-set' to remove a fileset</span>
<span class="linecomment">;;  from an Icicles saved set or add a fileset to a saved set.  To</span>
<span class="linecomment">;;  add, use a prefix arg to tell</span>
<span class="linecomment">;;  `icicle-add-entry-to-saved-completion-set' that you are adding a</span>
<span class="linecomment">;;  fileset and not a single completion candidate.  To add a single</span>
<span class="linecomment">;;  file (default: the current buffer's file) to a fileset, use</span>
<span class="linecomment">;;  command `icicle-add-file-to-fileset'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Use the right type of saved candidates (persistent or not)</span>
<span class="linecomment">;;  for a given command.  It is the particular command that determines</span>
<span class="linecomment">;;  whether or not a given type of saved candidate is appropriate.</span>
<span class="linecomment">;;  For example, you can save search hits when you use</span>
<span class="linecomment">;;  `icicle-search-file' (same as `icicle-search' with a negative</span>
<span class="linecomment">;;  prefix arg), and those saved search-hit candidates effectively</span>
<span class="linecomment">;;  reference files and positions in those files.  And you can later</span>
<span class="linecomment">;;  retrieve and reuse such saved candidates to visit the search</span>
<span class="linecomment">;;  positions.  But those candidates are not merely file names, so</span>
<span class="linecomment">;;  they cannot be used with a command such as `find-file' or</span>
<span class="linecomment">;;  `icicle-file' that expects a file name.  Conversely, you cannot</span>
<span class="linecomment">;;  use a saved set of file names with a command such as</span>
<span class="linecomment">;;  `icicle-search-file' that expects `icicle-search' candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Improving Performance with Persistent Sets")</span>
<span class="linecomment">;;  ** Improving Performance with Persistent Sets **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are two independent reasons that using a persistent set of</span>
<span class="linecomment">;;  file names can improve performance:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Avoiding remote file-name completion.  You can complete your</span>
<span class="linecomment">;;    input against remote file names without using Tramp and thus</span>
<span class="linecomment">;;    without accessing the remote file system.  (Once you have chosen</span>
<span class="linecomment">;;    the file you want, visiting it of course makes a remote access.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Avoiding generation of a large completion set.  Retrieving a</span>
<span class="linecomment">;;    list of file names is much, much faster than generating such a</span>
<span class="linecomment">;;    list.  So generate once and retrieve often, from a cache.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These are covered in the next two sections.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Avoid Remote File-Name Completion")</span>
<span class="linecomment">;;  *** Avoid Remote File-Name Completion ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you complete the name of a remote file, Tramp accesses the</span>
<span class="linecomment">;;  remote file system to see which matching files exist.  This takes</span>
<span class="linecomment">;;  time.  The completion itself is complicated - it involves parsing</span>
<span class="linecomment">;;  the remote file name and calling upon various file handlers.  But</span>
<span class="linecomment">;;  the greatest time spent is in accessing the remote machine.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you retrieve a (persistently) saved set of file names during</span>
<span class="linecomment">;;  completion, you are telling Emacs that these are the candidates</span>
<span class="linecomment">;;  you want to complete against.  You are not asking Emacs (Tramp) to</span>
<span class="linecomment">;;  tell you what the possible candidates are; you are telling it.</span>
<span class="linecomment">;;  (Obviously you will want to save the completions in a file on the</span>
<span class="linecomment">;;  local machine, so retrieval itself takes no time.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  After retrieving the saved candidates as the only possible ones,</span>
<span class="linecomment">;;  you might type some input and complete it (`TAB' or `S-TAB') to</span>
<span class="linecomment">;;  narrow your choices.  Or you might not bother with completion but</span>
<span class="linecomment">;;  instead pick one of the candidates using `mouse-2' or by cycling</span>
<span class="linecomment">;;  to it and using `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use either relative or absolute file-name completion with</span>
<span class="linecomment">;;  remote file names.  Relative name completion as provided by</span>
<span class="linecomment">;;  `read-file-name' (via `C-x C-f', for example) always involves</span>
<span class="linecomment">;;  Tramp (or ange-ftp, prior to Emacs 22).  When using relative name</span>
<span class="linecomment">;;  completion, you can save time in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Turn off incremental completion (using `C-#'), so that Tramp is</span>
<span class="linecomment">;;    used only when you hit `TAB' or `S-TAB', not with each character</span>
<span class="linecomment">;;    you type or delete!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Use `mouse-2', or cycle and use `RET', so that you avoid</span>
<span class="linecomment">;;    completion altogether.  Tramp is then used only to access the</span>
<span class="linecomment">;;    chosen file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use absolute file-name completion as provided by</span>
<span class="linecomment">;;  `completing-read' (via `C-u C-x C-f', for example), then you need</span>
<span class="linecomment">;;  not worry about turning off incremental completion or avoiding</span>
<span class="linecomment">;;  completion by cycling or using `mouse-2'.  This is because</span>
<span class="linecomment">;;  completion is entirely local - `completing-read' has no notion of</span>
<span class="linecomment">;;  files, let alone remote files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, if you use absolute file-name completion then you</span>
<span class="linecomment">;;  need not bother to type the (long) remote file-name prefix to get</span>
<span class="linecomment">;;  into the right directory for completion.  Again, `completing-read'</span>
<span class="linecomment">;;  has no notion of files or directories - it just completes an input</span>
<span class="linecomment">;;  pattern against string candidates.  Just type a substring or other</span>
<span class="linecomment">;;  regexp and then hit `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In general, using absolute file names (`C-u C-x C-f') is the way</span>
<span class="linecomment">;;  to go when dealing with remote files.  There is no need to forego</span>
<span class="linecomment">;;  the advantages of Icicles completion.  On the other hand, if you</span>
<span class="linecomment">;;  are going to work in a directory on a remote machine for some time</span>
<span class="linecomment">;;  using files other than those in some saved completion set, then</span>
<span class="linecomment">;;  you might want to use relative file names (`C-x C-f').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Avoid Generating A Large Completion Set")</span>
<span class="linecomment">;;  *** Avoid Generating A Large Completion Set ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Section (@&gt; "File-Name Input and Locating Files Anywhere") tells</span>
<span class="linecomment">;;  you how you can locate any file in your file system.  If you save</span>
<span class="linecomment">;;  the set of all file names persistently, you will increase the</span>
<span class="linecomment">;;  performance of using it - it is much faster to retrieve the list</span>
<span class="linecomment">;;  of all file names than it is to generate it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With 36 GB of files in my file system, my all-file-system cache</span>
<span class="linecomment">;;  file is 20 MB, and retrieving the file-name completions from it</span>
<span class="linecomment">;;  takes only a few seconds.  With this feature, Icicles essentially</span>
<span class="linecomment">;;  gives you the functionality of the Unix `locate' command, but with</span>
<span class="linecomment">;;  the addition of real-time regexp matching.  Here is all you do:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-locate-file RET</span>
<span class="linecomment">;;    C-#        ; Once or twice: turn off incremental completion.</span>
<span class="linecomment">;;    C-{        ; Retrieve all file names from your cache file.</span>
<span class="linecomment">;;               ; You are prompted for the set name and file name.</span>
<span class="linecomment">;;    foo.*bar   ; Regexp to match names with `foo' followed by `bar'.</span>
<span class="linecomment">;;    S-TAB      ; Update `*Completions*' display (because of `C-#').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, once you have retrieved a set of candidates from your</span>
<span class="linecomment">;;  cache file, you can access them again without re-reading the file.</span>
<span class="linecomment">;;  When they are retrieved from your cache they are saved in variable</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates', so the next time you want to</span>
<span class="linecomment">;;  use them, just retrieve them from this variable with `C-M-&lt;'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "File-Name Input and Locating Files Anywhere") for</span>
<span class="linecomment">;;    information about relative vs absolute file names and about</span>
<span class="linecomment">;;    finding files located anywhere in your file system</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icompletion") for information about `C-#' (toggle</span>
<span class="linecomment">;;    incremental completion)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Sets of Completion Candidates") for information about</span>
<span class="linecomment">;;    `C-M-&gt;' (save current candidates)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Icicles Bookmark Enhancements")</span>
<span class="linecomment">;;    for information about using autofile bookmarks, which are</span>
<span class="linecomment">;;    another form of persistent file names</span>
 
<span class="linecomment">;;(@* "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Dealing With Large Candidate Sets</span>
<span class="linecomment">;;  ---------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One of the advantages Icicles provides is the ability to deal with</span>
<span class="linecomment">;;  large sets of completion candidates with ease.  There are other</span>
<span class="linecomment">;;  libraries that also let you cycle among various choices of</span>
<span class="linecomment">;;  different kinds (buffers, files, and so on), but cycling quickly</span>
<span class="linecomment">;;  loses its effectiveness as the number of candidates increases.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles apropos matching lets you work with a large initial set of</span>
<span class="linecomment">;;  candidates by filtering them, quickly reducing the number</span>
<span class="linecomment">;;  candidates to cycle through.  Filtering by a prefix only (vanilla</span>
<span class="linecomment">;;  Emacs) is not very potent.  Until you get used to Icicles, you</span>
<span class="linecomment">;;  will be surprised at your ability to manipulate even humongous</span>
<span class="linecomment">;;  sets of choices.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nevertheless, there can be times when a candidate set is so large</span>
<span class="linecomment">;;  that you need to use a few tricks to deal with it efficiently.</span>
<span class="linecomment">;;  There are two main things that take time when dealing with a large</span>
<span class="linecomment">;;  set: computing the set and displaying it (with highlighting) in</span>
<span class="linecomment">;;  buffer `*Completions*'.  In particular, incremental completion</span>
<span class="linecomment">;;  display is costly because it does both of these, recompute the set</span>
<span class="linecomment">;;  and redisplay it, each time you type or delete a character in the</span>
<span class="linecomment">;;  minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some tips to improve performance with a large set of</span>
<span class="linecomment">;;  candidates:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Turn off incremental completion display in buffer</span>
<span class="linecomment">;;    `*Completions*'.  You can do this on the fly at any time by</span>
<span class="linecomment">;;    using `C-#' in the minibuffer - use `C-#' again to turn it back</span>
<span class="linecomment">;;    on.  See (@&gt; "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Compute a large candidate set only once, cache the result, and</span>
<span class="linecomment">;;    reuse it later by reading the cache instead of recomputing.</span>
<span class="linecomment">;;    This is useful, for instance, for the candidate set of all files</span>
<span class="linecomment">;;    on your file system.  You can cache a set of candidates in</span>
<span class="linecomment">;;    either a variable (quickest, but not persistent) or a disk file</span>
<span class="linecomment">;;    (slower, persistent).</span>
<span class="linecomment">;;    See (@&gt; "Persistent Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Compute a large candidate set (and perhaps cache it or filter</span>
<span class="linecomment">;;    it) without displaying it in `*Completions*', by using `C-M-TAB'</span>
<span class="linecomment">;;    or `C-M-S-TAB' instead of `TAB' or `S-TAB', respectively.  These</span>
<span class="linecomment">;;    are bound to commands `icicle-prefix-complete-no-display' and</span>
<span class="linecomment">;;    `icicle-apropos-complete-no-display'.  For example, when</span>
<span class="linecomment">;;    initially computing the set of all files on your file system for</span>
<span class="linecomment">;;    `C-u M-x icicle-locate-file', use `C-M-S-TAB' to compute the</span>
<span class="linecomment">;;    set, then use `C-}' to save it to a cache file - you need never</span>
<span class="linecomment">;;    display it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (The documentation refers to the keys that do this as</span>
<span class="linecomment">;;    `C-M-S-TAB' and `C-M-TAB'.  Actually, this is only by default.</span>
<span class="linecomment">;;    You can customize this, using options</span>
<span class="linecomment">;;    `icicle-apropos-complete-no-display-keys' and</span>
<span class="linecomment">;;    `icicle-prefix-complete-no-display-keys'.)</span>
 
<span class="linecomment">;;(@* "History Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  History Enhancements</span>
<span class="linecomment">;;  --------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is about accessing and reusing previous input that</span>
<span class="linecomment">;;  you have typed in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "What Input, What History?")</span>
<span class="linecomment">;;  ** What Input, What History? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  First, what is meant by "input" and "input history"?  In vanilla</span>
<span class="linecomment">;;  Emacs and in this doc, "minibuffer history" and "input history"</span>
<span class="linecomment">;;  generally refer to input that you have typed (or cycled or</span>
<span class="linecomment">;;  completed) in the minibuffer and then entered using `RET' (or</span>
<span class="linecomment">;;  `S-RET').  Emacs provides different history lists for this,</span>
<span class="linecomment">;;  depending on the kind of input.  The most general such list is the</span>
<span class="linecomment">;;  value of variable `minibuffer-history'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But what about input that you type in the minibuffer (e.g. during</span>
<span class="linecomment">;;  completion) but that you do not enter with `RET'?  That is not</span>
<span class="linecomment">;;  recorded in any standard history list, so you cannot recall it</span>
<span class="linecomment">;;  using `M-p' and `M-n'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Icicles doc speaks ambiguously of "minibuffer input".  This</span>
<span class="linecomment">;;  always refers to something that you type in the minibuffer, but</span>
<span class="linecomment">;;  sometimes it means input that you enter with `RET' and sometimes</span>
<span class="linecomment">;;  it does not.  The context and the use of phrases such as "entered"</span>
<span class="linecomment">;;  and "entered with `RET'" should make clear what is meant.  Input</span>
<span class="linecomment">;;  that you type during completion but that you do not necessarily</span>
<span class="linecomment">;;  enter is sometimes referred to in the Icicles doc as "completion</span>
<span class="linecomment">;;  input".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because completion is so important to Icicles, because cycling</span>
<span class="linecomment">;;  replaces the input you type in the minibuffer, and because you</span>
<span class="linecomment">;;  sometimes need to retrieve such typed input that was never</span>
<span class="linecomment">;;  entered, Icicles also records this input.  You can retrieve it</span>
<span class="linecomment">;;  during completion using `C-l' (`icicle-retrieve-previous-input')</span>
<span class="linecomment">;;  and `C-S-l', that is, `C-L', (`icicle-retrieve-next-input').  Use</span>
<span class="linecomment">;;  these commands to cycle among your past completion inputs</span>
<span class="linecomment">;;  (backward and forward, respectively).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  User option `icicle-completion-history-max-length' limits the</span>
<span class="linecomment">;;  number of completion inputs to save.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you customize user option `icicle-C-l-uses-completion-flag' to</span>
<span class="linecomment">;;  non-`nil', then, instead of cycling, `C-l' lets you use Icicles</span>
<span class="linecomment">;;  completion to retrieve a past completion input (`C-L' does the</span>
<span class="linecomment">;;  same thing).  Using completion to retrieve a past input does not</span>
<span class="linecomment">;;  also choose that input as the candidate for the main completion;</span>
<span class="linecomment">;;  it just replaces your current minibuffer input with it.  Because</span>
<span class="linecomment">;;  `C-l' completion uses a recursive minibuffer, you can also use</span>
<span class="linecomment">;;  `C-g' to cancel this completion and return to the main completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can temporarily reverse the effect of</span>
<span class="linecomment">;;  `icicle-C-l-uses-completion-flag' by using a prefix argument</span>
<span class="linecomment">;;  (`C-u') with `C-l'.  Thus, `C-u C-l' uses completion if</span>
<span class="linecomment">;;  `icicle-C-l-uses-completion-flag' is `nil' and cycles if it is</span>
<span class="linecomment">;;  non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The other sections here describe Icicles enhancements for</span>
<span class="linecomment">;;  minibuffer histories.  They are thus concerned only with inputs</span>
<span class="linecomment">;;  that you enter, not with completion inputs that are not entered.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Overview of Minibuffer History Enhancements")</span>
<span class="linecomment">;;  ** Overview of Minibuffer History Enhancements **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances the minibuffer history in these independent ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Commands invoked using a menu-bar menu are included in the</span>
<span class="linecomment">;;     command history for `M-x'.  This helps you quickly find again</span>
<span class="linecomment">;;     and reuse a (possibly deep) menu item.  It lets you use</span>
<span class="linecomment">;;     completion to access such commands.  And it helps you learn the</span>
<span class="linecomment">;;     commands that correspond to menu items that you use, thus</span>
<span class="linecomment">;;     providing a missing bridge between menu use and minibuffer use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     If you do not want to include menu-item commands in the command</span>
<span class="linecomment">;;     history, then set option `icicle-menu-items-to-history-flag' to</span>
<span class="linecomment">;;     `nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     Note: Non-`nil' `icicle-menu-items-to-history-flag' simply</span>
<span class="linecomment">;;     makes Emacs handle menu items that you choose the same way that</span>
<span class="linecomment">;;     it handles commands that you enter using `RET'.  It does not</span>
<span class="linecomment">;;     add such menu items to your completion history, which you</span>
<span class="linecomment">;;     access using `C-l' (see (@&gt; "What Input, What History?"),</span>
<span class="linecomment">;;     above).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Command `icicle-insert-history-element' (bound to `M-o' in the</span>
<span class="linecomment">;;     minibuffer) lets you use (lax) completion to insert a history</span>
<span class="linecomment">;;     element in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Candidates displayed in `*Completions*' are highlighted using</span>
<span class="linecomment">;;     face `icicle-historical-candidate' (blue foreground, by</span>
<span class="linecomment">;;     default), when they have been used previously, so you can more</span>
<span class="linecomment">;;     easily recognize them.  This highlighting is controlled by</span>
<span class="linecomment">;;     option `icicle-highlight-historical-candidates-flag'.  You can</span>
<span class="linecomment">;;     toggle this from the minibuffer at any time using `C-pause'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Command `icicle-toggle-alternative-sorting', (`C-M-,' in the</span>
<span class="linecomment">;;     minibuffer) re-sorts completion candidates, placing previously</span>
<span class="linecomment">;;     used candidates first.  This is a toggle: repeat it to return</span>
<span class="linecomment">;;     to the original order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Command `icicle-keep-only-past-inputs' (`M-pause' in the</span>
<span class="linecomment">;;     minibuffer) restricts the current set of completion candidates</span>
<span class="linecomment">;;     to those that you have used previously.  In other words, it</span>
<span class="linecomment">;;     keeps only those candidates that are highlighted in blue.  To</span>
<span class="linecomment">;;     use `M-pause', you must first have used `TAB' or `S-TAB' to</span>
<span class="linecomment">;;     establish an explicit candidate set.  If you use `C-u M-pause',</span>
<span class="linecomment">;;     then the previously used candidates are ordered</span>
<span class="linecomment">;;     chronologically, most recent first.  Without `C-u', the normal</span>
<span class="linecomment">;;     sort order is used (`icicle-sort-comparer').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. Command `icicle-history' (`M-h' in the minibuffer) matches the</span>
<span class="linecomment">;;     current input against the minibuffer history directly.  It can</span>
<span class="linecomment">;;     be used during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7. Command `icicle-other-history' (`C-M-pause' in the minibuffer)</span>
<span class="linecomment">;;     lets you use a different history for the current completion.</span>
<span class="linecomment">;;     You can choose the history using completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  8. Commands `icicle-clear-history' and</span>
<span class="linecomment">;;     `icicle-clear-current-history' (`M-i' in the minibuffer)</span>
<span class="linecomment">;;     provide a general way to clean up histories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  9. When you cycle among previously entered inputs using `M-p' and</span>
<span class="linecomment">;;     `M-n', you can use `M-k' (command</span>
<span class="linecomment">;;     `icicle-erase-minibuffer-or-history-element') to delete the</span>
<span class="linecomment">;;     current occurrence from the history list.  This is a quick and</span>
<span class="linecomment">;;     handy way to clean up list entries that you are no longer</span>
<span class="linecomment">;;     interested in.  Only the occurrence that you have cycled to is</span>
<span class="linecomment">;;     deleted; if there are identical entries elsewhere in the</span>
<span class="linecomment">;;     history, they remain.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some of these enhancements are described below in more detail.</span>
<span class="linecomment">;;  Each of 1-7 lets you see the complete list of previous inputs that</span>
<span class="linecomment">;;  match your current input.  In vanilla Emacs, the history lists are</span>
<span class="linecomment">;;  never shown as such; you can access previous inputs only one at a</span>
<span class="linecomment">;;  time, in order (with `M-p').  In vanilla Emacs, you can use a</span>
<span class="linecomment">;;  regexp to search the history list (via `M-r'), but the regexp</span>
<span class="linecomment">;;  matching is not dynamic, and the first match found is the (only)</span>
<span class="linecomment">;;  one you get.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Displaying previous inputs that match the current input sounds</span>
<span class="linecomment">;;  like a minor advantage, but it is actually quite helpful in</span>
<span class="linecomment">;;  practice.  Among other things, it means that you can work with</span>
<span class="linecomment">;;  long history lists in a practical way.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Completion to Insert Previous Inputs: `M-o'")</span>
<span class="linecomment">;;  ** Using Completion to Insert Previous Inputs: `M-o' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Unlike the other minibuffer history enhancements, described below,</span>
<span class="linecomment">;;  which are available only during minibuffer completion, you can use</span>
<span class="linecomment">;;  `M-o' (`icicle-insert-history-element') anytime you are asked for</span>
<span class="linecomment">;;  minibuffer input.  It provides a recursive minibuffer in which you</span>
<span class="linecomment">;;  can match a previous input using completion.  After you hit `RET'</span>
<span class="linecomment">;;  to accept your choice, it is inserted in the minibuffer just as if</span>
<span class="linecomment">;;  you had typed it.  This is a form of on-demand completion</span>
<span class="linecomment">;;  (see (@&gt; "Completion On Demand"), and as such is always available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This has the advantage over cycling with `M-n' or `M-p' and</span>
<span class="linecomment">;;  searching with `M-s' or `M-r', that you can use Icicles completion</span>
<span class="linecomment">;;  and cycling to quickly access a previous input, no matter how long</span>
<span class="linecomment">;;  ago you entered it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When completion is available for reading input, if you use `M-o'</span>
<span class="linecomment">;;  to choose a previously entered input, this just inserts that input</span>
<span class="linecomment">;;  in the minibuffer.  What is in the minibuffer after you use `M-o'</span>
<span class="linecomment">;;  is not automatically chosen for the main completion - you can edit</span>
<span class="linecomment">;;  the minibuffer contents before entering it with `RET'.  You can</span>
<span class="linecomment">;;  also use `C-g' during the `M-o' completion to cancel it and return</span>
<span class="linecomment">;;  to the main completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;  ** Putting Previous Candidates First: `C-M-,' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  At any time, two of the Icicles sort orders are immediately</span>
<span class="linecomment">;;  available.  These are the values of user options</span>
<span class="linecomment">;;  `icicle-sort-comparer' and `icicle-alternative-sort-comparer'.  By</span>
<span class="linecomment">;;  default, the former usually sorts alphabetically, and the latter</span>
<span class="linecomment">;;  puts all previously used inputs first, before the candidates you</span>
<span class="linecomment">;;  have not yet used.  Each of these groups, used and unused</span>
<span class="linecomment">;;  candidates, is then sorted alphabetically, separately.  So, with</span>
<span class="linecomment">;;  the default alternative sort, you can see all matching candidates</span>
<span class="linecomment">;;  (used and unused), but you privilege those used previously - they</span>
<span class="linecomment">;;  are the first listed in `*Completions*' and the first available</span>
<span class="linecomment">;;  for cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you prefer, by customizing these user options, you can use</span>
<span class="linecomment">;;  `icicle-historical-alphabetic-p' as the main sort function (option</span>
<span class="linecomment">;;  `icicle-sort-comparer') and some other sort function</span>
<span class="linecomment">;;  (e.g. `icicle-case-string-less-p') as the alternative sort</span>
<span class="linecomment">;;  function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can toggle at any time between normal sorting and alternative</span>
<span class="linecomment">;;  sorting, using command `icicle-toggle-alternative-sorting'.</span>
<span class="linecomment">;;  During completion, this is bound to `C-M-,'.  Together with</span>
<span class="linecomment">;;  toggling between normal sorting and not sorting at all, which is a</span>
<span class="linecomment">;;  sort-order choice available through `C-,', this gives you quite a</span>
<span class="linecomment">;;  lot of flexibility.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Matching Only Historical Candidates: `M-h' and `M-pause'")</span>
<span class="linecomment">;;  ** Matching Only Historical Candidates: `M-h' and `M-pause' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Both `M-h' (`icicle-history') and `M-pause'</span>
<span class="linecomment">;;  (`icicle-keep-only-past-inputs') can be used toward the same end.</span>
<span class="linecomment">;;  They both work for all input types.  They both use the appropriate</span>
<span class="linecomment">;;  history list for the current command.  They both provide</span>
<span class="linecomment">;;  completion and cycling for the minibuffer history.  Use them as</span>
<span class="linecomment">;;  another way to search through a history list or complete to one of</span>
<span class="linecomment">;;  its elements.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, If you use `C-x C-f' to find a file, and then use</span>
<span class="linecomment">;;  `M-h' or `M-pause', the completion candidates will be the names of</span>
<span class="linecomment">;;  files that you have previously accessed (file names you have input</span>
<span class="linecomment">;;  in the minibuffer), and which match the current minibuffer input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `M-h' lets you complete your input against the minibuffer input</span>
<span class="linecomment">;;  history.  `M-pause' lets you restrict the current explicit set of</span>
<span class="linecomment">;;  completion candidates to those that are also in the minibuffer</span>
<span class="linecomment">;;  history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  They provide similar functionality in different ways.  The</span>
<span class="linecomment">;;  difference is that `M-pause' takes the current set of matching</span>
<span class="linecomment">;;  candidates into account.  It is a completion-candidates set</span>
<span class="linecomment">;;  operation, similar to those described in section</span>
<span class="linecomment">;;  (@&gt; "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This means, in particular, that with `M-pause' you can first</span>
<span class="linecomment">;;  perform set operations on the set of candidates, and then use that</span>
<span class="linecomment">;;  result to restrict the history search.  For example, you can first</span>
<span class="linecomment">;;  complement the candidate set using `C-~', then use `M-pause' to</span>
<span class="linecomment">;;  restrict those candidates to matches in the history list.  In this</span>
<span class="linecomment">;;  way, you avoid including matches from the original match set when</span>
<span class="linecomment">;;  searching the history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Example: You are in a directory with lots of files that have the</span>
<span class="linecomment">;;  prefix `foo' and lots of C-language source files.  You happen to</span>
<span class="linecomment">;;  be interested in another file, however.  One way to get to that</span>
<span class="linecomment">;;  file is to use Dired's ability to mark files by matching a regexp</span>
<span class="linecomment">;;  and then use Dired's ability to omit the marked files from view.</span>
<span class="linecomment">;;  You can scan through those that remain, and pick the one you want.</span>
<span class="linecomment">;;  However, it turns out that even then there are many files to scan.</span>
<span class="linecomment">;;  You accessed the one you want now just the other day, but the file</span>
<span class="linecomment">;;  date is unfortunately not significant.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you use regexp matching and take the set complement of</span>
<span class="linecomment">;;  the hits, just like in Dired: `C-x C-f foo.*\.c$' defines the</span>
<span class="linecomment">;;  candidate set as all files whose names start with `foo' and have</span>
<span class="linecomment">;;  extension `c'.  `C-~' then defines the candidate set as all files</span>
<span class="linecomment">;;  whose names are not like that.  Finally, you use `M-pause' to</span>
<span class="linecomment">;;  restrict the file-name candidates to names that you have used</span>
<span class="linecomment">;;  before.  You've accessed many, many files recently, so just</span>
<span class="linecomment">;;  cycling through the history with `M-p' would be tedious.  You</span>
<span class="linecomment">;;  could match a regexp against the file history, but how can you</span>
<span class="linecomment">;;  come up with a regexp that finds anti-matches?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A consequence of this difference between `M-h' and `M-pause' is</span>
<span class="linecomment">;;  that using `TAB' or `S-TAB' after `M-pause' abandons use of the</span>
<span class="linecomment">;;  minibuffer history and starts a new set of completion candidates.</span>
<span class="linecomment">;;  It simply completes the current input in the context of the</span>
<span class="linecomment">;;  current command; `TAB' and `S-TAB' have nothing to do with the</span>
<span class="linecomment">;;  minibuffer history in this case.  Using `TAB' or `S-TAB' after</span>
<span class="linecomment">;;  `M-h', however, re-completes your input against the current</span>
<span class="linecomment">;;  history list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another consequence is that you can use `down' or `C-down' on the</span>
<span class="linecomment">;;  candidates displayed by `M-h', but not on those displayed by</span>
<span class="linecomment">;;  `M-pause'.  For example, to cycle through the doc for each</span>
<span class="linecomment">;;  variable that starts with `icicle-' which you have previously</span>
<span class="linecomment">;;  input, you can use `C-h v icicle- M-h', then repeatedly use</span>
<span class="linecomment">;;  `C-down'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Also, file-name and directory-name completion works differently in</span>
<span class="linecomment">;;  these two commands.  By default, the current directory is (as</span>
<span class="linecomment">;;  always) inserted into the minibuffer by commands such as</span>
<span class="linecomment">;;  `find-file', so either `M-h' or `M-pause' after `C-x C-f' will</span>
<span class="linecomment">;;  match previously input file names from the current directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, in the case of `M-h', the entire minibuffer input is</span>
<span class="linecomment">;;  matched against the history list, which is a list of absolute file</span>
<span class="linecomment">;;  names.  `M-pause' works only with the current candidate set,</span>
<span class="linecomment">;;  which, if you have already used `TAB' or `S-TAB' in the current</span>
<span class="linecomment">;;  directory, is a set of relative file names in that directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This difference has a consequence for apropos (regexp) completion</span>
<span class="linecomment">;;  with `M-h'.  It means that to match a file name using a substring</span>
<span class="linecomment">;;  you must, in the minibuffer, either not specify a directory (erase</span>
<span class="linecomment">;;  it) or explicitly use `.*' before the file-name substring.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, with `M-h', `/foo/bar/lph' will not apropos-match the</span>
<span class="linecomment">;;  previously input file name `/foo/bar/alphabet-soup.el'; you should</span>
<span class="linecomment">;;  use either `/foo/bar/.*lph' or `lph' (no directory).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the case of `M-pause', however, the input is matched against</span>
<span class="linecomment">;;  the history list as restricted by the existing completion list.</span>
<span class="linecomment">;;  And, since apropos file-name completion uses only the relative</span>
<span class="linecomment">;;  file name, without the directory name, as a regexp, the candidate</span>
<span class="linecomment">;;  list that is restricted has already matched the input regexp.  The</span>
<span class="linecomment">;;  action of `M-pause' is simply to filter the list of candidates,</span>
<span class="linecomment">;;  keeping those that are in the history list.  This means that, with</span>
<span class="linecomment">;;  `M-pause', the input `/foo/bar/lph' will match against the</span>
<span class="linecomment">;;  previously input file name `/foo/bar/alphabet-soup.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that neither `M-h' nor `M-pause' uses a recursive minibuffer;</span>
<span class="linecomment">;;  they each simply co-opt the current completion, changing it to</span>
<span class="linecomment">;;  completion against the history.  This means that whatever</span>
<span class="linecomment">;;  completion mode (prefix or apropos) was in effect before you use</span>
<span class="linecomment">;;  `M-h' or `M-pause' remains in effect for the history completion as</span>
<span class="linecomment">;;  well.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If this all sounds confusing, just give it a try; it is much</span>
<span class="linecomment">;;  harder to describe than it is to experience.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Other Histories; Commands Any Which Way")</span>
<span class="linecomment">;;  ** Using Other Histories; Commands Any Which Way **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section describes how to complete your input against a</span>
<span class="linecomment">;;  history other than the default history provided for the current</span>
<span class="linecomment">;;  command.  A special case of this, starting with Emacs 23, is</span>
<span class="linecomment">;;  completing a command, abbrev, or keyboard macro name against all</span>
<span class="linecomment">;;  such that were previously executed in any interactive way.  This</span>
<span class="linecomment">;;  includes commands invoked using a menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completing Against All Interactive Commands")</span>
<span class="linecomment">;;  *** Completing Against All Interactive Commands ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you execute a command using `M-x', it is added to the history</span>
<span class="linecomment">;;  `extended-command-history'.  Likewise, when you execute a command</span>
<span class="linecomment">;;  or abbrev using `icicle-command-abbrev-command'.  And when you</span>
<span class="linecomment">;;  execute a keyboard macro using `C-x M-e'</span>
<span class="linecomment">;;  (`icicle-execute-named-keyboard-macro'), it is added to history</span>
<span class="linecomment">;;  `icicle-kmacro-history'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, when you execute a command, abbrev, or keyboard macro in</span>
<span class="linecomment">;;  other ways than these, it is not added to such a history.  For</span>
<span class="linecomment">;;  example, if you choose a menu item, the associated command is not</span>
<span class="linecomment">;;  added to any of these histories.  Thus, although `M-o' lets you</span>
<span class="linecomment">;;  complete against previously used commands, this does not include</span>
<span class="linecomment">;;  commands that were called via a menu item.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To remedy this, starting with Emacs 23 Icicles can optionally add</span>
<span class="linecomment">;;  all commands that are called using `call-interactively' to the</span>
<span class="linecomment">;;  larger command history `icicle-interactive-history'.  This</span>
<span class="linecomment">;;  includes commands on menus.  To enable this feature, you must</span>
<span class="linecomment">;;  customize option `icicle-populate-interactive-history-flag', to</span>
<span class="linecomment">;;  make it non-`nil'.  Thereafter, when you enter Icicle mode, all</span>
<span class="linecomment">;;  interactive use of commands records them on this special history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During completion, you can then use `C-M-pause'</span>
<span class="linecomment">;;  (`icicle-other-history') to complete against this extended set of</span>
<span class="linecomment">;;  previously used commands.  For example, if you use menu item `Open</span>
<span class="linecomment">;;  File', then the corresponding command, `menu-find-file-existing',</span>
<span class="linecomment">;;  becomes available as a completion candidate.  (Recall too that the</span>
<span class="linecomment">;;  command associated with a given menu item is shown in the</span>
<span class="linecomment">;;  `*Completions*' mode line whenever you cycle to it.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Be aware that use of this feature can slow Emacs down, and the</span>
<span class="linecomment">;;  history list can become quite large.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using an Alternative History")</span>
<span class="linecomment">;;  *** Using an Alternative History ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you are completing something other than a command, abbrev, or</span>
<span class="linecomment">;;  keyboard macro (or even when you complete one of those, if you use</span>
<span class="linecomment">;;  a prefix argument), `C-M-pause' prompts you for an alternative</span>
<span class="linecomment">;;  history to use - any history you like.  You can choose the history</span>
<span class="linecomment">;;  using completion.  This does not automatically complete your</span>
<span class="linecomment">;;  current input against the history you choose; it simply changes</span>
<span class="linecomment">;;  the current history for the duration of the current minibuffer</span>
<span class="linecomment">;;  completion.  (You can use `M-h', as usual, if you want to complete</span>
<span class="linecomment">;;  against the chosen history.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Cleaning Up History Lists")</span>
<span class="linecomment">;;  ** Cleaning Up History Lists **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Besides the use of `M-k' during history cycling (`M-p', `M-n') to</span>
<span class="linecomment">;;  remove individual input occurrences from the current history list,</span>
<span class="linecomment">;;  you can use commands `icicle-clear-history' and</span>
<span class="linecomment">;;  `icicle-clear-current-history' to clean minibuffer histories</span>
<span class="linecomment">;;  entirely of selected entries.  Command</span>
<span class="linecomment">;;  `icicle-clear-current-history' is bound to `M-i' in the</span>
<span class="linecomment">;;  minibuffer.  It is `icicle-clear-history' specialized to work on</span>
<span class="linecomment">;;  just the current history list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These commands prompt you for a history entry to delete from a</span>
<span class="linecomment">;;  history list.  These are multi-commands, so you can delete</span>
<span class="linecomment">;;  multiple entries.  For each entry you choose, all of its</span>
<span class="linecomment">;;  occurrences are deleted from the history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-clear-history' first prompts you for a history</span>
<span class="linecomment">;;  list to act on.  This too is multi-command input, so you can use</span>
<span class="linecomment">;;  `icicle-clear-history' to remove entries from multiple histories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use a prefix argument with these commands, then the</span>
<span class="linecomment">;;  histories are emptied entirely (upon confirmation).  Thus, for</span>
<span class="linecomment">;;  instance, you can use `C-u M-i' at any time during minibuffer</span>
<span class="linecomment">;;  input to completely empty the current history list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "More about Multi-Commands") for information about</span>
<span class="linecomment">;;  using `S-delete' to delete objects associated with completion</span>
<span class="linecomment">;;  candidates.</span>
 
<span class="linecomment">;;(@* "Isearch Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Isearch Enhancements</span>
<span class="linecomment">;;  --------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides two different enhancements for searching:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - Icicles search: Top-level Icicles commands that provide an</span>
<span class="linecomment">;;    entirely new and different way for you to search.</span>
<span class="linecomment">;;    This is described in section</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - Extensions to standard Emacs incremental search, Isearch.</span>
<span class="linecomment">;;    These are described in this section.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    * Search string completion against previous search strings.</span>
<span class="linecomment">;;    * Occur mode interface for Isearch hits.</span>
<span class="linecomment">;;    * Icicles search (`icicle-search') interface, reusing the</span>
<span class="linecomment">;;      Isearch search string (by default).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc2.el" :to "Support for Projects")</span>
<span class="linecomment">;;    for information about using `grep' to search all of the files in</span>
<span class="linecomment">;;    a project.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Isearch Completion Against the Search History")</span>
<span class="linecomment">;;  ** Isearch Completion Against the Search History **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you search incrementally (`C-s'), Emacs lets you use `M-TAB'</span>
<span class="linecomment">;;  (aka `C-M-i', aka `ESC-TAB') to complete your input to a string</span>
<span class="linecomment">;;  that you have sought previously, that is, a string in the current</span>
<span class="linecomment">;;  search history (`search-ring' or `regexp-search-ring').  In Icicle</span>
<span class="linecomment">;;  mode, this feature is enhanced so that you can use all of the</span>
<span class="linecomment">;;  completion enhancements provided by Icicles: `M-TAB' is bound to</span>
<span class="linecomment">;;  `icicle-isearch-complete' during Isearch.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some operating systems grab `M-TAB' for their own use, making it</span>
<span class="linecomment">;;  unavailable for Emacs.  They normally do not grab `ESC TAB', which</span>
<span class="linecomment">;;  in Emacs is typically the same ase `M-TAB'.  For this reason,</span>
<span class="linecomment">;;  Icicles also binds `icicle-isearch-complete' to both `ESC TAB' and</span>
<span class="linecomment">;;  `C-M-TAB'.  (Note: For MS Windows, you can use</span>
<span class="linecomment">;;  (w32-register-hot-key [M-tab]) to allow Emacs to use `M-TAB'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles users are in the habit of using `M-o' to complete the</span>
<span class="linecomment">;;  current minibuffer input against previously entered inputs.</span>
<span class="linecomment">;;  Because of the similarity, you can likewise use `M-o' during</span>
<span class="linecomment">;;  Isearch to complete the current search string: `M-o' is equivalent</span>
<span class="linecomment">;;  to `M-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The keys bound by default to `icicle-isearch-complete' in</span>
<span class="linecomment">;;  `isearch-mode-map' are thus `M-TAB', `ESC TAB', `C-M-TAB', and</span>
<span class="linecomment">;;  `M-o'.  But you can change the keys to use for this by customizing</span>
<span class="linecomment">;;  option `icicle-isearch-complete-keys'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `M-o' (or `M-TAB') while searching, Isearch exits</span>
<span class="linecomment">;;  momentarily, giving way to Icicles completion in the minibuffer</span>
<span class="linecomment">;;  (Isearch actually uses the echo area, not the minibuffer).  You</span>
<span class="linecomment">;;  can then use either `S-TAB' or `TAB' to complete your search</span>
<span class="linecomment">;;  string.  After you finish completing (e.g. by hitting `RET'),</span>
<span class="linecomment">;;  Isearch resumes with the new, completed search string.  It's</span>
<span class="linecomment">;;  pretty seamless, and easier to try than to describe.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Reminder: Using `S-TAB' vs `TAB' for regexp vs non-regexp</span>
<span class="linecomment">;;  completion against previous search strings has nothing to do with</span>
<span class="linecomment">;;  regexp vs non-regexp searching.  You can of course use either kind</span>
<span class="linecomment">;;  of searching before or after having used either kind of</span>
<span class="linecomment">;;  completion.  Isearch uses different search rings for regexp and</span>
<span class="linecomment">;;  non-regexp searching.  The kind of search in progress (regexp or</span>
<span class="linecomment">;;  not) at the moment you ask Isearch for completion determines which</span>
<span class="linecomment">;;  search ring provides the candidates for completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Launch Occur using the Isearch Search String")</span>
<span class="linecomment">;;  ** Launch Occur using the Isearch Search String **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use library `color-moccur.el' or library</span>
<span class="linecomment">;;  `occur-schroeder.el', then `C-o' is bound during Isearch to</span>
<span class="linecomment">;;  `isearch-moccur', which provides an Occur buffer interface for</span>
<span class="linecomment">;;  search hits.  This has nothing per se to do with Icicles, but you</span>
<span class="linecomment">;;  might find it useful.  (Library `color-moccur.el' itself binds</span>
<span class="linecomment">;;  `M-o' for this, but `M-o' is used in Icicles for search-string</span>
<span class="linecomment">;;  completion.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Launch Icicles Search using the Isearch Search String")</span>
<span class="linecomment">;;  ** Launch Icicles Search using the Isearch Search String **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles search is described in section</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc2.el" :to "Icicles Search Commands, Overview").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can start Icicles search from Isearch: Hit `S-TAB' to choose</span>
<span class="linecomment">;;  the Icicles search initial regexp - the default value is the</span>
<span class="linecomment">;;  current Isearch search string, but you can edit that.  Completion</span>
<span class="linecomment">;;  is available for your input - completion against your previous</span>
<span class="linecomment">;;  Isearch regexp search strings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, use `C-s C-w C-w S-TAB' to pick up the next two words</span>
<span class="linecomment">;;  at the cursor, then type `.*' before and after them and hit `RET'.</span>
<span class="linecomment">;;  That puts you in Icicles search with the completion candidates</span>
<span class="linecomment">;;  being all of the lines in the buffer that contain that two-word</span>
<span class="linecomment">;;  phrase.  Type some more text to narrow the candidate lines to</span>
<span class="linecomment">;;  those that match what you type.  Then use `C-next' to visit search</span>
<span class="linecomment">;;  hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The key to initiate Icicles search from Isearch is `S-TAB' only by</span>
<span class="linecomment">;;  default.  You can change this key by customizing option</span>
<span class="linecomment">;;  `icicle-search-from-isearch-keys'.</span>
 
<span class="linecomment">;;  The Icicles doc is continued in file `icicles-doc2.el'.</span>
 
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; This program is free software; you can redistribute it and/or</span>
<span class="linecomment">;; modify it under the terms of the GNU General Public License as</span>
<span class="linecomment">;; published by the Free Software Foundation; either version 2, or (at</span>
<span class="linecomment">;; your option) any later version.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; This program is distributed in the hope that it will be useful,</span>
<span class="linecomment">;; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="linecomment">;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="linecomment">;; GNU General Public License for more details.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; You should have received a copy of the GNU General Public License</span>
<span class="linecomment">;; along with this program; see the file COPYING.  If not, write to</span>
<span class="linecomment">;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth</span>
<span class="linecomment">;; Floor, Boston, MA 02110-1301, USA.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;; Code:</span>

<span class="linecomment">;; You need not load this file.  It contains only documentation.</span>

(provide 'icicles-doc1)

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; icicles-doc1.el ends here</span></span></pre></div><div class="wrapper close"></div></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span><span class="translation bar"><br />  <a class="translation new" rel="nofollow" href="http://www.emacswiki.org/emacs?action=translate;id=icicles-doc1.el;missing=de_es_fr_it_ja_ko_pt_ru_se_zh">Add Translation</a></span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" rel="nofollow" href="http://www.emacswiki.org/emacs?action=edit;id=icicles-doc1.el">Edit this page</a> <a class="history" rel="nofollow" href="http://www.emacswiki.org/emacs?action=history;id=icicles-doc1.el">View other revisions</a> <a class="admin" rel="nofollow" href="http://www.emacswiki.org/emacs?action=admin;id=icicles-doc1.el">Administration</a></span><span class="time"><br /> Last edited 2011-06-03 23:00 UTC by <a class="author" title="from 148.87.67.196" href="http://www.emacswiki.org/emacs/DrewAdams">DrewAdams</a> <a class="diff" rel="nofollow" href="http://www.emacswiki.org/emacs?action=browse;diff=2;id=icicles-doc1.el">(diff)</a></span><div style="float:right; margin-left:1ex;">
<!-- Creative Commons License -->
<a href="http://creativecommons.org/licenses/GPL/2.0/"><img alt="CC-GNU GPL" style="border:none" src="/pics/cc-GPL-a.png" /></a>
<!-- /Creative Commons License -->
</div>

<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <license rdf:resource="http://creativecommons.org/licenses/GPL/2.0/" />
  <dc:type rdf:resource="http://purl.org/dc/dcmitype/Software" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/GPL/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
   <requires rdf:resource="http://web.resource.org/cc/SourceCode" />
</License>
</rdf:RDF>
-->

<p class="legal">
This work is licensed to you under version 2 of the
<a href="http://www.gnu.org/">GNU</a> <a href="/GPL">General Public License</a>.
Alternatively, you may choose to receive this work under any other
license that grants the right to use, copy, modify, and/or distribute
the work, as long as that license imposes the restriction that
derivative works have to grant the same rights and impose the same
restriction. For example, you may choose to receive this work under
the
<a href="http://www.gnu.org/">GNU</a>
<a href="/FDL">Free Documentation License</a>, the
<a href="http://creativecommons.org/">CreativeCommons</a>
<a href="http://creativecommons.org/licenses/sa/1.0/">ShareAlike</a>
License, the XEmacs manual license, or
<a href="/OLD">similar licenses</a>.
</p>
</div>
</body>
</html>
