<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>EmacsWiki: icicles-doc2.el</title><link rel="alternate" type="application/wiki" title="Edit this page" href="http://www.emacswiki.org/emacs?action=edit;id=icicles-doc2.el" /><link type="text/css" rel="stylesheet" href="/emacs/wiki.css" /><meta name="robots" content="INDEX,FOLLOW" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki" href="http://www.emacswiki.org/emacs?action=rss" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki: icicles-doc2.el" href="http://www.emacswiki.org/emacs?action=rss;rcidonly=icicles-doc2.el" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content"
      href="http://www.emacswiki.org/emacs/full.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content and diff"
      href="http://www.emacswiki.org/emacs/full-diff.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki including minor differences"
      href="http://www.emacswiki.org/emacs/minor-edits.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Changes for icicles-doc2.el only"
      href="http://www.emacswiki.org/emacs?action=rss;rcidonly=icicles-doc2.el" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2101513-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body class="http://www.emacswiki.org/emacs"><div class="header"><a class="logo" href="http://www.emacswiki.org/emacs/SiteMap"><img class="logo" src="/emacs_logo.png" alt="[Home]" /></a><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span>
<!-- Google CSE Search Box Begins  -->
<form class="tiny" action="http://www.google.com/cse" id="searchbox_004774160799092323420:6-ff2s0o6yi"><p>
<input type="hidden" name="cx" value="004774160799092323420:6-ff2s0o6yi" />
<input type="text" name="q" size="25" />
<input type="submit" name="sa" value="Search" />
</p></form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=searchbox_004774160799092323420%3A6-ff2s0o6yi"></script>
<!-- Google CSE Search Box Ends -->
<h1><a title="Click to search for references to this page" rel="nofollow" href="http://www.google.com/cse?cx=004774160799092323420:6-ff2s0o6yi&amp;q=%22icicles-doc2.el%22">icicles-doc2.el</a></h1></div><div class="wrapper"><div class="content browse"><p class="download"><a href="http://www.emacswiki.org/emacs/download/icicles-doc2.el">Download</a></p><pre class="code"><span class="linecomment">;;; icicles-doc2.el --- Minibuffer input completion and cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Filename: icicles-doc2.el</span>
<span class="linecomment">;; Description: Minibuffer completion and cycling.</span>
<span class="linecomment">;; Author: Drew Adams</span>
<span class="linecomment">;; Maintainer: Drew Adams</span>
<span class="linecomment">;; Copyright (C) 1996-2011, Drew Adams, all rights reserved.</span>
<span class="linecomment">;; Created: Tue Aug  1 14:21:16 1995</span>
<span class="linecomment">;; Version: 22.0</span>
<span class="linecomment">;; Last-Updated: Fri Jun  3 16:07:37 2011 (-0700)</span>
<span class="linecomment">;;           By: dradams</span>
<span class="linecomment">;;     Update #: 28035</span>
<span class="linecomment">;; URL: http://www.emacswiki.org/cgi-bin/wiki/icicles-doc2.el</span>
<span class="linecomment">;; Keywords: internal, extensions, help, abbrev, local, minibuffer,</span>
<span class="linecomment">;;           keys, apropos, completion, matching, regexp, command</span>
<span class="linecomment">;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; Features that might be required by this library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   None</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;; Commentary:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles documentation, part 2.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Files `icicles-doc1.el' and `icicles-doc2.el' contain the doc for</span>
<span class="linecomment">;;  Icicles, including how to install and use Icicles.  You can also</span>
<span class="linecomment">;;  read the Icicles doc, in formatted form, on the Emacs-Wiki Web</span>
<span class="linecomment">;;  site: http://www.emacswiki.org/cgi-bin/wiki/Icicles.  Emacs Wiki</span>
<span class="linecomment">;;  also has a few addtional pages about Icicles.  In particular, if</span>
<span class="linecomment">;;  you are new to Emacs, as well as Icicles, see this page:</span>
<span class="linecomment">;;  http://www.emacswiki.org/cgi-bin/wiki/EmacsNewbieWithIcicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This file continues the Icicles documentation, which starts in</span>
<span class="linecomment">;;  file `icicles-doc1.el'.</span>
 
<span class="linecomment">;;(@* "Index")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Index</span>
<span class="linecomment">;;  -----</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you have library `linkd.el' and Emacs 22 or later, load</span>
<span class="linecomment">;;  `linkd.el' and turn on `linkd-mode' now.  It lets you easily</span>
<span class="linecomment">;;  navigate around the sections of this doc.  Linkd mode will</span>
<span class="linecomment">;;  highlight this Index and render it more readable.  Likewise, for</span>
<span class="linecomment">;;  the cross-references and section headings throughout this file.</span>
<span class="linecomment">;;  You can get `linkd.el' here:</span>
<span class="linecomment">;;  http://www.emacswiki.org/cgi-bin/wiki/linkd.el.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Documentation in File `icicles-doc1.el'")</span>
<span class="linecomment">;;  -----------------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Nutshell View of Icicles")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "README for Non-Readers")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Toggle Options on the Fly")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Cycle Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Display Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Prefix Completion and Apropos Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Chains of Simple Match Patterns - Progressive Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Choose Before You Act")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Help on Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Perform Multiple Operations in One Command")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Perform Alternative Operations on the Fly")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completion Status Indicators")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icicles Search")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Complete Key Sequences Too")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Available for Almost Any Input")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Component Icicles Libraries")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "If You Are an Emacs-Lisp Programmer")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Inserting Text Found Near the Cursor")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Background on Vanilla Emacs Input Completion")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Cycling Completions")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Traversing Minibuffer Histories")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Apropos Completions")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Expanded-Common-Match Completion")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "`M-*': Matching Additional Regexps")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Successive Approximation...")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "`M-&': Satisfying Additional Predicates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Regressive Completion")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Completion On Demand")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Moving Between the Minibuffer and Other Buffers")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Inserting a Regexp from a Variable or Register")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Special Characters in Input Patterns")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Alternative Libraries: Other Methods of Choosing Default Values")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Exiting the Minibuffer Without Confirmation")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "*Completions* Display")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icompletion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "icomplete+.el Displays the Number of Other Prefix Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icicles Highlights the Input that Won't Complete")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icompletion in *Completions*: Apropos and Prefix Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Changing the Sort Order")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Defining New Sort Orders")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Different Sorts for Different Sorts of Uses")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Get Help on Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Use Candidate Help Like You Use Emacs Command `apropos'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Other Icicles Apropos Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What Is a Multi-Command?")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "How Does a Multi-Command Work?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "More about Multi-Commands")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Alternative Actions")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Deleting Objects")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Accessing Saved Locations (Bookmarks) on the Fly")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icicles Tripping")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Highlighting the Destination")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Key Completion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completing Keys")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "`S-TAB' Is Everywhere - Start With It")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completing Keys By Name")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completing Prefix Keys")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Meta Key Bindings")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Navigate the Key-Binding Hierarchy")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Local Bindings Are Highlighted")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Completing Keys By Just Hitting Them")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Key and Command Help")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "`S-TAB' Is a Multi-Command")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Possible Source of Confusion")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Three-Key Emacs")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Entering Special and Foreign Characters")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Handling Keymaps That Are Inaccessible From the Global Map")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icicles Multi `M-x'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Examples of Using Multi `M-x'")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc1.el" :to "What about describe-variable and describe-function?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Multi `M-x' Turns Every Command into a Multi-Command")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Choose All Completion Candidates")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Saving and Retrieving Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Different Places for Saving and Retrieving Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Set Operations")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Google Matching")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Domain of Discourse")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Global Filtering")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Word Matching and String Matching")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "AND Matching and OR Matching")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "NOT Matching")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Buffer-Name Input")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Function `read-file-name'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Function `completing-read'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icicles Commands that Read File Names")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Absolute File Names and Different Directories")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Saving Candidates in Cache Files")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Filesets and Icicles Saved Completion Sets")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Improving Performance with Persistent Sets")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc1.el" :to "Avoid Remote File-Name Completion")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc1.el" :to "Avoid Generating A Large Completion Set")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "History Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What Input, What History?")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Overview of Minibuffer History Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Using Completion to Insert Previous Inputs: `M-o'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Putting Previous Candidates First: `C-M-,'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Matching Only Historical Candidates: `M-h' and `M-pause'")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Using Other Histories; Commands Any Which Way")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc1.el" :to "Completing Against All Interactive Commands")</span>
<span class="linecomment">;;      (@file :file-name "icicles-doc1.el" :to "Using an Alternative History")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Cleaning Up History Lists")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Isearch Enhancements")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Launch Occur using the Isearch Search String")</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Launch Icicles Search using the Isearch Search String")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@* "Documentation in File `icicles-doc2.el'")</span>
<span class="linecomment">;;  ----------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;    (@&gt; "Introduction: On Beyond Occur...")</span>
<span class="linecomment">;;    (@&gt; "How Icicles Search Works")</span>
<span class="linecomment">;;    (@&gt; "Why Use 2 Search Patterns?")</span>
<span class="linecomment">;;    (@&gt; "Search Multiple Buffers, Files, and Bookmarks")</span>
<span class="linecomment">;;    (@&gt; "User Options for Icicles Searching")</span>
<span class="linecomment">;;    (@&gt; "Using Regexps with Icicles Search")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Search and Replace")</span>
<span class="linecomment">;;  (@&gt; "Other Icicles Search Commands")</span>
<span class="linecomment">;;    (@&gt; "Icicles Imenu")</span>
<span class="linecomment">;;      (@&gt; "`icicle-imenu' Combines Benefits of Imenu and Emacs Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (@&gt; "Compile/Grep Search")</span>
<span class="linecomment">;;    (@&gt; "Input Reuse in Interactive Interpreter Modes")</span>
<span class="linecomment">;;    (@&gt; "Define Your Own Icicles Search Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Bookmark Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Saving Regions and Selecting Them")</span>
<span class="linecomment">;;    (@&gt; "Setting a Bookmark and Jumping to a Bookmark")</span>
<span class="linecomment">;;    (@&gt; "Jumping to a Bookmark")</span>
<span class="linecomment">;;    (@&gt; "Searching Bookmarked Objects")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Enhancements for Emacs Tags")</span>
<span class="linecomment">;;    (@&gt; "`icicle-find-tag': Find Tags in All Tags Tables")</span>
<span class="linecomment">;;    (@&gt; "`icicle-find-first-tag': Find First Tag in Current Table")</span>
<span class="linecomment">;;    (@&gt; "`icicle-tags-search': Search and Replace Using Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Shell-Command Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Shell Command Completion as File-Name Completion")</span>
<span class="linecomment">;;    (@&gt; "Gotcha: `$' in Shell Commands")</span>
<span class="linecomment">;;    (@&gt; "Known Shell Commands as Proxy Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Dired Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Search-and-Replace Marked Files")</span>
<span class="linecomment">;;    (@&gt; "Save Marked Files as Completion Candidates")</span>
<span class="linecomment">;;    (@&gt; "Open Dired for a Set of File Names")</span>
<span class="linecomment">;;    (@&gt; "Marked Files as a Project")</span>
<span class="linecomment">;;    (@&gt; "Shell Commands on Marked Files")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Info Enhancements")</span>
<span class="linecomment">;;    (@&gt; "Icicles Completion for Info")</span>
<span class="linecomment">;;      (@&gt; "Virtual Info Books")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (@&gt; "Using Icicle-Search With Info")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Support for Projects")</span>
<span class="linecomment">;;    (@&gt; "Bookmarks for Project Access and Organization")</span>
<span class="linecomment">;;    (@&gt; "A Tags File Can Define a Project")</span>
<span class="linecomment">;;    (@&gt; "Navigating Among Code Definitions")</span>
<span class="linecomment">;;    (@&gt; "Searching Project Files")</span>
<span class="linecomment">;;    (@&gt; "Defining and Saving Sets of Files or Buffers")</span>
<span class="linecomment">;;    (@&gt; "Retrieving and Reusing a Saved Project")</span>
<span class="linecomment">;;    (@&gt; "Semantics? Roll Your Own?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Using Complex Completion Candidates")</span>
<span class="linecomment">;;  (@&gt; "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;    (@&gt; "Apropos Completion as OO")</span>
<span class="linecomment">;;    (@&gt; "M-RET")</span>
<span class="linecomment">;;    (@&gt; "`icicle-object-action' and `icicle-anything'")</span>
<span class="linecomment">;;    (@&gt; "Icicles with Anything")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Multi-Completions")</span>
<span class="linecomment">;;    (@&gt; "Icicles Multi-Completion Commands")</span>
<span class="linecomment">;;    (@&gt; "How Multi-Completions Work")</span>
<span class="linecomment">;;    (@&gt; "Multi-Completions vs `completing-read-multiple'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Dot, Dot, Dot")</span>
<span class="linecomment">;;  (@&gt; "Fuzzy Completion")</span>
<span class="linecomment">;;    (@&gt; "Partial Completion")</span>
<span class="linecomment">;;    (@&gt; "Scatter-Match Completion")</span>
<span class="linecomment">;;    (@&gt; "Swank (Fuzzy Symbol) Completion")</span>
<span class="linecomment">;;    (@&gt; "Fuzzy-Match Completion")</span>
<span class="linecomment">;;    (@&gt; "Levenshtein Completion")</span>
<span class="linecomment">;;    (@&gt; "Jaro-Winkler Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Completion in Other Buffers")</span>
<span class="linecomment">;;    (@&gt; "Dynamic Abbreviation")</span>
<span class="linecomment">;;    (@&gt; "BBDB Completion")</span>
<span class="linecomment">;;    (@&gt; "Thesaurus Completion")</span>
<span class="linecomment">;;    (@&gt; "Completion in Comint Modes")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Customization and General Tips")</span>
<span class="linecomment">;;    (@&gt; "Using Icicles with Delete Selection Mode")</span>
<span class="linecomment">;;    (@&gt; "Icicles User Options and Faces")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "File-Name and Directory-Name Completion Tips")</span>
<span class="linecomment">;;  (@&gt; "Key Bindings")</span>
<span class="linecomment">;;    (@&gt; "Global Bindings")</span>
<span class="linecomment">;;    (@&gt; "Icicles-Mode Bindings")</span>
<span class="linecomment">;;    (@&gt; "Minibuffer Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Customizing Key Bindings")</span>
<span class="linecomment">;;    (@&gt; "Customizing Global Bindings")</span>
<span class="linecomment">;;    (@&gt; "Customizing Icicle Mode Bindings")</span>
<span class="linecomment">;;    (@&gt; "Customizing Minibuffer Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Icicles Redefines Some Standard Functions")</span>
<span class="linecomment">;;  (@&gt; "Programming with Fancy Candidates")</span>
<span class="linecomment">;;  (@&gt; "Programming Multi-Completions")</span>
<span class="linecomment">;;    (@&gt; "Variable icicle-list-use-nth-parts")</span>
<span class="linecomment">;;    (@&gt; "Variable icicle-candidate-properties-alist")</span>
<span class="linecomment">;;    (@&gt; "What You See Is Not What You Get")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Candidates with Text Properties")</span>
<span class="linecomment">;;    (@&gt; "Using Property icicle-special-candidate")</span>
<span class="linecomment">;;    (@&gt; "Applying Text Properties to a Candidate String")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;    (@&gt; "Nothing To It!")</span>
<span class="linecomment">;;    (@&gt; "Multi-Commands Are Easy To Define Too")</span>
<span class="linecomment">;;    (@&gt; "Are Users Dependent on Icicles To Use Multi-Commands?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Defining Icicles Tripping Commands")</span>
<span class="linecomment">;;  (@&gt; "Defining Multiple-Choice Menus")</span>
<span class="linecomment">;;  (@&gt; "Defining Icicles Multi `M-x'")</span>
<span class="linecomment">;;    (@&gt; "How Multi `M-x' is Defined")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@&gt; "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;  (@&gt; "Global Filters")</span>
<span class="linecomment">;;  (@&gt; "Specifying Match Functions for Commands")</span>
<span class="linecomment">;;  (@&gt; "Defining Buffer-Text Completion for Comint Modes")</span>
<span class="linecomment">;;  (@&gt; "Note to Programmers")</span>
<span class="linecomment">;;  (@&gt; "La Petite Histoire")</span>
<span class="linecomment">;;  (@&gt; "Note on Non-`nil' `pop-up-frames' on MS Windows")</span>
 
<span class="linecomment">;;(@* "Icicles Search Commands, Overview")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Search Commands, Overview</span>
<span class="linecomment">;;  ---------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section provides an overview of Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The doc string (`C-h f') of command `icicle-search'; it provides</span>
<span class="linecomment">;;    a boatload of general information about Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Other Icicles Search Commands") for specialized Icicles</span>
<span class="linecomment">;;    search commands, including search in particular buffers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Info Enhancements") for information about using</span>
<span class="linecomment">;;    Icicles to search in Info mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Bookmark Enhancements") for information about</span>
<span class="linecomment">;;    searching bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Support for Projects") for information about using `grep'</span>
<span class="linecomment">;;    to search all of the files in a project.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Introduction: On Beyond Occur...")</span>
<span class="linecomment">;;  ** Introduction: On Beyond Occur... **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You've no doubt used standard Emacs command `occur'.  It finds all</span>
<span class="linecomment">;;  lines in a buffer that match a regexp that you enter.  It displays</span>
<span class="linecomment">;;  the matching lines as links in buffer `*Occur*' - you can click a</span>
<span class="linecomment">;;  link to navigate to the corresponding line in the original buffer.</span>
<span class="linecomment">;;  Using buffer `*Occur*' is similar to using the output of the Emacs</span>
<span class="linecomment">;;  `grep' command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-occur' is similar to `occur', but instead of</span>
<span class="linecomment">;;  entering a regexp (with `RET') you type a regexp and then use</span>
<span class="linecomment">;;  `S-TAB' to show the matching lines in buffer `*Completions*'.  As</span>
<span class="linecomment">;;  usual in Icicles, you can complete to a single candidate, or cycle</span>
<span class="linecomment">;;  among candidates to choose one.  To navigate to a match in the</span>
<span class="linecomment">;;  original buffer, use `C-RET', `C-mouse-2', `C-next', or `C-prior'.</span>
<span class="linecomment">;;  One advantage of `icicle-occur' over `occur' is that you can</span>
<span class="linecomment">;;  change the regexp on the fly to match different sets of lines.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another, major advantage is that you can use progressive</span>
<span class="linecomment">;;  completion to find lines that match multiple regexps.  A similar,</span>
<span class="linecomment">;;  but less interactive, effect can be had using chained `grep'</span>
<span class="linecomment">;;  commands, but it is otherwise not possible with other search</span>
<span class="linecomment">;;  methods such as regexp Isearch.  A regexp simply cannot express</span>
<span class="linecomment">;;  intersection ("and") except in the limited form of "followed by".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-search' is a generalization of `icicle-occur'.</span>
<span class="linecomment">;;  You enter an initial, search-context regexp (using `RET'), which</span>
<span class="linecomment">;;  defines a set of completion candidates: all of the matching</span>
<span class="linecomment">;;  strings in the current buffer (by default).  These candidates are</span>
<span class="linecomment">;;  called "search contexts".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-occur' is really `icicle-search' with an implicit</span>
<span class="linecomment">;;  initial regexp of `.*' (which you do not enter, however).  That</span>
<span class="linecomment">;;  is, the initial completion candidates for `icicle-occur' are all</span>
<span class="linecomment">;;  of the lines of the buffer (`.' matches any character except a</span>
<span class="linecomment">;;  newline).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With `icicle-search', the candidates need not be single, complete</span>
<span class="linecomment">;;  lines; they can be any strings in the buffer, including multi-line</span>
<span class="linecomment">;;  strings.  Your initial regexp is used over and over to find the</span>
<span class="linecomment">;;  set of matching strings in the region or buffer that you search.</span>
<span class="linecomment">;;  These strings then serve as the completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, you might use a search-context regexp of</span>
<span class="linecomment">;;  "[A-Z][^.?!]+[.?!]" to search sentences, "\\(.+\n\\)+" to search</span>
<span class="linecomment">;;  paragraphs, or "\\([^\f]*[\f]\\|[^\f]+$\\)" to search pages.</span>
<span class="linecomment">;;  (That's in fact how convenience commands</span>
<span class="linecomment">;;  `icicles-search-sentences', `icicles-search-paragraphs', and</span>
<span class="linecomment">;;  `icicles-search-pages' are defined.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `\f' is the form-feed, or page-separator, character.  You input</span>
<span class="linecomment">;;  `\f', `\t', and `\n' using `C-q l', `C-q TAB', and `C-j',</span>
<span class="linecomment">;;  respectively.  See (@&gt; "Dot, Dot, Dot") for information about</span>
<span class="linecomment">;;  multi-line dot (`.'), which matches also newline.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Again, you can use progressive completion (`M-*' or `S-SPC') to</span>
<span class="linecomment">;;  match several different regexps within the same page or the same</span>
<span class="linecomment">;;  sentence.  For example, you could find all sentences that contain</span>
<span class="linecomment">;;  `character', `delete', and `backward', in any order, as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-c ` [A-Z][^.?!]+[.?!] RET</span>
<span class="linecomment">;;    character M-* delete M-* backward</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you visit a search context, both `icicle-occur' and</span>
<span class="linecomment">;;  `icicle-search' highlight that hit.  For `icicle-occur', the</span>
<span class="linecomment">;;  search context is the current line.  For `icicle-search', it is</span>
<span class="linecomment">;;  whatever your search-context regexp matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "How Icicles Search Works")</span>
<span class="linecomment">;;  ** How Icicles Search Works **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are several Icicles search commands, some of which are bound</span>
<span class="linecomment">;;  to keys in Icicle mode:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-c '',  `icicle-occur'             - An `occur' with icompletion</span>
<span class="linecomment">;;  `C-c `'   `icicle-search'   - Seach buffer areas that match regexp</span>
<span class="linecomment">;;            `icicle-search-buffer' (`C-1') - Search selected buffers</span>
<span class="linecomment">;;            `icicle-search-buff-menu-marked' - BufferMenu marked</span>
<span class="linecomment">;;            `icicle-search-ibuffer-marked'   - Search Ibuffer marked</span>
<span class="linecomment">;;            `icicle-search-dired-marked' - Search Dired marked files</span>
<span class="linecomment">;;            `icicle-search-file' (`C--')     - Search selected files</span>
<span class="linecomment">;;            `icicle-search-bookmarks-together' (`C-u'),</span>
<span class="linecomment">;;              `icicle-search-bookmark'            - Search bookmarks</span>
<span class="linecomment">;;            `icicle-search-*-bookmark'   - Bookmarks of a given type</span>
<span class="linecomment">;;  `C-c $'   `icicle-search-word'           - Whole words as contexts</span>
<span class="linecomment">;;  `C-c ^'   `icicle-search-keywords'   - Search with regexp keywords</span>
<span class="linecomment">;;  `C-c `'   `icicle-compilation-search'    - Search compilation hits</span>
<span class="linecomment">;;                                             (e.g `grep' hits)</span>
<span class="linecomment">;;  `C-c "'   ["] `icicle-search-text-property' -</span>
<span class="linecomment">;;                            Search text having a given text property</span>
<span class="linecomment">;;            `icicle-search-overlay-property' -</span>
<span class="linecomment">;;                         Search text having a given overlay property</span>
<span class="linecomment">;;            `icicle-search-char-property' -</span>
<span class="linecomment">;;                    Search text having a given text/overlay property</span>
<span class="linecomment">;;            `icicle-search-pages'               - Search Emacs pages</span>
<span class="linecomment">;;            `icicle-search-paragraphs'     - Search Emacs paragraphs</span>
<span class="linecomment">;;            `icicle-search-sentences' - Search sentences as contexts</span>
<span class="linecomment">;;            `icicle-search-thing'     - Search thing-at-point things</span>
<span class="linecomment">;;                                        optionally ignoring comments</span>
<span class="linecomment">;;            `icicle-search-xml-element' - Search XML elements</span>

<span class="linecomment">;;  `C-c ='   `icicle-imenu' - Navigate among Imenu entries.</span>
<span class="linecomment">;;            `icicle-imenu-command' -</span>
<span class="linecomment">;;               Navigate among Emacs command definitions.</span>
<span class="linecomment">;;            `icicle-imenu-non-interactive-function' -</span>
<span class="linecomment">;;               Navigate among Emacs non-interactive function</span>
<span class="linecomment">;;               definitions.</span>
<span class="linecomment">;;  `C-c TAB' `icicle-comint-command' - Retrieve a past shell command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All operate in the same general way:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Unlike standard incremental search, Icicles search commands</span>
<span class="linecomment">;;     search the entire buffer, not just the part that follows the</span>
<span class="linecomment">;;     cursor.  If the region is active, however, then the search is</span>
<span class="linecomment">;;     confined to the region.  Some Icicles search commands let you</span>
<span class="linecomment">;;     search across multiple buffers, multiple files, or multiple</span>
<span class="linecomment">;;     bookmarks, including region bookmarks.  Searching within one or</span>
<span class="linecomment">;;     more such regions of text is a first way to limit the context</span>
<span class="linecomment">;;     of a search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. You limit the search context in a second way, by providing some</span>
<span class="linecomment">;;     information, such as a regexp or a character property (text or</span>
<span class="linecomment">;;     overlay property), that defines zones of text that you want to</span>
<span class="linecomment">;;     search.  You can use (lax) completion against previous input to</span>
<span class="linecomment">;;     enter the regexp or the character property.  In some cases, the</span>
<span class="linecomment">;;     information (e.g. regexp) to define the search context is</span>
<span class="linecomment">;;     provided automatically by the search command; for example,</span>
<span class="linecomment">;;     `icicle-occur' assumes that you want to search lines.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. If you use a regexp to define the search context, and if that</span>
<span class="linecomment">;;     regexp has subgroups, that is, subexpressions of the form</span>
<span class="linecomment">;;     `\(...\)', then you are prompted for the subgroup to use to</span>
<span class="linecomment">;;     define the search context.  0 means the entire regexp match is</span>
<span class="linecomment">;;     used as a context.  1 means that whatever the first subgroup</span>
<span class="linecomment">;;     matches is used as a context, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     Using a subgroup thus limits the search context in a third way.</span>
<span class="linecomment">;;     It lets you find a search match within a larger search-match</span>
<span class="linecomment">;;     context.  For example, you might choose a Lisp argument list as</span>
<span class="linecomment">;;     the search context, specifying that it must follow `(defun ':</span>
<span class="linecomment">;;     `(defun [^(]*\(([^(]*)\)'.  Subgroup 1 is the argument list.</span>
<span class="linecomment">;;     Specifying a subgroup search context helps you become more</span>
<span class="linecomment">;;     familiar with regexps.  Icicles search highlighting (see below)</span>
<span class="linecomment">;;     shows you the subgroup matches instantly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. You can limit the set of search contexts in a fourth way, by</span>
<span class="linecomment">;;     using `M-&' to provide predicates that search-context</span>
<span class="linecomment">;;     candidates must satisfy.  Command `icicle-search' and its</span>
<span class="linecomment">;;     derivative functions use candidates of the form (CONTEXT</span>
<span class="linecomment">;;     . MARKER), where CONTEXT is a string, the search hit (search</span>
<span class="linecomment">;;     context), and MARKER is a buffer marker that locates the</span>
<span class="linecomment">;;     CONTEXT.  Predicates you supply to the `M-&' prompt must expect</span>
<span class="linecomment">;;     such candidates.  Only contexts that satisfy the predicate are</span>
<span class="linecomment">;;     found.  For example, if the predicate is (lambda (x) (commandp</span>
<span class="linecomment">;;     (intern-soft (car x)))), then only contexts that name Emacs</span>
<span class="linecomment">;;     commands are found.  Or, if you have a predicate `verbp' that</span>
<span class="linecomment">;;     tests whether a word is an English verb form, then you can use</span>
<span class="linecomment">;;     that to limit word matches to verbs.  In this way, you can</span>
<span class="linecomment">;;     combine purely syntactic searching (regexp or text-property</span>
<span class="linecomment">;;     match) with more semantic search criteria.  After building up a</span>
<span class="linecomment">;;     complex predicate by using `M-&', you can save it to a variable</span>
<span class="linecomment">;;     with `C-M-&' and then reuse it later with `C-='.</span>
<span class="linecomment">;;     See also (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Icicles finds all of the qualified search contexts, and</span>
<span class="linecomment">;;     presents them to you as completion candidates.  As always for</span>
<span class="linecomment">;;     Icicles completion, the number of search hits (matching</span>
<span class="linecomment">;;     candidates), is displayed in the mode-line of buffer</span>
<span class="linecomment">;;     `*Completions*' - e.g., `72 candidates'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. You can navigate among the source-buffer search contexts, using</span>
<span class="linecomment">;;     the multi-command action keys (`C-next', `C-prior', `C-RET',</span>
<span class="linecomment">;;     `C-mouse-2').  The contexts are highlighted in the source</span>
<span class="linecomment">;;     buffer(s).  You can scroll the current search-hits buffer</span>
<span class="linecomment">;;     forward and backward using `C-M-v' and `C-M-S-v' (aka `C-M-V').</span>
<span class="linecomment">;;     Whenever the destination would be off-screen, user option</span>
<span class="linecomment">;;     `icicle-recenter' is passed to `recenter' to make it visible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7. As always in Icicles, your current minibuffer input filters the</span>
<span class="linecomment">;;     set of current candidates - the search contexts, so that only</span>
<span class="linecomment">;;     those that contain matches to your input remain as candidates.</span>
<span class="linecomment">;;     This is a second level of matching: looking for a refinement</span>
<span class="linecomment">;;     pattern within the search contexts. And this constitutes a</span>
<span class="linecomment">;;     fifth way you can limit the set of search contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  8. As always in Icicles, this input can be a regexp.  This is</span>
<span class="linecomment">;;     ordinary apropos completion, applied to searching.  You do not</span>
<span class="linecomment">;;     type `RET' to enter this regexp, and you can change it on the</span>
<span class="linecomment">;;     fly to change the set of search hits.  Icicles searching is</span>
<span class="linecomment">;;     thus incremental, in the sense that changing your input</span>
<span class="linecomment">;;     dynamically changes the set of matching search hits.  Icicles</span>
<span class="linecomment">;;     searching is not incremental with respect to the initial,</span>
<span class="linecomment">;;     context matching, however.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  9. As always in Icicles, you can type some input and then hit</span>
<span class="linecomment">;;     `C-~' to remove all candidates that match that input.  Then</span>
<span class="linecomment">;;     type some other input and hit `C-~' again to remove those</span>
<span class="linecomment">;;     matches.  Or you can use `M-&' to define a predicate, and then</span>
<span class="linecomment">;;     hit `C-~' to remove all candidates that satisfy that predicate.</span>
<span class="linecomment">;;     And so on.  And you can use `S-mouse-2' or the `delete' key to</span>
<span class="linecomment">;;     remove individual search hits.  These techniques let you chip</span>
<span class="linecomment">;;     away at the search set, removing hits that are uninteresting.</span>
<span class="linecomment">;;     This is a very powerful technique for both searching and</span>
<span class="linecomment">;;     search-and-replace (see next), and it constitutes a sixth way</span>
<span class="linecomment">;;     to limit the set of search contexts.  See also</span>
<span class="linecomment">;;     (@file :file-name "icicles-doc1.el" :to "Chip Away the Non-Elephant").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  10. You can sort the search hits in various ways.  This can</span>
<span class="linecomment">;;     facilitate navigation and comparison of hits, as well as</span>
<span class="linecomment">;;     search-and-replace (see #11).  And you can define your own</span>
<span class="linecomment">;;     Icicles search commands that provide custom search orders for</span>
<span class="linecomment">;;     particular kinds of search.  It is likely that you have never</span>
<span class="linecomment">;;     considered being able to sort search hits, but if you think</span>
<span class="linecomment">;;     about it you will see that this can be handy.  If you are</span>
<span class="linecomment">;;     searching across multiple buffers, files, or bookmarks, sorting</span>
<span class="linecomment">;;     helps you compare, visit, and replace related hits from the</span>
<span class="linecomment">;;     different sources, instead of having to handle all of the hits</span>
<span class="linecomment">;;     from each source in turn.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  11. You can replace text while you search, forward, backward, or</span>
<span class="linecomment">;;     randomly.  You can replace entire search contexts or just the</span>
<span class="linecomment">;;     parts that match your current input.  You can use any</span>
<span class="linecomment">;;     replacement string that is allowed by `query-replace-regexp'.</span>
<span class="linecomment">;;     In Emacs 22 or later, this includes `\,', to substitute the</span>
<span class="linecomment">;;     result of a Lisp evaluation.  Use the alternative-action keys</span>
<span class="linecomment">;;     for replacement: `C-S-RET', `C-S-mouse-2', `C-S-down',</span>
<span class="linecomment">;;     `C-S-up', `C-S-next', `C-S-prior', `C-S-end', and `C-S-home'.</span>
<span class="linecomment">;;     At the first use, you are prompted for the replacement string;</span>
<span class="linecomment">;;     it is used thereafter.  You can use `M-|'</span>
<span class="linecomment">;;     (`icicle-all-candidates-list-alt-action') to replace all</span>
<span class="linecomment">;;     matches.  See (@&gt; "Search and Replace").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  12. When you visit a search context (using `C-mouse-2' or</span>
<span class="linecomment">;;     `C-down', for example), the part of the candidate that matches</span>
<span class="linecomment">;;     your input is highlighted.  An entire search context is</span>
<span class="linecomment">;;     highlighted in face `icicle-search-main-regexp-current', and</span>
<span class="linecomment">;;     the part that matches your input is highlighted in face</span>
<span class="linecomment">;;     `icicle-search-current-input'.  All other search contexts are</span>
<span class="linecomment">;;     also highlighted (in face `icicle-search-main-regexp-others').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  13. User option `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;     controls whether the input matches are highlighted within each</span>
<span class="linecomment">;;     search context or only within the current context.  It,</span>
<span class="linecomment">;;     together with `icicle-expand-input-to-common-match-flag',</span>
<span class="linecomment">;;     controls whether the input-match highlighting covers an</span>
<span class="linecomment">;;     expanded common match among all matches or just the exact input</span>
<span class="linecomment">;;     match.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  14. If you do not use a subgroup to define the search context (as</span>
<span class="linecomment">;;     in #3, above), that is, if the search context corresponds to</span>
<span class="linecomment">;;     the entire search regexp, then up to eight context levels</span>
<span class="linecomment">;;     (subgroups) are each highlighted differently, using faces</span>
<span class="linecomment">;;     `icicle-search-context-level-1' through</span>
<span class="linecomment">;;     `icicle-search-context-level-8'.  This context-level</span>
<span class="linecomment">;;     highlighting is not done if user option</span>
<span class="linecomment">;;     `icicle-search-highlight-context-levels-flag' is `nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You might have noticed that out of these 14 search features, 6</span>
<span class="linecomment">;;  constitute independent ways in which you can narrow or limit the</span>
<span class="linecomment">;;  set of search hits among which you can navigate.  And another one</span>
<span class="linecomment">;;  (sorting) further facilitates your observation and selection of</span>
<span class="linecomment">;;  search hits.  Restricting the search space and making search-hit</span>
<span class="linecomment">;;  patterns more evident are in fact what search is all about, and</span>
<span class="linecomment">;;  Icicles offers you some unique tools to do this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For several Icicles search commands, including `icicle-search'</span>
<span class="linecomment">;;  (`C-c `'), you provide an initial regexp to define the search</span>
<span class="linecomment">;;  contexts (step 1, above).  Why use two regexps to search (steps 1</span>
<span class="linecomment">;;  and 4, above)?  To make things simpler.  Regular expressions are</span>
<span class="linecomment">;;  powerful for searching, but they can also be cumbersome sometimes.</span>
<span class="linecomment">;;  Why not use one simple regexp to set up a set of candidates and</span>
<span class="linecomment">;;  then, optionally, use a second simple regexp to filter those</span>
<span class="linecomment">;;  candidates?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is the same idea as that behind progressive completion.  And</span>
<span class="linecomment">;;  speaking of which, how would you find a line that contains a given</span>
<span class="linecomment">;;  set of words (each of them), but in an arbitrary (unknown) order?</span>
<span class="linecomment">;;  Progressive completion.  Which lines in this doc section contain</span>
<span class="linecomment">;;  the words `which', `you', and `how', in any order?  If you are</span>
<span class="linecomment">;;  reading this doc in file `icicles-doc2.el', then just use</span>
<span class="linecomment">;;  `icicle-occur' with progressive completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-c ' which M-SPC you M-SPC how</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That narrows things down to four lines that you can then navigate</span>
<span class="linecomment">;;  among.  Progressive completion gives Icicles search a power boost.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like `icicle-occur', commands `icicle-search-word' (`C-c $') and</span>
<span class="linecomment">;;  `icicle-search-keywords' (`C-c ^') are variants of `icicle-search'</span>
<span class="linecomment">;;  that differ only in the regexp used.  Each accepts your input and</span>
<span class="linecomment">;;  converts it to a regexp that does the right thing.</span>
<span class="linecomment">;;  `icicle-search-word' just adds `\b' before and after the word you</span>
<span class="linecomment">;;  type, so that it matches at word boundaries.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-search-keywords' wraps the keywords you provide as input</span>
<span class="linecomment">;;  with regexp grouping (`\(...\)') and alternative (`\|') syntax, so</span>
<span class="linecomment">;;  that search looks for any of the keywords.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  "Keywords" here is an understatement. Each keyword is actually a</span>
<span class="linecomment">;;  regexp and is treated as such, unless you use `C-`' to turn on</span>
<span class="linecomment">;;  escaping of regexp special characters.  In that case, each keyword</span>
<span class="linecomment">;;  is matched as a substring.  At the `C-c $' prompt, you can use</span>
<span class="linecomment">;;  completion to choose keywords that you have already entered, or</span>
<span class="linecomment">;;  you can use `C-RET' to enter new keywords.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, you can use the search string during incremental</span>
<span class="linecomment">;;  search (Isearch) as the initial regexp for `icicle-search'.  You</span>
<span class="linecomment">;;  do this by hitting `S-TAB' during Isearch.  This ends Isearch and</span>
<span class="linecomment">;;  passes its search string to `icicle-search'.  This can be a handy</span>
<span class="linecomment">;;  way to start `icicle-search', picking up its search pattern by</span>
<span class="linecomment">;;  using, say, `C-s C-w C-w...'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Search Multiple Buffers, Files, and Bookmarks")</span>
<span class="linecomment">;;  ** Search Multiple Buffers, Files, and Bookmarks **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you provide a prefix argument to most Icicles search functions,</span>
<span class="linecomment">;;  then you can search multiple buffers, files, or bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Plain prefix argument (`C-u') - Search multiple bookmarks of</span>
<span class="linecomment">;;    various kinds.  To use this feature, you must also use library</span>
<span class="linecomment">;;    `bookmark+.el'.  See (@&gt; "Icicles Bookmark Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-negative numeric prefix argument (e.g. `C-9') - Search</span>
<span class="linecomment">;;    multiple buffers - you are prompted for the buffers to search.</span>
<span class="linecomment">;;    If the prefix argument is 99, then only buffers that are</span>
<span class="linecomment">;;    visiting files are candidates.  You can use `C-RET' and so on to</span>
<span class="linecomment">;;    choose individual buffers with completion.  You can use `C-!' to</span>
<span class="linecomment">;;    choose all buffers or all buffers that match a regexp.</span>
<span class="linecomment">;;    (See (@file :file-name "icicles-doc1.el" :to "Multi-Commands").)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: You can use `M-s i' in Ibuffer or Buffer Menu to search</span>
<span class="linecomment">;;    all marked buffers using Icicles search.  In Ibuffer, menu item</span>
<span class="linecomment">;;    `Icicles Search (and Replace)...' does the same thing as `M-s</span>
<span class="linecomment">;;    i'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Negative numeric prefix argument (e.g. `C--') - Search multiple</span>
<span class="linecomment">;;    files in the current directory - you are prompted for the files</span>
<span class="linecomment">;;    to search.  As for multiple-buffer searching, you can use</span>
<span class="linecomment">;;    `C-RET' and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: You can use `M-s i' in Dired to search all marked files</span>
<span class="linecomment">;;    using Icicles search.  Menu item `Search (and Replace)...' is</span>
<span class="linecomment">;;    added to the Icicles submenu of menu `Multiple' (or `Operate'),</span>
<span class="linecomment">;;    and it does the same thing as `M-s i'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a convenience, some specialized Icicles commands are defined</span>
<span class="linecomment">;;  that correspond to `icicle-search' with the various</span>
<span class="linecomment">;;  prefix-argument cases: `icicle-search-bookmarks-together',</span>
<span class="linecomment">;;  `icicle-search-buffer', and `icicle-search-file'.  If you often</span>
<span class="linecomment">;;  use `C-c `' with one of the prefix argument options, then you</span>
<span class="linecomment">;;  might want to bind one or more of these commands.  These commands</span>
<span class="linecomment">;;  are also available in the Icicles menu-bar menu (or the Search</span>
<span class="linecomment">;;  menu, if it exists).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "User Options for Icicles Searching")</span>
<span class="linecomment">;;  ** User Options for Icicles Searching **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can customize the following user options, to control search</span>
<span class="linecomment">;;  and replacement behavior.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-show-multi-completion-flag' is non-`nil' (the default</span>
<span class="linecomment">;;    value), then, whenever you use a prefix argument, Icicles search</span>
<span class="linecomment">;;    functions annotate each candidate with the name of the buffer</span>
<span class="linecomment">;;    where the search hit occurs, highlighted, to help orient you.</span>
<span class="linecomment">;;    The buffer name is actually part of the (multi-completion)</span>
<span class="linecomment">;;    candidate, so you can match against it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note that even when the value of this option is `nil', if option</span>
<span class="linecomment">;;    `icicle-help-in-mode-line-delay' is greater than zero then you</span>
<span class="linecomment">;;    can see the buffer name in the mode-line (as well as the</span>
<span class="linecomment">;;    position and length of the search context in the buffer).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Icicles search functions that use an initial regexp highlight</span>
<span class="linecomment">;;    the first `icicle-search-highlight-threshold' matches for that</span>
<span class="linecomment">;;    regexp at once (using face `icicle-search-main-regexp-others').</span>
<span class="linecomment">;;    The effect is similar to the Emacs 22+ lazy search highlighting</span>
<span class="linecomment">;;    of Isearch (except that the highlighting is not in fact lazy).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-search-highlight-all-current-flag' is non-`nil', then</span>
<span class="linecomment">;;    Icicles search functions highlight your current input match</span>
<span class="linecomment">;;    within *all* search contexts at once.  If it is non-`nil' and</span>
<span class="linecomment">;;    `icicle-expand-input-to-common-match-flag' is also non-`nil',</span>
<span class="linecomment">;;    then what is highlighted for each input match is the expanded</span>
<span class="linecomment">;;    common match among all input matches throughout the search area.</span>
<span class="linecomment">;;    If either is `nil', then only the exact input match is</span>
<span class="linecomment">;;    highlighted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For example</span>
<span class="linecomment">;;    (see (@file :file-name "icicles-doc1.el" :to "Nutshell View of Icicles")),</span>
<span class="linecomment">;;    if the initial regexp defining the search context is</span>
<span class="linecomment">;;    `.*recursive.*', and your input is `edit', then searching file</span>
<span class="linecomment">;;    `icicles-doc1.el' highlights not `edit' but</span>
<span class="linecomment">;;    ``abort-recursive-edit'', which is the longest common match</span>
<span class="linecomment">;;    among all input matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Gotcha: Remember that the expanded common match pertains to the</span>
<span class="linecomment">;;            entire completion candidate.  In the context of Icicles</span>
<span class="linecomment">;;            search, if you are interested in multiple matches of</span>
<span class="linecomment">;;            your input within the same search context, and you want</span>
<span class="linecomment">;;            to be sure to catch each match, then turn off</span>
<span class="linecomment">;;            common-match expansion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;            Why?  The search context as a whole is compared with the</span>
<span class="linecomment">;;            other search contexts when looking for the expanded</span>
<span class="linecomment">;;            common match.  Your input is matched against the entire</span>
<span class="linecomment">;;            context (search hit), and the expanded common match is</span>
<span class="linecomment">;;            (typically) the longest match that is common to the</span>
<span class="linecomment">;;            other search contexts.  Do not expect the longest common</span>
<span class="linecomment">;;            match of your input against all occurrences in the</span>
<span class="linecomment">;;            search contexts.  What counts is the longest single</span>
<span class="linecomment">;;            match for a given context.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;            For example, if your input is `then' and two of the</span>
<span class="linecomment">;;            search hits are `But then X and then Y' and `W and then</span>
<span class="linecomment">;;            Z', the expanded common match will be `and then', not</span>
<span class="linecomment">;;            `then'.  The matches highlighted for your input thus do</span>
<span class="linecomment">;;            not include each occurrence of `then' in the search</span>
<span class="linecomment">;;            hits, but rather each occurrence of `and then'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If `icicle-expand-input-to-common-match-flag',</span>
<span class="linecomment">;;    `icicle-search-highlight-all-current-flag', and</span>
<span class="linecomment">;;    `icicle-search-replace-common-match-flag' are all non-`nil',</span>
<span class="linecomment">;;    then a search replacement replaces the expanded common match;</span>
<span class="linecomment">;;    otherwise, it replaces only the exact match.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The default value of `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;    is `nil', because non-`nil' can impact performance negatively if</span>
<span class="linecomment">;;    there are many search contexts - the highlighting is updated</span>
<span class="linecomment">;;    with each input change.  You can toggle the value at any time</span>
<span class="linecomment">;;    using command `icicle-toggle-highlight-all-current', bound to</span>
<span class="linecomment">;;    `C-^' in the minibuffer during Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-search-cleanup-flag' is non-`nil' (the default value)</span>
<span class="linecomment">;;    then search highlighting is removed after the search.  If you</span>
<span class="linecomment">;;    set this to `nil' then you can remove search highlighting</span>
<span class="linecomment">;;    manually later using command `icicle-search-highlight-cleanup'.</span>
<span class="linecomment">;;    You can toggle this search highlight removal at any time using</span>
<span class="linecomment">;;    command `icicle-toggle-search-cleanup', bound to `C-.' in the</span>
<span class="linecomment">;;    minibuffer (except during file-name completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    One use of `nil' `icicle-search-cleanup-flag' is to highlight</span>
<span class="linecomment">;;    regexp matches throughout a region or buffer (or multiple files</span>
<span class="linecomment">;;    or...).  In that capacity, Icicles search functions act like</span>
<span class="linecomment">;;    some of the highlighting commands in my library `highlight.el'.</span>
<span class="linecomment">;;    Note that when `icicle-search-cleanup-flag' is `nil', *all*</span>
<span class="linecomment">;;    Icicles search highlighting remains: last-visited search</span>
<span class="linecomment">;;    context, other context matches, current-input matches, and even</span>
<span class="linecomment">;;    regexp subgroups.  The faces for these are, respectively:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - `icicle-search-main-regexp-current'</span>
<span class="linecomment">;;    - `icicle-search-main-regexp-others'</span>
<span class="linecomment">;;    - `icicle-search-highlight-input-matches-here' (everywhere, if</span>
<span class="linecomment">;;      `icicle-search-highlight-all-current-flag' is non-`nil')</span>
<span class="linecomment">;;    - `icicle-search-context-level-1' through</span>
<span class="linecomment">;;      `icicle-search-context-level-8'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-search-replace-whole-candidate-flag' is `nil', then</span>
<span class="linecomment">;;    whatever matches your current input is replaced, within the</span>
<span class="linecomment">;;    current search context, when you perform replacement</span>
<span class="linecomment">;;    (e.g. `C-S-RET').  If the value is non-`nil' (the default</span>
<span class="linecomment">;;    value), then the entire search context is replaced, instead.</span>
<span class="linecomment">;;    You can use `M-_' at any time during searching and replacing, to</span>
<span class="linecomment">;;    toggle the value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-search-word' (bound to `C-c $') always searches</span>
<span class="linecomment">;;    for a whole word: your initial search string is matched only</span>
<span class="linecomment">;;    against whole words.  Non-`nil' `icicle-search-whole-word-flag'</span>
<span class="linecomment">;;    makes other Icicles search commands also perform whole-word</span>
<span class="linecomment">;;    searching.  The search string you type is matched literally, but</span>
<span class="linecomment">;;    matches must start and end at word boundaries.  Because it is</span>
<span class="linecomment">;;    matched literally, all regexp special characters in the search</span>
<span class="linecomment">;;    string are escaped.  This means, for instance, that you can</span>
<span class="linecomment">;;    match `foo-bar' as a word, even in contexts (such as Emacs Lisp)</span>
<span class="linecomment">;;    where `-' is not a word-constituent character.  Similarly, you</span>
<span class="linecomment">;;    can match the literal four-character "word" `f.*g'.  You can use</span>
<span class="linecomment">;;    `M-q' while searching to toggle this option; the new value takes</span>
<span class="linecomment">;;    effect for the next complete search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can toggle `icicle-use-C-for-actions-flag' at any time using</span>
<span class="linecomment">;;    `M-g' in the minibuffer.  This is handy for multi-commands that</span>
<span class="linecomment">;;    browse, such as Icicles search.  It means that you can use</span>
<span class="linecomment">;;    `next' and so on instead of `C-next' and so on to navigate among</span>
<span class="linecomment">;;    search hits.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-ignore-comments-flag' means that</span>
<span class="linecomment">;;    `icicle-search-thing' and related commands</span>
<span class="linecomment">;;    (e.g. `icicle-search-xml-element') ignore comments.  That is,</span>
<span class="linecomment">;;    they hide comments temporarily while they scan the region or</span>
<span class="linecomment">;;    buffer for things of the given type to serve as search contexts</span>
<span class="linecomment">;;    (completion candidates).  This prevents them, for example, from</span>
<span class="linecomment">;;    presenting as a candidate a sexp or a list that is commented</span>
<span class="linecomment">;;    out.  You can toggle this option anytime using `C-M-;' in the</span>
<span class="linecomment">;;    minibuffer, but to see the effect you might need to invoke the</span>
<span class="linecomment">;;    current command again.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-search-hook': Functions run after searching and moving</span>
<span class="linecomment">;;    to a match, whether by `RET' or `C-RET' (or `C-next' or</span>
<span class="linecomment">;;    `C-prior').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It can sometimes be useful to highlight all regexp matches using a</span>
<span class="linecomment">;;  large value of `icicle-search-highlight-threshold' and a `nil'</span>
<span class="linecomment">;;  value of `icicle-search-cleanup-flag', and then set</span>
<span class="linecomment">;;  `icicle-search-highlight-threshold' to zero and use an Icicles</span>
<span class="linecomment">;;  search function again with a different regexp to search through</span>
<span class="linecomment">;;  the same region or buffer.  This lets you see the relation between</span>
<span class="linecomment">;;  the two sets of regexp matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Regexps with Icicles Search")</span>
<span class="linecomment">;;  ** Using Regexps with Icicles Search **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use Icicles search to find text entities of a certain kind</span>
<span class="linecomment">;;  - sentences, paragraphs, file names, URLs, and so on.  A</span>
<span class="linecomment">;;  convenient way to do this is to use `C-='</span>
<span class="linecomment">;;  (`icicle-insert-string-from-variable') or `C-x r i'</span>
<span class="linecomment">;;  (`insert-register') in the minibuffer to insert a predefined</span>
<span class="linecomment">;;  regexp that matches a particular kind of text entity.  Which of</span>
<span class="linecomment">;;  these you use depends on whether the regexp string is saved in a</span>
<span class="linecomment">;;  variable (`C-=') or a register (`C-x r i').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, suppose you are in a mail client and you want to move</span>
<span class="linecomment">;;  between mail headers.  If you use a regexp that matches the header</span>
<span class="linecomment">;;  field you want (e.g. the sent date or sender) then Icicles search</span>
<span class="linecomment">;;  highlights all such occurrences and lets you navigate among them -</span>
<span class="linecomment">;;  instant mail browser!  Or, suppose you are in a C++ or Perl file</span>
<span class="linecomment">;;  and you want to navigate among function definitions or other</span>
<span class="linecomment">;;  definitions.  If you have a canned regexp that matches the start</span>
<span class="linecomment">;;  of a definition, then you can use `C-=' to quickly turn</span>
<span class="linecomment">;;  `icicle-search' into a code browser.  In a log file, navigate</span>
<span class="linecomment">;;  among date or time entries or IP addresses...  Of course, most</span>
<span class="linecomment">;;  programming modes and mail clients already provide other ways to</span>
<span class="linecomment">;;  navigate, but you get the idea - Icicles search provides a general</span>
<span class="linecomment">;;  way to navigate among things, as long as you can match them with</span>
<span class="linecomment">;;  regexps, and `C-=' lets you quickly access a library of predefined</span>
<span class="linecomment">;;  regexps.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can find useful regexps to store in variables in the standard</span>
<span class="linecomment">;;  Emacs Lisp libraries.  Grep for `font-lock-keywords' or `regexp'</span>
<span class="linecomment">;;  in the Emacs `lisp' directory and its subdirectories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   See `align.el' for regexps for programming languages.</span>
<span class="linecomment">;;   See `url-dav.el' for regexps matching ISO 8601 dates.</span>
<span class="linecomment">;;   See `rmail.el', `sendmail.el', and `mh-show.el' for regexps</span>
<span class="linecomment">;;   matching mail-header fields.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Imenu regexps occurring as parts of different values of</span>
<span class="linecomment">;;  `imenu-generic-expression' for different buffer types can be used</span>
<span class="linecomment">;;  as variable values for `C-='.  They all work fine with</span>
<span class="linecomment">;;  `icicle-search', turning it into a navigator for the given mode.</span>
<span class="linecomment">;;  See, for example, `generic-x.el' and `lisp-mode.el'.  Here is a</span>
<span class="linecomment">;;  regexp for Javascript function definitions from `generic-x.el':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   "^function\\s-+\\([A-Za-z0-9_]+\\)"</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And `lisp-imenu-generic-expression' (in `lisp-mode.el') provides</span>
<span class="linecomment">;;  regexps for Lisp function, variable, and type definitions.  Here</span>
<span class="linecomment">;;  is the variable-definition regexp:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   "^\\s-*(\\(def\\(c\\(onst\\(ant\\)?\\|ustom\\)\\|ine-symbol-macro</span>
<span class="linecomment">;;   \\|parameter\\|var\\)\\)\\s-+\\(\\(\\sw\\|\\s_\\)+\\)"</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You certainly do not want to type a regexp like that into the</span>
<span class="linecomment">;;  minibuffer (and the function-definition regexp is twice as</span>
<span class="linecomment">;;  complex)!  Put it into a variable or register once and use `C-='</span>
<span class="linecomment">;;  or `C-x r i' from then on to retrieve it - simple.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If it's so simple, then why not let a command do it?  This is</span>
<span class="linecomment">;;  exactly what command `icicle-imenu' (bound to `C-c =') does.  You</span>
<span class="linecomment">;;  do not need to bother looking up Imenu regexps and assigning them</span>
<span class="linecomment">;;  to variables for use with `C-=' and `icicle-search'-</span>
<span class="linecomment">;;  `icicle-imenu' does that for you automatically.</span>
<span class="linecomment">;;  See (@&gt; "Other Icicles Search Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In sum: For complete interactivity, type a regexp dynamically as</span>
<span class="linecomment">;;  input to `icicle-search'.  For isolated special regexps that you</span>
<span class="linecomment">;;  use, save them in variables and use `C-=' with `icicle-search'.</span>
<span class="linecomment">;;  For well-defined sets of regexps, especially if used frequently,</span>
<span class="linecomment">;;  define a command that uses `icicle-search'.  There is a spectrum</span>
<span class="linecomment">;;  of use cases for `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-search' is very general and very powerful.  It</span>
<span class="linecomment">;;  might never replace incremental search - either regexp or literal</span>
<span class="linecomment">;;  string search, but in some cases it can be quite handy.  Think of</span>
<span class="linecomment">;;  it as another tool to add to your search-tool belt.  Admittedly,</span>
<span class="linecomment">;;  it does take a little getting used to.  Remember, in particular,</span>
<span class="linecomment">;;  that the initial, context regexp you enter (with `RET') cannot be</span>
<span class="linecomment">;;  changed without re-executing `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And remember too that `C-l' (`icicle-retrieve-previous-input') is</span>
<span class="linecomment">;;  your friend - it clears the minibuffer during cycling, retrieving</span>
<span class="linecomment">;;  your last real input.  Use it to modify your second and subsequent</span>
<span class="linecomment">;;  regexps on the fly - those that filter the initial candidate list</span>
<span class="linecomment">;;  further.  You can repeat `C-l' to retrieve older completion</span>
<span class="linecomment">;;  inputs, and you can use `C-S-l' (that is, `C-L') to cycle previous</span>
<span class="linecomment">;;  inputs in the other direction.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Oh - And do not forget that you can do things like take the</span>
<span class="linecomment">;;  complement of your fine-tuning regexp matches, within the context</span>
<span class="linecomment">;;  of your coarse-tuning matches.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, use `^.*defun.*$' as the main regexp, to find all</span>
<span class="linecomment">;;  lines containing `defun'.  Then type `icicle' to match only the</span>
<span class="linecomment">;;  lines with `defun' that also contain `icicle'.  Then complement</span>
<span class="linecomment">;;  (`C-~') that set, to see the lines that contain `defun' but not</span>
<span class="linecomment">;;  `icicle'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And you can then save that set of matches, and then subtract it</span>
<span class="linecomment">;;  from another set of matches in a different search...  You get the</span>
<span class="linecomment">;;  idea.  When performing set operations combined with</span>
<span class="linecomment">;;  `icicle-search', keep in mind that the saved set does not include</span>
<span class="linecomment">;;  any position information - it is only a set of matching strings.</span>
<span class="linecomment">;;  So, in particular, a set-union operation (`C-+') is not useful</span>
<span class="linecomment">;;  with `icicle-search' (adding a saved set of strings without</span>
<span class="linecomment">;;  positions is useless).  Still, you can do things like match lines</span>
<span class="linecomment">;;  that contain `defun' followed somewhere by `()', and then subtract</span>
<span class="linecomment">;;  the (saved) set of lines in the same region that contain `icicle'.</span>
<span class="linecomment">;;  Try it in an Icicles library, using regexps `.*icicle.*$' and</span>
<span class="linecomment">;;  `^*.defun.*().*$'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One more reminder: When you save a set of completion candidates</span>
<span class="linecomment">;;  (`C-M-&gt;'), make sure that you actually have a set of candidates to</span>
<span class="linecomment">;;  save!  It is not enough to just enter a regexp at the</span>
<span class="linecomment">;;  `icicle-search' prompt.  You must also use some Icicles command,</span>
<span class="linecomment">;;  such as `TAB', `S-TAB', `next', or `down' to tell Icicles how to</span>
<span class="linecomment">;;  create the candidate set - how to match the regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The doc string (`C-h f') of command `icicle-search'; it provides</span>
<span class="linecomment">;;    general information about Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Other Icicles Search Commands") for specialized Icicles</span>
<span class="linecomment">;;    search commands `icicle-comint-search',</span>
<span class="linecomment">;;    `icicle-compilation-search', `icicle-imenu',</span>
<span class="linecomment">;;    `icicle-imenu-command', `icicle-imenu-non-interactive-function',</span>
<span class="linecomment">;;    `icicle-search-char-property', `icicle-search-keywords',</span>
<span class="linecomment">;;    `icicle-search-overlay-property', and</span>
<span class="linecomment">;;    `icicle-search-text-property'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Search and Replace") for information about replacing search</span>
<span class="linecomment">;;    hits or parts of search hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Customization and General Tips") for information about the</span>
<span class="linecomment">;;    `icicle-search-*' faces, which control Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
<span class="linecomment">;;    for information about `M-*' and `M-&'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Multi-Commands") for</span>
<span class="linecomment">;;    information about `C-RET', `C-mouse-2', `C-next', and `C-prior'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Bookmark Enhancements") for information about</span>
<span class="linecomment">;;    searching bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Inserting a Regexp from a Variable or Register")</span>
<span class="linecomment">;;    for more about inserting a saved string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Info Enhancements") for information about using</span>
<span class="linecomment">;;    Icicles to search in Info mode.</span>
 
<span class="linecomment">;;(@* "Search and Replace")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Search and Replace</span>
<span class="linecomment">;;  ------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Replacement during Icicles search is something quite different</span>
<span class="linecomment">;;  from anything you are used to.  There are several different ways</span>
<span class="linecomment">;;  to replace search-hit text during Icicles search, and it can be a</span>
<span class="linecomment">;;  bit of a challenge to understand all the possibilities.  So my</span>
<span class="linecomment">;;  advice is to experiment, as well as to read the descriptions here.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can replace the current search match by using any of the</span>
<span class="linecomment">;;  alternative action keys: `C-S-RET', `C-S-mouse-2' (in</span>
<span class="linecomment">;;  `*Completions*'), `C-S-down', `C-S-up', `C-S-next', `C-S-prior',</span>
<span class="linecomment">;;  `C-S-end', or `C-S-home', .  You can use `M-|'</span>
<span class="linecomment">;;  (`icicle-all-candidates-list-alt-action') to replace all matches</span>
<span class="linecomment">;;  of your current input at once, throughout the search space.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  At the first use of any of these, you are prompted for the</span>
<span class="linecomment">;;  replacement pattern; it is used thereafter, or until you use `M-,'</span>
<span class="linecomment">;;  (`icicle-search-define-replacement').  You can use `M-,' at any</span>
<span class="linecomment">;;  time during searching to change the pattern for subsequent</span>
<span class="linecomment">;;  replacements.  The replacement pattern can be anything that is</span>
<span class="linecomment">;;  allowed as a replacement by `query-replace-regexp'.  In Emacs 22</span>
<span class="linecomment">;;  or later, this includes Lisp sexp evaluation via `\,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Unlike `query-replace', you need not visit each search match - you</span>
<span class="linecomment">;;  can visit and replace selected matches in any order.  Some other</span>
<span class="linecomment">;;  differences from standard `query-replace' and</span>
<span class="linecomment">;;  `query-replace-regexp':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * Replacing matches of your current input provides a contextual</span>
<span class="linecomment">;;     replacement feature: replace `foo' by `fu', but only in zones</span>
<span class="linecomment">;;     that match `toto.*titi'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * Icicles search navigation (`C-next', etc.) lets you replace</span>
<span class="linecomment">;;     individual search hits without navigating through each search</span>
<span class="linecomment">;;     context in turn: direct access.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * In Icicles search, replace-all (`M-|') means replace all</span>
<span class="linecomment">;;     matches of your current input, throughout the search space, not</span>
<span class="linecomment">;;     just all matches that follow the cursor.  And remember that you</span>
<span class="linecomment">;;     can (a) activate the region to limit the search-and-replace</span>
<span class="linecomment">;;     space and (b) use progressive completion etc. to narrow the set</span>
<span class="linecomment">;;     of hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * You can act across multiple buffers, files, or bookmarks -</span>
<span class="linecomment">;;     see information about the `icicle-search' prefix arg.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * You can also replace matches within text-property search</span>
<span class="linecomment">;;     contexts - just use `icicle-search-text-property' (`C-c "') ["]</span>
<span class="linecomment">;;     as the search command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Search matches are replaced - but just what is meant by a "search</span>
<span class="linecomment">;;  match"?  It can be either an entire search context or each match</span>
<span class="linecomment">;;  of your current minibuffer input within a search context.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Anytime during search and replace:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `M-,' redefines the replacement string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `C-`' toggles `icicle-toggle-regexp-quote' (as always).  This</span>
<span class="linecomment">;;     escapes regexp special characters, so that search is literal.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `M-q' toggles `icicle-search-whole-word-flag'.  By default,</span>
<span class="linecomment">;;     this is `nil', meaning that searching is not for whole words</span>
<span class="linecomment">;;     (except for `icicle-search-word', bound to `C-c $').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `C-M-`' toggles `icicle-search-replace-literally-flag'.  By</span>
<span class="linecomment">;;      default, this is `nil', which means that `\' character</span>
<span class="linecomment">;;      sequences in replacement text are intrepreted as for</span>
<span class="linecomment">;;      `query-replace-regexp'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `M-_' toggles `icicle-search-replace-whole-candidate-flag'.  By</span>
<span class="linecomment">;;     default, this is non-`nil', which means that the entire current</span>
<span class="linecomment">;;     search context is replaced, that is, whatever matches the</span>
<span class="linecomment">;;     context regexp that you entered initially using `RET'.</span>
<span class="linecomment">;;     However, you can use `M-_' anytime during searching to toggle</span>
<span class="linecomment">;;     between this default behavior and replacement of whatever your</span>
<span class="linecomment">;;     current minibuffer input matches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   * `M-;' toggles `icicle-search-replace-common-match-flag'.</span>
<span class="linecomment">;;     Together with other options, it controls whether to replace the</span>
<span class="linecomment">;;     expanded common match or just the exact match.  See below.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  REMEMBER THIS:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - If `icicle-search-replace-whole-candidate-flag' is true</span>
<span class="linecomment">;;    (non-`nil'), then the granularity of replacement is a complete</span>
<span class="linecomment">;;    search context.  In this case, replacement behaves similarly to</span>
<span class="linecomment">;;    `query-replace-regexp' (except that special replacement</span>
<span class="linecomment">;;    constructs, such as `\#', are not treated as such).  You can</span>
<span class="linecomment">;;    still use minibuffer input to filter the set of search contexts,</span>
<span class="linecomment">;;    but replacement is on a whole-context basis.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - If `icicle-search-replace-whole-candidate-flag' is false</span>
<span class="linecomment">;;    (`nil'), then you can replace multiple input matches separately</span>
<span class="linecomment">;;    within a search context (using `C-S-RET').  This behavior is</span>
<span class="linecomment">;;    unique to Icicles.  You cannot, however skip over one input</span>
<span class="linecomment">;;    match and replace the next one in the same context - `C-S-RET'</span>
<span class="linecomment">;;    always replaces the first available match in the context</span>
<span class="linecomment">;;    (repeated use changes which is first).  When</span>
<span class="linecomment">;;    `icicle-search-replace-whole-candidate-flag' is `nil', you can</span>
<span class="linecomment">;;    also use special replacement constructs, such as `\#'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If `icicle-search-replace-whole-candidate-flag' is true, then you</span>
<span class="linecomment">;;  can use the navigational alternative action keys, `C-S-down',</span>
<span class="linecomment">;;  `C-S-up', `C-S-next', `C-S-prior', `C-S-end', and `C-S-home',</span>
<span class="linecomment">;;  repeatedly to replace successive search contexts.  At the buffer</span>
<span class="linecomment">;;  limits, these commands wrap around to the other buffer limit (last</span>
<span class="linecomment">;;  search context to first, and vice versa).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Search traversal using these go-to-next-context-and-replace keys</span>
<span class="linecomment">;;  is always by search context, not by individual input match.  This</span>
<span class="linecomment">;;  means that you cannot use these keys to replace input matches</span>
<span class="linecomment">;;  within a search context.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If `icicle-search-replace-whole-candidate-flag' is false, then you</span>
<span class="linecomment">;;  can use these keys to replace the first input match.  More</span>
<span class="linecomment">;;  importantly, you can use `C-S-RET' to replace that first match,</span>
<span class="linecomment">;;  without moving on to the next context.  Because `C-S-RET' always</span>
<span class="linecomment">;;  acts on the current search hit (context), using it again, after</span>
<span class="linecomment">;;  you have used it to replace the first such match, replaces the</span>
<span class="linecomment">;;  next one.  And so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Thus, if your input matches multiple parts of a search context and</span>
<span class="linecomment">;;  you want to replace these matches, use `C-S-RET' repeatedly.</span>
<span class="linecomment">;;  After all of the matches in the current context have been</span>
<span class="linecomment">;;  replaced, `C-S-RET' replaces the first match in the next context.</span>
<span class="linecomment">;;  (There is a gotcha, however, if the replacement text matches your</span>
<span class="linecomment">;;  input - see below.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can thus traverse all matches of your input, in the current</span>
<span class="linecomment">;;  sort order (by default, the order they appear in the source being</span>
<span class="linecomment">;;  searched), by just repeating `C-S-RET'.  At the buffer limits,</span>
<span class="linecomment">;;  repeating `C-S-RET' wraps around.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-S-RET' always replaces the first input match in the</span>
<span class="linecomment">;;  current search context or, if there are no matches, then the first</span>
<span class="linecomment">;;  input match in the next context.  This behavior has these</span>
<span class="linecomment">;;  important consequences:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If you repeat `C-S-RET' and the previous replacement no longer</span>
<span class="linecomment">;;    matches your input, then `C-S-RET' moves on to the next input</span>
<span class="linecomment">;;    match (which is now the first one) and replaces that.  This is</span>
<span class="linecomment">;;    why you can usually just repeat `C-S-RET' to successively</span>
<span class="linecomment">;;    replaces matches of your input, including from one context to</span>
<span class="linecomment">;;    the next.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If, on the other hand, after replacement the text still matches</span>
<span class="linecomment">;;    your input, then repeating `C-S-RET' will just replace that</span>
<span class="linecomment">;;    match.  For example, if you replace the input match `ab' by</span>
<span class="linecomment">;;    `abcd', then repeating `C-S-RET' produces `abcd', then `abcdcd',</span>
<span class="linecomment">;;    then `abcdcdcd',...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You cannot replace an input match, skip the next match, and then</span>
<span class="linecomment">;;    replace the following one, all in the same context.  You can,</span>
<span class="linecomment">;;    however, replace some matches and then skip (e.g. `C-next') to</span>
<span class="linecomment">;;    the next context.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What your input matches, hence what gets replaced if</span>
<span class="linecomment">;;  `icicle-search-replace-whole-candidate-flag' is `nil', depends on</span>
<span class="linecomment">;;  a few Icicles options:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `icicle-regexp-quote-flag' determines whether to use regexp</span>
<span class="linecomment">;;    matching or literal matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - `icicle-search-highlight-all-current-flag',</span>
<span class="linecomment">;;    `icicle-expand-input-to-common-match-flag' and</span>
<span class="linecomment">;;    `icicle-search-replace-common-match-flag' together determine</span>
<span class="linecomment">;;    whether to replace exactly what your input matches in the</span>
<span class="linecomment">;;    current search hit or the expanded common match (ECM) of your</span>
<span class="linecomment">;;    input among all search hits.  If any of these options is `nil',</span>
<span class="linecomment">;;    then your exact input match is replaced; otherwise, the ECM is</span>
<span class="linecomment">;;    replaced.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The replacement string can be nearly anything that is allowed as a</span>
<span class="linecomment">;;  replacement by `query-replace-regexp'.  In Emacs 22 or later, this</span>
<span class="linecomment">;;  includes Emacs-Lisp sexp evaluation via `\,' and constructs such</span>
<span class="linecomment">;;  as `\#' and `\N' (back references).  You can also use `\?', but it</span>
<span class="linecomment">;;  is not very useful - you might as well use `M-,' instead, to</span>
<span class="linecomment">;;  change the replacement text.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Finally, let me repeat what I said at the beginning of this page:</span>
<span class="linecomment">;;  Icicles search-and-replace is different from what you are used to,</span>
<span class="linecomment">;;  and there are several different ways to use it.  Experiment to get</span>
<span class="linecomment">;;  to know how it works, and reread the description here.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is important to understand the various user options (with their</span>
<span class="linecomment">;;  toggle commands) and their effects.  They can radically change the</span>
<span class="linecomment">;;  behavior of replacement.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In particular, to put Icicles search-and-replace to best advantage</span>
<span class="linecomment">;;  you need to know what gets replaced, depending on those user</span>
<span class="linecomment">;;  options: the whole search hit vs only input matches, an exact</span>
<span class="linecomment">;;  input match vs the expanded common match.  Experiment with the</span>
<span class="linecomment">;;  toggles `M-_', `C-^', `C-;', and `M-;'.  And you need to know how</span>
<span class="linecomment">;;  repeated `C-S-RET' works vs repeated `C-S-next'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I know it's tricky to learn.  Experimenting helps.  If something</span>
<span class="linecomment">;;  happens that you did not expect, reread this section and try to</span>
<span class="linecomment">;;  understand.  Have fun.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") and the doc string of</span>
<span class="linecomment">;;    `icicle-search' for more information about search-and-replace.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Compile/Grep Search") for information about using</span>
<span class="linecomment">;;    search-and-replace with `grep' buffers and compilation buffers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@* "Icicles Dired Enhancements") for information about using</span>
<span class="linecomment">;;    search-and-replace on marked files in Dired.</span>
 
<span class="linecomment">;;(@* "Other Icicles Search Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Other Icicles Search Commands</span>
<span class="linecomment">;;  -----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `icicle-search' is very general.  As is explained in</span>
<span class="linecomment">;;  (@&gt; "Icicles Search Commands, Overview"), command `icicle-occur'</span>
<span class="linecomment">;;  is defined trivially using `icicle-search' - it is basically</span>
<span class="linecomment">;;  `icicle-search' with a regexp of `.*', to match lines.  Similarly,</span>
<span class="linecomment">;;  `icicle-search-word' (`C-c $') uses a regexp of `\bWORD\b', where</span>
<span class="linecomment">;;  `WORD' is the word to look for, and `icicle-search-keywords'</span>
<span class="linecomment">;;  (`C-c ^') uses a regexp of `\(KW1\|KW2\|KW2...\|KWn\)', where the</span>
<span class="linecomment">;;  `KWm' are the keywords (regexps) to look for.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Still other Icicles commands are available that make use of</span>
<span class="linecomment">;;  `icicle-search'.  And you can define your own, specialized search</span>
<span class="linecomment">;;  commands along the same lines.  To do that, it is instructive to</span>
<span class="linecomment">;;  look at the source code of the commands described in this section;</span>
<span class="linecomment">;;  they can serve as a model for defining your own search commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Two of the commands described here, `icicle-compilation-search'</span>
<span class="linecomment">;;  and `icicle-comint-search', are specialized versions of</span>
<span class="linecomment">;;  `icicle-search' that work only in particular buffers where there</span>
<span class="linecomment">;;  is little need for `icicle-search' itself. For this reason, these</span>
<span class="linecomment">;;  commands reuse the key sequence, `C-c `' (backquote), that is</span>
<span class="linecomment">;;  normally bound to `icicle-search'.  This shadow binding occurs if</span>
<span class="linecomment">;;  the current major mode is a compilation mode (for</span>
<span class="linecomment">;;  `icicle-compilation-search') or an interactive interpreter mode</span>
<span class="linecomment">;;  such as `shell-mode' or Lisp interactive mode (for</span>
<span class="linecomment">;;  `icicle-comint-search').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  [Programmer Note: Actually, the way this works is that `C-c `' is</span>
<span class="linecomment">;;  bound to the value of internal variable `icicle-search-generic'.</span>
<span class="linecomment">;;  You can use this mechanism to provide custom Icicles search</span>
<span class="linecomment">;;  commands for particular buffers.]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Besides the commands described in this section, there are Icicles</span>
<span class="linecomment">;;  search commands for navigating tags-file definitions and searching</span>
<span class="linecomment">;;  their associated source files.  These are described in section</span>
<span class="linecomment">;;  (@&gt; "Icicles Enhancements for Emacs Tags").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `M-g' in the minibuffer to toggle option</span>
<span class="linecomment">;;  `icicle-use-C-for-actions-flag', then you can use just `next'</span>
<span class="linecomment">;;  instead of `C-next' to navigate when using any Icicles search</span>
<span class="linecomment">;;  command.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Searching Text with Properties")</span>
<span class="linecomment">;;  ** Searching Text with Properties **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of providing a context regexp, for commands</span>
<span class="linecomment">;;  `icicle-search-char-property', `icicle-search-overlay-property',</span>
<span class="linecomment">;;  and `icicle-search-text-property' (`C-c "') ["] you provide a</span>
<span class="linecomment">;;  character property (e.g. `face') and its value</span>
<span class="linecomment">;;  (e.g. `font-lock-function-name-face').  All zones of text that</span>
<span class="linecomment">;;  have that property with that value become the completion</span>
<span class="linecomment">;;  candidates (search hits).  As always, you can filter this set of</span>
<span class="linecomment">;;  candidates by typing input in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By a "character property" is meant either a text property or an</span>
<span class="linecomment">;;  overlay property.  `icicle-search-char-property' searches both</span>
<span class="linecomment">;;  kinds of character property; `icicle-search-overlay-property'</span>
<span class="linecomment">;;  searches only overlay properties; and</span>
<span class="linecomment">;;  `icicle-search-text-property' (`C-c "' ["]) searches only text</span>
<span class="linecomment">;;  properties.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you use `icicle-search-char-property' with a</span>
<span class="linecomment">;;  `face' property value `highlight', then the text searched includes</span>
<span class="linecomment">;;  text with that overlay value and text with that text-property</span>
<span class="linecomment">;;  value.  With a `face' property value of `font-lock-string-face',</span>
<span class="linecomment">;;  you can browse or search doc strings, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the property chosen is `face', then you can in fact choose</span>
<span class="linecomment">;;  multiple faces, in multi-command fashion (e.g. `C-mouse-2'), and</span>
<span class="linecomment">;;  the text that is searched has at least one of the faces you</span>
<span class="linecomment">;;  choose.  If you choose no face value (empty input), then the</span>
<span class="linecomment">;;  target is text that has any face at all.  The search hits are</span>
<span class="linecomment">;;  zones of text that are distinguished by their `face' values.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As with other Icicles search commands, a prefix argument controls</span>
<span class="linecomment">;;  whether these character-property commands search the current</span>
<span class="linecomment">;;  buffer, selected bookmarks, selected files, or selected buffers.</span>
<span class="linecomment">;;  However, keep in mind that, since in this case you are searching</span>
<span class="linecomment">;;  character properties, you will find search hits only for buffers</span>
<span class="linecomment">;;  that already have such properties, for example, buffers that have</span>
<span class="linecomment">;;  been fontified.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Imenu")</span>
<span class="linecomment">;;  ** Icicles Imenu **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-imenu', which is bound to `C-c =', is an Imenu</span>
<span class="linecomment">;;  browser.  It lets you use Icicles completion to navigate among</span>
<span class="linecomment">;;  definitions of functions, variables, types, keys, and so on in a</span>
<span class="linecomment">;;  programming language (in fact, any language that Imenu handles).</span>
<span class="linecomment">;;  As always in Icicles, your current input (e.g. a regexp) filters</span>
<span class="linecomment">;;  the set of available candidates.  That is, you can match against</span>
<span class="linecomment">;;  parts of an Imenu entry - any parts.  That's particularly useful</span>
<span class="linecomment">;;  if there are many entries in the Imenu menu; you do not need to</span>
<span class="linecomment">;;  read/scan the whole list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you look at the definition of `icicle-imenu' you'll see that it</span>
<span class="linecomment">;;  simply lets you choose an Imenu submenu (Functions, User Options,</span>
<span class="linecomment">;;  and so on) that is appropriate for the current buffer type, and</span>
<span class="linecomment">;;  then it calls `icicle-search', passing it the appropriate Imenu</span>
<span class="linecomment">;;  regexp.  You can similarly define your own specialized search</span>
<span class="linecomment">;;  commands using `icicle-search' to browse regexp matches.  You get</span>
<span class="linecomment">;;  all of the features of `icicle-search' when you do that.  For</span>
<span class="linecomment">;;  example, `icicle-imenu' gives you these advantages over a standard</span>
<span class="linecomment">;;  Imenu menu:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can restrict navigation (search) to a region.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can navigate (browse) among multiple entries, instead of</span>
<span class="linecomment">;;    choosing them one by one from a menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can restrict the entries to browse using (regexp) pattern</span>
<span class="linecomment">;;    matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * As for `icicle-search', you can search multiple bookmarks,</span>
<span class="linecomment">;;    multiple buffers, or multiple files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, for Emacs-Lisp function definitions, Icicles provides</span>
<span class="linecomment">;;  two specializations of `icicle-imenu', to find only Emacs command</span>
<span class="linecomment">;;  definitions and only non-interactive function (that is,</span>
<span class="linecomment">;;  non-command) definitions: `icicle-imenu-command' and</span>
<span class="linecomment">;;  `icicle-imenu-non-interactive-function'.  The definitions of these</span>
<span class="linecomment">;;  two search commands provide examples of using `icicle-search' with</span>
<span class="linecomment">;;  a predicate argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-imenu' Combines Benefits of Imenu and Emacs Tags")</span>
<span class="linecomment">;;  *** `icicle-imenu' Combines Benefits of Imenu and Emacs Tags ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Imenu lets you navigate among definitions in a single buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Emacs tags let you navigate among definitions in multiple files,</span>
<span class="linecomment">;;    but you must build and update the tags file that identifies the</span>
<span class="linecomment">;;    definitions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like Emacs tags, `icicle-imenu' lets you navigate among</span>
<span class="linecomment">;;  definitions in multiple files - and also multiple bookmarks and</span>
<span class="linecomment">;;  multiple non-file buffers.  Like Imenu, you need not build a tags</span>
<span class="linecomment">;;  file.  Unlike Imenu, Icicles provides regexp completion that lets</span>
<span class="linecomment">;;  you filter Imenu hits that you want to visit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another difference from Emacs tags, besides the need for a tags</span>
<span class="linecomment">;;  file, is that, since Icicles locates definitions using Imenu</span>
<span class="linecomment">;;  regexps, you can only navigate among definitions in buffers that</span>
<span class="linecomment">;;  you are visiting.  This is both an advantage and a disadvantage:</span>
<span class="linecomment">;;  you can narrow the search to certain files, but you must know</span>
<span class="linecomment">;;  which files to search. And if you want to search all files, then</span>
<span class="linecomment">;;  you must open them all (e.g. by matching a project regexp),</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The differences mean that `icicle-imenu' does not provide a</span>
<span class="linecomment">;;  substitute for Emacs tags; it provides some similar</span>
<span class="linecomment">;;  functionality. It is another tool in your belt, handier in some</span>
<span class="linecomment">;;  situations than using tags, and less useful in some other</span>
<span class="linecomment">;;  situations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Icicles Enhancements for Emacs Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Compile/Grep Search")</span>
<span class="linecomment">;;  ** Compile/Grep Search **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In a compilation-results buffer, such as `*Compilation*' or</span>
<span class="linecomment">;;  `*grep*', you can use command `icicle-compilation-search', bound</span>
<span class="linecomment">;;  to `C-c `', to search among the result set (search hits).  This is</span>
<span class="linecomment">;;  similar to `icicle-search', but when you use `C-RET', `C-mouse-2',</span>
<span class="linecomment">;;  `C-down', `C-up', `C-next', `C-prior', `C-end', or `C-home', it</span>
<span class="linecomment">;;  visits the source code that corresponds to the current line in the</span>
<span class="linecomment">;;  compilation buffer.  Just as for `icicle-search', you can narrow</span>
<span class="linecomment">;;  the set of search contexts by typing a regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using `icicle-compilation-search' with `grep' gives you two levels</span>
<span class="linecomment">;;  of regexp searching: 1) the `grep' regexp and 2) your current</span>
<span class="linecomment">;;  input regexp.  And you can of course use progressive completion</span>
<span class="linecomment">;;  (`M-*') to add any number of additional levels.  (And, starting</span>
<span class="linecomment">;;  with Emacs 22, you can pipe to other `grep' commands in the same</span>
<span class="linecomment">;;  `M-x grep'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Emacs 22 and later, you can also replace search-hit text.  You</span>
<span class="linecomment">;;  can replace the entire grep regexp match or just the part of it</span>
<span class="linecomment">;;  that matches your current input, depending on the value of option</span>
<span class="linecomment">;;  `icicle-search-replace-whole-candidate-flag' (which you can toggle</span>
<span class="linecomment">;;  with `M-_').  Replacement acts here just as it does for</span>
<span class="linecomment">;;  `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also use a non-`grep' compilation buffer to perform search</span>
<span class="linecomment">;;  and replace.  Use it, for example, to correct errors in source</span>
<span class="linecomment">;;  files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles thus gives you several ways to perform search-and-replace</span>
<span class="linecomment">;;  throughout multiple files: `grep'/compilation, `icicle-occur', and</span>
<span class="linecomment">;;  `icicle-search'.  The latter is of course not limited to</span>
<span class="linecomment">;;  line-by-line search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also: (@&gt; "Search and Replace").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Input Reuse in Interactive Interpreter Modes")</span>
<span class="linecomment">;;  ** Input Reuse in Interactive Interpreter Modes **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In an interactive interpreter mode such as `shell-mode' or</span>
<span class="linecomment">;;  interactive Lisp mode, you can search for and reuse a previous</span>
<span class="linecomment">;;  input, possibly editing it first.  Command `icicle-comint-search',</span>
<span class="linecomment">;;  bound to `C-c `', lets you use Icicles completion and cycling to</span>
<span class="linecomment">;;  access your previous (shell or Lisp) inputs; it uses</span>
<span class="linecomment">;;  `icicle-search', so it highlights your regexp input matches, and</span>
<span class="linecomment">;;  so on.  You can use `C-$' at any time to toggle removal of</span>
<span class="linecomment">;;  duplicate past inputs as completion candidates; by default,</span>
<span class="linecomment">;;  duplicates are removed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Being a search command, however, `icicle-comint-search' has access</span>
<span class="linecomment">;;  only to the commands that are visible in the buffer.  It does not</span>
<span class="linecomment">;;  use the `comint-input-ring', so it cannot, for instance, give you</span>
<span class="linecomment">;;  access to commands used in a previous session, which might have</span>
<span class="linecomment">;;  been recorded in a history file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another Icicles command, `icicle-comint-command', which is not a</span>
<span class="linecomment">;;  search command, does use `comint-input-ring' and does give you</span>
<span class="linecomment">;;  completion and cycling against previous inputs that might not have</span>
<span class="linecomment">;;  come from the current session.  It is bound to `C-c TAB' in</span>
<span class="linecomment">;;  `comint-mode' and derived modes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Define Your Own Icicles Search Commands")</span>
<span class="linecomment">;;  ** Define Your Own Icicles Search Commands **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `icicle-search' is not only a useful user command; it is</span>
<span class="linecomment">;;  also a framework for you to define your own Icicles search</span>
<span class="linecomment">;;  commands.  Consult the source code for the commands presented</span>
<span class="linecomment">;;  above for models.  And consult the doc string of `icicle-search'</span>
<span class="linecomment">;;  for more information about calling it non-interactively.  In</span>
<span class="linecomment">;;  particular, note that:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can pass a functional argument instead of a regexp to</span>
<span class="linecomment">;;    `icicle-search', and it will use that function to define the</span>
<span class="linecomment">;;    search contexts.  The function is passed, as arguments, the</span>
<span class="linecomment">;;    buffer to search, the beginning and end of the search region in</span>
<span class="linecomment">;;    that buffer, and any additional arguments that you pass to</span>
<span class="linecomment">;;    `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can pass a predicate argument to `icicle-search', in</span>
<span class="linecomment">;;    addition to passing a regexp, and the search contexts will be</span>
<span class="linecomment">;;    only those regexp matches that also satisfy the predicate.  The</span>
<span class="linecomment">;;    predicate takes two arguments, the search-context string and a</span>
<span class="linecomment">;;    marker at the end of the search context.  For information about</span>
<span class="linecomment">;;    this, consult the doc string for function</span>
<span class="linecomment">;;    `icicle-search-regexp-scan'.  For a model of using this feature,</span>
<span class="linecomment">;;    see the code that defines command `icicle-imenu'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By using your own function to define the search contexts, either</span>
<span class="linecomment">;;  from scratch or by limiting regexp matches using a predicate, you</span>
<span class="linecomment">;;  can perform semantic-based searching.  That is, your search</span>
<span class="linecomment">;;  command can use information besides syntax to define search hits.</span>
<span class="linecomment">;;  For instance, commands `icicle-imenu-command' and</span>
<span class="linecomment">;;  `icicle-imenu-non-interactive-function' use the semantic predicate</span>
<span class="linecomment">;;  `commandp' to distinguish Emacs-Lisp commands from non-interactive</span>
<span class="linecomment">;;  functions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for general information</span>
<span class="linecomment">;;    about Icicles search and the commands `icicle-search' and</span>
<span class="linecomment">;;    `icicle-occur'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Search and Replace") for information about replacing search</span>
<span class="linecomment">;;    hits or parts of search hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Multi-Commands") for</span>
<span class="linecomment">;;    information about using `C-RET', `C-mouse-2', `C-down', `C-up',</span>
<span class="linecomment">;;    `C-next', `C-prior', `C-end', and `C-home'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
<span class="linecomment">;;    for information about using any number of search regexps with</span>
<span class="linecomment">;;    `M-*' and any number of search predicates with `M-&'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Info Enhancements") for information about using</span>
<span class="linecomment">;;    Icicles with Info mode.</span>
 
<span class="linecomment">;;(@* "Icicles Bookmark Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Bookmark Enhancements</span>
<span class="linecomment">;;  -----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Many of the enhancements described in this section are available</span>
<span class="linecomment">;;  only if you also use library `bookmark+.el' (which I recommend).</span>
<span class="linecomment">;;  Bookmark+ is compatible with vanilla Emacs bookmarks across</span>
<span class="linecomment">;;  multiple Emacs versions.  It enhances the use of bookmarks in many</span>
<span class="linecomment">;;  ways.  The explanation here does not attempt to describe the</span>
<span class="linecomment">;;  Bookmark+ enhancements; it describes only the Icicles features</span>
<span class="linecomment">;;  that make use of them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One of the main Bookmark+ enhancements is support for new bookmark</span>
<span class="linecomment">;;  types.  Icicles provides type-specific bookmark commands and</span>
<span class="linecomment">;;  bookmark-candidate filtering.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, when you complete the names of some kinds of objects,</span>
<span class="linecomment">;;  you can use `C-x m' to choose objects of that type.  For example,</span>
<span class="linecomment">;;  when you use `icicle-dired' (`C-x d') to complete a directory</span>
<span class="linecomment">;;  name, you can use `C-x m' to choose among your Dired bookmarks.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc1.el" :to "Accessing Saved Locations (Bookmarks) on the Fly").</span>

<span class="linecomment">;;  Regardless of the bookmark type, another Bookmark+ feature that</span>
<span class="linecomment">;;  Icicles takes advantage of is the fact that a bookmark (any</span>
<span class="linecomment">;;  bookmark) can save not only a single position but a region, that</span>
<span class="linecomment">;;  is, two positions.  You can think of this as bookmarking, or</span>
<span class="linecomment">;;  saving, regions.  When you jump to a region bookmark, the region</span>
<span class="linecomment">;;  is activated (if option `bmkp-use-region' is non-`nil').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These are the main Icicles bookmarking features:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Tagging files (a la delicious) and jumping to tagged files</span>
<span class="linecomment">;;  * Bookmarking the region and selecting a bookmarked region</span>
<span class="linecomment">;;  * Setting a bookmark and jumping to a bookmark</span>
<span class="linecomment">;;  * Searching the text of a bookmark's buffer or region</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Each is described in a little more detail below.  More generally,</span>
<span class="linecomment">;;  however, the Bookmark+ doc is your friend.  See these sections of</span>
<span class="linecomment">;;  the Bookmark+ doc:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "bookmark+-doc.el" :to "Bookmark Tags")</span>
<span class="linecomment">;;  * (@file :file-name "bookmark+-doc.el" :to "Autofile Bookmarks")</span>
<span class="linecomment">;;  * (@file :file-name "bookmark+-doc.el" :to "Tag Commands and Keys")</span>
<span class="linecomment">;;  * (@file :file-name "bookmark+-doc.el" :to "Tags: Sets of Bookmarks")</span>
<span class="linecomment">;;  * (@file :file-name "bookmark+-doc.el" :to "Bookmark Tags Can Have Values")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Saving Regions and Selecting Them")</span>
<span class="linecomment">;;  ** Saving Regions and Selecting Them **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Saving the region just means bookmarking it.  As for any bookmark,</span>
<span class="linecomment">;;  it must have a name.  When you later jump to a region bookmark,</span>
<span class="linecomment">;;  the region is activated (provided option `bmkp-use-region' is</span>
<span class="linecomment">;;  non-`nil').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles gives you quick ways to save a region and select</span>
<span class="linecomment">;;  (activate) a saved region.  You can do both using `C-x C-x'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * With no prefix arg, `C-x C-x' exchanges point and mark</span>
<span class="linecomment">;;    (activating the region), as usual.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * With a plain prefix arg (`C-u'), `C-x C-x' jumps to a region</span>
<span class="linecomment">;;    bookmark that you choose using completion, and activates it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * With a numeric prefix arg, `C-x C-x' saves the region.  If the</span>
<span class="linecomment">;;    prefix arg is negative, then you are prompted for the name to</span>
<span class="linecomment">;;    use.  Otherwise, the bookmark is named automatically using the</span>
<span class="linecomment">;;    buffer name plus ": " plus the first</span>
<span class="linecomment">;;    `icicle-bookmark-name-length-max' characters of the region text.</span>
<span class="linecomment">;;    (Newline characters are changed to spaces for the name.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    So if (a) you are visiting buffer `foo', (b) the region text</span>
<span class="linecomment">;;    starts with "Arise, you wretched of the earth! For justice</span>
<span class="linecomment">;;    thunders condemnation: A better world's in birth!", and (c) the</span>
<span class="linecomment">;;    value of option `icicle-bookmark-name-length-max' is 15, then</span>
<span class="linecomment">;;    `C-9 C-x C-x' sets the region bookmark named `foo: Arise, you'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Setting a Bookmark and Jumping to a Bookmark")</span>
<span class="linecomment">;;  ** Setting a Bookmark and Jumping to a Bookmark **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as `C-x C-x' lets you either set or jump to a region</span>
<span class="linecomment">;;  bookmark, so `C-x r m' lets you either set or jump to any</span>
<span class="linecomment">;;  bookmark.  `C-x r m' is the vanilla Emacs key for setting a</span>
<span class="linecomment">;;  bookmark.  In Icicle mode it is bound by default to command</span>
<span class="linecomment">;;  `icicle-bookmark-cmd'. (By default, whatever keys are normally</span>
<span class="linecomment">;;  bound to `bookmark-set' are remapped in Icicle mode to</span>
<span class="linecomment">;;  `icicle-bookmark-cmd'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * With no prefix arg or a plain prefix arg (`C-u'), `C-x r m' acts</span>
<span class="linecomment">;;    like `icicle-bookmark-set'.  This is similar to `bookmark-set',</span>
<span class="linecomment">;;    but if you use Bookmark+ then you can use (lax) completion,</span>
<span class="linecomment">;;    choosing from existing bookmarks for the same buffer.  This</span>
<span class="linecomment">;;    makes it easy to update a nearby bookmark.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The same completion enhancements are available as for bookmark</span>
<span class="linecomment">;;    jumping - see (@&gt; "Jumping to a Bookmark"), below.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * With a negative prefix arg, `C-x r m' jumps to a bookmark (with</span>
<span class="linecomment">;;    completion).  See (@&gt; "Jumping to a Bookmark"), below.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * With a non-negative prefix arg, `C-x r m' sets a bookmark,</span>
<span class="linecomment">;;    automatically naming it.  This is like the automatic naming for</span>
<span class="linecomment">;;    a region bookmark, except that instead of including a prefix of</span>
<span class="linecomment">;;    the region text, the name includes text from the current line</span>
<span class="linecomment">;;    that starts at point.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    So if the cursor in buffer `foo' is on the `y' in a line with</span>
<span class="linecomment">;;    the text "Arise, you wretched of the earth!", then the bookmark</span>
<span class="linecomment">;;    will automatically be named `foo: you wretch'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If the prefix argument is 0, then the new bookmark does not</span>
<span class="linecomment">;;    overwrite any existing bookmark with the same name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Jumping to a Bookmark")</span>
<span class="linecomment">;;  ** Jumping to a Bookmark **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles commands that jump to a bookmark are multi-commands: you</span>
<span class="linecomment">;;  can use them to jump to any number of bookmarks in a single</span>
<span class="linecomment">;;  invocation.  Each jump command acts as a bookmark browser.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As with most Icicles tripping commands, after you jump to a</span>
<span class="linecomment">;;  (non-region) bookmark, the cursor position is highlighted using</span>
<span class="linecomment">;;  cross hairs, if you also use library `crosshairs.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Bookmark names are highlighted in buffer `*Completions*' to</span>
<span class="linecomment">;;  indicate the bookmark type.  The faces used are those defined by</span>
<span class="linecomment">;;  Bookmark+.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If option `icicle-show-multi-completion-flag' is non-`nil', then</span>
<span class="linecomment">;;  each completion candidate is a multi-completion, with up to three</span>
<span class="linecomment">;;  parts: the bookmark name, the bookmark file or buffer name, and</span>
<span class="linecomment">;;  any (del.icio.us-style) tags the bookmark has.  You can toggle</span>
<span class="linecomment">;;  option `icicle-show-multi-completion-flag' (for the next command)</span>
<span class="linecomment">;;  using `M-m' during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When using multi-completion candidates, you can match any of the</span>
<span class="linecomment">;;  multi-completion parts.  For example, you can match all bookmarks</span>
<span class="linecomment">;;  that have any tags by typing this when choosing a bookmark:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-M-j . * C-M-j S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Or match all bookmarks whose names match `P42' and whose tags</span>
<span class="linecomment">;;  match `blue':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    P 4 2 . * C-M-j . * C-M-j . * b l u e S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (Each `C-M-j' inserts `^G\n', which is `icicle-list-join-string'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-M-RET' shows detailed info about the current bookmark</span>
<span class="linecomment">;;  completion candidate.  `C-u C-M-RET' shows the complete, internal</span>
<span class="linecomment">;;  info for the bookmark.  Likewise, for the other candidate help</span>
<span class="linecomment">;;  keys: `C-M-down' etc.  And the mode line always shows summary</span>
<span class="linecomment">;;  info about the current bookmark.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During bookmark completion you can sort the candidates in various</span>
<span class="linecomment">;;  bookmark-specific ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * By the current (latest) `*Bookmark List*' order</span>
<span class="linecomment">;;  * By bookmark name</span>
<span class="linecomment">;;  * By last access as a bookmark (date + time)</span>
<span class="linecomment">;;  * By bookmark visit frequency (number of times visited)</span>
<span class="linecomment">;;  * By last buffer or file access (date + time)</span>
<span class="linecomment">;;  * With marked bookmarks before unmarked (in `*Bookmark List*')</span>
<span class="linecomment">;;  * By file name</span>
<span class="linecomment">;;  * By (local) file type</span>
<span class="linecomment">;;  * By (local) file size</span>
<span class="linecomment">;;  * By last (local) file access (date + time)</span>
<span class="linecomment">;;  * By last (local) file update (date + time)</span>
<span class="linecomment">;;  * By Info location (manual and node)</span>
<span class="linecomment">;;  * By Gnus thread</span>
<span class="linecomment">;;  * By URL</span>
<span class="linecomment">;;  * By bookmark type</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The most general Icicles jump commands are `icicle-bookmark' and</span>
<span class="linecomment">;;  `icicle-bookmark-other-window'.  In Icicle mode these are bound to</span>
<span class="linecomment">;;  whatever `bookmark-jump' and `bookmark-jump-other-window' are</span>
<span class="linecomment">;;  normally bound to.  If you use Bookmark+, the default bindings are</span>
<span class="linecomment">;;  `C-x j j' and `C-x 4 j j', respectively.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use these commands, you can narrow the completion</span>
<span class="linecomment">;;  candidates to bookmarks of a specific type using these keys:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-M-b'   - non-file (buffer) bookmarks</span>
<span class="linecomment">;;  `C-M-B'   - bookmark-list bookmarks</span>
<span class="linecomment">;;  `C-M-d'   - Dired bookmarks</span>
<span class="linecomment">;;  `C-M-f'   - file bookmarks</span>
<span class="linecomment">;;  `C-M-F'   - local-file bookmarks</span>
<span class="linecomment">;;  `C-M-g'   - Gnus bookmarks</span>
<span class="linecomment">;;  `C-M-I'   - Info bookmarks</span>
<span class="linecomment">;;  `C-M-K'   - desktop bookmarks</span>
<span class="linecomment">;;  `C-M-m'   - `man' pages</span>
<span class="linecomment">;;  `C-M-r'   - bookmarks with regions</span>
<span class="linecomment">;;  `C-M-u'   - URL bookmarks</span>
<span class="linecomment">;;  `C-M-w'   - W3M (URL) bookmarks</span>
<span class="linecomment">;;  `C-M-@'   - remote-file bookmarks</span>
<span class="linecomment">;;  `C-M-= b' - bookmarks for a specific buffer</span>
<span class="linecomment">;;  `C-M-= f' - bookmarks for a specific file</span>
<span class="linecomment">;;  `C-M-= .' - bookmarks for the current buffer</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, there are individual jump commands for bookmarks of</span>
<span class="linecomment">;;  each of each type, and these commands are bound by default to keys</span>
<span class="linecomment">;;  with the prefix `C-x 4 j' that use the same mnemonic characters as</span>
<span class="linecomment">;;  for narrowing.  For example, `icicle-bookmark-info-other-window'</span>
<span class="linecomment">;;  is bound to `C-x 4 j i'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Commands `icicle-bookmark' and `icicle-bookmark-other-window' can</span>
<span class="linecomment">;;  use a cache for the set of available bookmarks.  This improves</span>
<span class="linecomment">;;  performance, especially if you have a lot of bookmarks.  The</span>
<span class="linecomment">;;  downside is that the list of completion candidates is not</span>
<span class="linecomment">;;  automatically updated when you add new bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, this caching is off, so the set of possible bookmark</span>
<span class="linecomment">;;  candidates is always up-to-date.  You can turn on this caching by</span>
<span class="linecomment">;;  setting option `icicle-bookmark-refresh-cache-flag' to `nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Alternatively, you can use a prefix argument to reverse the effect</span>
<span class="linecomment">;;  of this option.  If you have a lot of bookmarks then I recommend</span>
<span class="linecomment">;;  that you customize the option to `nil' and just update it</span>
<span class="linecomment">;;  occasionally by using `C-u' for bookmark completion.  That will</span>
<span class="linecomment">;;  temporarily turn off caching so that the current jump command</span>
<span class="linecomment">;;  refreshes (updates) the cache.  The default value of the option is</span>
<span class="linecomment">;;  `t' only to avoid confusion for new users.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The bookmarks cache is also used for searching bookmarks (see</span>
<span class="linecomment">;;  next).  The type-specific bookmark jump commands</span>
<span class="linecomment">;;  (e.g. `icicle-bookmark-info-other-window') do not use the cache,</span>
<span class="linecomment">;;  since they typically use a smaller number of candidates.  And the</span>
<span class="linecomment">;;  cache is automatically updated whenever you use `S-delete' to</span>
<span class="linecomment">;;  delete a candidate bookmark.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Icicles Tripping")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Searching Bookmarked Objects")</span>
<span class="linecomment">;;  ** Searching Bookmarked Objects **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles search (and replace) lets you search across multiple</span>
<span class="linecomment">;;  buffers, files, or bookmarks.  This is true for nearly all Icicles</span>
<span class="linecomment">;;  search commands.  You use a plain prefix argument to specify</span>
<span class="linecomment">;;  bookmark searching.  For command `icicle-search' itself (`C-u C-c</span>
<span class="linecomment">;;  `'), you can alternatively use the specific command</span>
<span class="linecomment">;;  `icicle-search-bookmarks-together'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you do this you first choose the bookmarks to search, using</span>
<span class="linecomment">;;  completion.  Use `C-RET' and similar multi-command actions to</span>
<span class="linecomment">;;  choose (use `RET' for the final choice).  Once you have chosen the</span>
<span class="linecomment">;;  bookmarks, you type a search pattern to narrow the set of</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (Multi-command `icicle-bookmark-list' similarly lets you choose</span>
<span class="linecomment">;;  bookmark names.  It returns them as a Lisp list of strings.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you search the text of a region bookmark, the search is</span>
<span class="linecomment">;;  limited to the region.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to using `C-u' with the general Icicles search</span>
<span class="linecomment">;;  commands, you can use the following Icicles search commands that</span>
<span class="linecomment">;;  are specific to bookmarks:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * icicle-search-bookmark</span>
<span class="linecomment">;;  * icicle-search-autofile-bookmark</span>
<span class="linecomment">;;  * icicle-search-bookmark-list-bookmark</span>
<span class="linecomment">;;  * icicle-search-desktop-bookmark</span>
<span class="linecomment">;;  * icicle-search-dired-bookmark</span>
<span class="linecomment">;;  * icicle-search-file-bookmark</span>
<span class="linecomment">;;  * icicle-search-gnus-bookmark</span>
<span class="linecomment">;;  * icicle-search-info-bookmark</span>
<span class="linecomment">;;  * icicle-search-local-file-bookmark</span>
<span class="linecomment">;;  * icicle-search-man-bookmark</span>
<span class="linecomment">;;  * icicle-search-non-file-bookmark</span>
<span class="linecomment">;;  * icicle-search-region-bookmark</span>
<span class="linecomment">;;  * icicle-search-remote-file-bookmark</span>
<span class="linecomment">;;  * icicle-search-specific-buffers-bookmark</span>
<span class="linecomment">;;  * icicle-search-specific-files-bookmark</span>
<span class="linecomment">;;  * icicle-search-this-buffer-bookmark</span>
<span class="linecomment">;;  * icicle-search-url-bookmark</span>
<span class="linecomment">;;  * icicle-search-w3m-bookmark </span>
<span class="linecomment">;;  * icicle-search-all-tags-bookmark</span>
<span class="linecomment">;;  * icicle-search-all-tags-regexp-bookmark</span>
<span class="linecomment">;;  * icicle-search-some-tags-bookmark</span>
<span class="linecomment">;;  * icicle-search-some-tags-regexp-bookmark</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-search-bookmark' is a general command; the others are each</span>
<span class="linecomment">;;  specific to a certain kind of bookmark candidate, and they need</span>
<span class="linecomment">;;  library `bookmark+.el'.  The last four let you search bookmarks</span>
<span class="linecomment">;;  that have a certain set of tags.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All of these commands act the same way.  They are multi-commands,</span>
<span class="linecomment">;;  so you can use them to search multiple bookmarks.  But unlike</span>
<span class="linecomment">;;  `icicle-search-bookmarks-together' (`C-u C-c `'), you do not first</span>
<span class="linecomment">;;  choose all of the bookmarks and then search them together.</span>
<span class="linecomment">;;  Instead, you search them one at a time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-search-bookmark' is flexible, letting you specify any set</span>
<span class="linecomment">;;  of bookmarks to use as candidates.  The candidates are the</span>
<span class="linecomment">;;  bookmarks last shown in the `*Bookmark List*' display (list</span>
<span class="linecomment">;;  `bmkp-sorted-alist', to be precise).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use the Bookmark+ features of `*Bookmark List*' to limit</span>
<span class="linecomment">;;  the candidates to bookmarks of a certain type (e.g., only</span>
<span class="linecomment">;;  autofiles, using `A S'), bookmarks with certain tags (e.g., only</span>
<span class="linecomment">;;  those with tags matching a regexp using `T m %' followed by `&gt;'),</span>
<span class="linecomment">;;  and so on.  Whatever set of bookmarks are shown (or were last</span>
<span class="linecomment">;;  shown) in `*Bookmark List*' are the bookmarks to be searched.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for information about</span>
<span class="linecomment">;;    command `icicle-search'.</span>
<span class="linecomment">;;  * (@&gt; "Jumping to a Bookmark") for information about bookmark</span>
<span class="linecomment">;;    caching.  Caching is also used for bookmark searching.</span>
<span class="linecomment">;;  * (@&gt; "Support for Projects")</span>
 
<span class="linecomment">;;(@* "Icicles Enhancements for Emacs Tags")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Enhancements for Emacs Tags</span>
<span class="linecomment">;;  -----------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Emacs and Icicles, the word "tag" is used in multiple ways.</span>
<span class="linecomment">;;  This section is about tags as identifiers of source-code</span>
<span class="linecomment">;;  definitions.  Emacs uses tags files, typically named `TAGS', to</span>
<span class="linecomment">;;  index these definition locations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What constitutes a "definition" is determined by the content of</span>
<span class="linecomment">;;  the tags file.  Typically, definition recognition is available for</span>
<span class="linecomment">;;  programming languages, but in fact a tags table can record any</span>
<span class="linecomment">;;  text at all as a definition.  That is, if you create your own tags</span>
<span class="linecomment">;;  table, you can use the Emacs tags feature to navigate among any</span>
<span class="linecomment">;;  "definitions" of your own choosing.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `M-g' in the minibuffer to toggle option</span>
<span class="linecomment">;;  `icicle-use-C-for-actions-flag', then you can use just `next'</span>
<span class="linecomment">;;  instead of `C-next' to navigate when using any of the Icicles tags</span>
<span class="linecomment">;;  browsing commands described here.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Support for Projects")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-find-tag': Find Tags in All Tags Tables")</span>
<span class="linecomment">;;  ** `icicle-find-tag': Find Tags in All Tags Tables **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In vanilla Emacs, you use commands such as `find-tag' (`M-.') to</span>
<span class="linecomment">;;  find a tag, `tags-loop-continue' (`M-,') to find another matching</span>
<span class="linecomment">;;  tag, `tags-apropos' to list all tags that match a regexp, and</span>
<span class="linecomment">;;  `list-tags' to show all tags (definitions) in a given source file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can use multi-command `icicle-find-tag', bound to</span>
<span class="linecomment">;;  `M-.' in Icicle mode, to do all of this.  It is similar to the</span>
<span class="linecomment">;;  Icicles search commands.  It is a general tags browser, just as</span>
<span class="linecomment">;;  `icicle-imenu' is an Imenu browser.  Being a multicommand, you can</span>
<span class="linecomment">;;  visit any number of tags, in any order, in a single `M-.'</span>
<span class="linecomment">;;  invocation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With `icicle-find-tag', you enter (using `RET') a regexp to match</span>
<span class="linecomment">;;  the tags you want to visit.  By default, all tags in all tags</span>
<span class="linecomment">;;  files are searched, and the matches become completion candidates</span>
<span class="linecomment">;;  (which you can of course match further by typing another pattern).</span>
<span class="linecomment">;;  As always, you can use progressive completion, chip away the</span>
<span class="linecomment">;;  non-elephant, and so on.  Just as with Icicles search commands,</span>
<span class="linecomment">;;  you use `C-RET', `C-mouse-2', `C-next', and so on, to visit the</span>
<span class="linecomment">;;  search hits.  You can use `M-*' (`icicle-pop-mark') to return to</span>
<span class="linecomment">;;  the place you invoked `M-.'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, the completion candidates are multi-completions: the</span>
<span class="linecomment">;;  source file name is included.  This is an important aid, because</span>
<span class="linecomment">;;  there can be similar, or even identical, tags in different source</span>
<span class="linecomment">;;  files.  Your current input can of course filter the source-file</span>
<span class="linecomment">;;  name also, excluding certain files from the search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A prefix argument  changes the default behavior, as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If non-negative (&gt;= 0), then only the current tag table is used,</span>
<span class="linecomment">;;    instead of all tag tables.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If non-positive (&lt;= 0), then the source file name is not part of</span>
<span class="linecomment">;;    the completion candidate; only the tag itself is used.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for general information</span>
<span class="linecomment">;;    about Icicles search commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Nutshell View of Icicles")</span>
<span class="linecomment">;;    for information about progressive completion and chipping away</span>
<span class="linecomment">;;    the non-elephant.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-find-first-tag': Find First Tag in Current Table")</span>
<span class="linecomment">;;  ** `icicle-find-first-tag': Find First Tag in Current Table **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes you do not need the full power and flexibility of</span>
<span class="linecomment">;;  `icicle-find-tag'.  If you just want to find the first tag among</span>
<span class="linecomment">;;  several duplicates that match your input, and you just want to use</span>
<span class="linecomment">;;  the current tags table, then you can use `icicle-find-first-tag'</span>
<span class="linecomment">;;  or `icicle-find-first-tag-other-window'.  These commands are like</span>
<span class="linecomment">;;  vanilla `find-tag', but they are multi-commands, so you can visit</span>
<span class="linecomment">;;  any number of tags in one invocation.  Unlike `find-tag', however,</span>
<span class="linecomment">;;  you cannot follow up to find another tag that matches using `M-,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-tags-search': Search and Replace Using Tags")</span>
<span class="linecomment">;;  ** `icicle-tags-search': Search and Replace Using Tags **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In vanilla Emacs, you use commands `tags-search',</span>
<span class="linecomment">;;  `tags-query-replace', and `tags-loop-continue' (`M-,') to search</span>
<span class="linecomment">;;  and replace text in source files whose definitions are indexed in</span>
<span class="linecomment">;;  a tags file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, you can use multi-command `icicle-tags-search' to</span>
<span class="linecomment">;;  search and replace.  It is in fact just command `icicle-search'</span>
<span class="linecomment">;;  applied to the relevant source files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also (@&gt; "Icicles Search Commands, Overview") for information</span>
<span class="linecomment">;;  about `icicle-search.</span>
 
<span class="linecomment">;;(@* "Icicles Shell-Command Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Shell-Command Enhancements</span>
<span class="linecomment">;;  ----------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides completion support for shell commands in these</span>
<span class="linecomment">;;  ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In Shell mode and related modes, it enhances completion of</span>
<span class="linecomment">;;    commands, previous inputs (commands plus their switches and</span>
<span class="linecomment">;;    arguments), file names, and environment variables.</span>
<span class="linecomment">;;    See (@&gt; "Completion in Comint Modes").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In any buffer, it provides Icicles completion for `M-!' and</span>
<span class="linecomment">;;    `M-|'.  This is an optional feature that is not enabled by</span>
<span class="linecomment">;;    default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In Dired mode, it provides Icicles completion for `!', and `&'.</span>
<span class="linecomment">;;    See (@&gt; "Shell Commands on Marked Files").  This is an optional</span>
<span class="linecomment">;;    feature that is not enabled by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section describes the optional Icicles completion available</span>
<span class="linecomment">;;  for `M-!' and `M-|'.  It applies also to completion for `!', and</span>
<span class="linecomment">;;  `&' in Dired (but those have additional enhancements).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In vanilla Emacs, when you enter a shell command at the prompt for</span>
<span class="linecomment">;;  `M-!' or `M-|', no completion is available for Emacs prior to</span>
<span class="linecomment">;;  Emacs 23.  In Emacs 23, no completion is available for empty</span>
<span class="linecomment">;;  input, and non-empty input is completed only to a shell command</span>
<span class="linecomment">;;  that is in your search path.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicle mode, `M-!' and `M-|' can, like in vanilla Emacs 23,</span>
<span class="linecomment">;;  complete using commands in your search path.  This depends on the</span>
<span class="linecomment">;;  the value of option `icicle-guess-commands-in-path' (see below).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Shell Command Completion as File-Name Completion")</span>
<span class="linecomment">;;  ** Shell Command Completion as File-Name Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The most significant thing about Icicles completion for reading a</span>
<span class="linecomment">;;  shell command is that it is in fact *file-name* completion.</span>
<span class="linecomment">;;  Reading a shell command means, first, reading a file name.  This</span>
<span class="linecomment">;;  is unexpected, to say the least.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because of this unusual behavior, this feature is optional and is</span>
<span class="linecomment">;;  not enabled by default.  To enable it, customize option</span>
<span class="linecomment">;;  `icicle-functions-to-redefine' to add the shell-related functions</span>
<span class="linecomment">;;  `dired-read-shell-command' and `read-shell-command'.  If you do</span>
<span class="linecomment">;;  that, then Icicle mode will substitute Icicles functions for these</span>
<span class="linecomment">;;  standard functions and you will get the Icicles completion</span>
<span class="linecomment">;;  described here.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A shell command is itself an executable file, either a binary</span>
<span class="linecomment">;;  program or a script.  That's not so shocking.  But since Icicles</span>
<span class="linecomment">;;  uses file-name completion for your entire shell-command input,</span>
<span class="linecomment">;;  including any switches (options) and command arguments, all of</span>
<span class="linecomment">;;  that input is interpreted by `read-file-name' as a file name,</span>
<span class="linecomment">;;  before it gets passed on to the shell.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The reason for providing file-name completion for a shell command</span>
<span class="linecomment">;;  is to let you easily invoke a program no matter where it resides,</span>
<span class="linecomment">;;  whether or not its directory is in your search path.  You can use</span>
<span class="linecomment">;;  completion to navigate to the command's location.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles shell-command completion is lax, so you can enter any</span>
<span class="linecomment">;;  command you want, not just a file-name completion candidate.  And</span>
<span class="linecomment">;;  you can edit the completed input before hitting `RET', to add</span>
<span class="linecomment">;;  command switches (options) and arguments.  The overall input</span>
<span class="linecomment">;;  string is taken as a (pseudo) file name, but it is then passed to</span>
<span class="linecomment">;;  the shell for execution.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Gotcha: `$' in Shell Commands")</span>
<span class="linecomment">;;  ** Gotcha: `$' in Shell Commands **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There is a gotcha, however, regarding `$' and file-name input:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you hit `RET' to accept the input, `read-file-name' finishes</span>
<span class="linecomment">;;  its job, as always, by trying to expand any environment variables</span>
<span class="linecomment">;;  in the string.  Usually this is what you want, and it presents no</span>
<span class="linecomment">;;  problem.  But in the context of a shell another `$' syntax is also</span>
<span class="linecomment">;;  used.  For example, `$1' typically means the first argument or</span>
<span class="linecomment">;;  first field; it does not mean a variable named `1'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `read-file-name' knows nothing about this different `$' syntax,</span>
<span class="linecomment">;;  and it systematically calls `substitute-in-file-name' to expand</span>
<span class="linecomment">;;  any environment variables in the file name you enter (when you hit</span>
<span class="linecomment">;;  `RET').  It interprets `$1' the same way it inteprets `$PATH',</span>
<span class="linecomment">;;  treating `1' as an (unknown) environment variable.  This is not</span>
<span class="linecomment">;;  what you want it to do.  If you input `awk '{print $1}' Emacs</span>
<span class="linecomment">;;  raises this error:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Substituting nonexistent environment variable "1"</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What can you do about this?  Three possible approaches:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Do not use this Icicles feature at all.  The feature is turned</span>
<span class="linecomment">;;    off, by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can escape a dollar sign by doubling it: use `$$' instead of</span>
<span class="linecomment">;;    `$' when you want to pass a `$' to the shell and not let</span>
<span class="linecomment">;;    `read-file-name' try to interpret it in terms of an environment</span>
<span class="linecomment">;;    variable.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can turn off Icicle mode temporarily whenever you use a</span>
<span class="linecomment">;;    complex command that involves `$': `M-x icy-mode'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Known Shell Commands as Proxy Candidates")</span>
<span class="linecomment">;;  ** Known Shell Commands as Proxy Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you do turn on Icicles file-name completion for reading shell</span>
<span class="linecomment">;;  commands, then extra, known shell commands are also made available</span>
<span class="linecomment">;;  as proxy completion candidates, provided that option</span>
<span class="linecomment">;;  `icicle-guess-commands-in-path' is non-`nil' (it is `nil' by</span>
<span class="linecomment">;;  default).  These extra candidates are the names of all executable</span>
<span class="linecomment">;;  files (or of all files, if `shell-completion-execonly' is `nil')</span>
<span class="linecomment">;;  in your search path.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The fact that these are Icicles proxy candidates means that they</span>
<span class="linecomment">;;  are available regardless of the current default-directory - they</span>
<span class="linecomment">;;  are not in fact treated as file-name candidates, even though they</span>
<span class="linecomment">;;  are available during file-name completion.  You can easily</span>
<span class="linecomment">;;  recognize Icicles proxy candidates in buffer `*Completions*': they</span>
<span class="linecomment">;;  have face `icicle-proxy-candidates'.  See </span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Completions Display").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If `icicle-guess-commands-in-path' is non-`nil', the list of</span>
<span class="linecomment">;;  search-path candidate commands is computed once and cached as the</span>
<span class="linecomment">;;  value of option `icicle-shell-command-candidates-cache'.  The</span>
<span class="linecomment">;;  particular non-`nil' value of `icicle-guess-commands-in-path'</span>
<span class="linecomment">;;  determines when the cache is filled.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the value of `icicle-guess-commands-in-path' is `first-use',</span>
<span class="linecomment">;;  the cache is filled the first time you use it, and each time you</span>
<span class="linecomment">;;  turn on Icicle mode it is updated.  If the value of</span>
<span class="linecomment">;;  `icicle-guess-commands-in-path' is `load', then the cache is</span>
<span class="linecomment">;;  instead filled each time you load Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Regardless of the non-`nil' value of</span>
<span class="linecomment">;;  `icicle-guess-commands-in-path', if you save</span>
<span class="linecomment">;;  `icicle-shell-command-candidates-cache', then that value is used</span>
<span class="linecomment">;;  in future sessions (no delay for searching your path).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If your environment changes, you can use command</span>
<span class="linecomment">;;  `icicle-recompute-shell-command-candidates' to update the cached</span>
<span class="linecomment">;;  list at any time.  With a prefix argument, the updated value is</span>
<span class="linecomment">;;  saved persistently.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to the extra candidates computed by searching your</span>
<span class="linecomment">;;  search path, in contexts such as Dired where target (e.g. marked)</span>
<span class="linecomment">;;  files for the shell command are known, the extra candidates</span>
<span class="linecomment">;;  include additional commands (possibly including switches) that</span>
<span class="linecomment">;;  Icicles can guess might be appropriate for the target files.</span>
<span class="linecomment">;;  See (@&gt; "Shell Commands on Marked Files").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During Icicles shell-command completion, help is available for</span>
<span class="linecomment">;;  individual candidates, using `C-M-RET', `C-M-mouse-2', and so on.</span>
<span class="linecomment">;;  For an extra candidate, help is provided for the command by the</span>
<span class="linecomment">;;  `apropos' shell command (if available).  For a file-name</span>
<span class="linecomment">;;  candidate, help shows the file's properties.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Get Help on Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Remember also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * After you have typed or completed the shell command per se</span>
<span class="linecomment">;;    (e.g. a file name or search-path command), you can use `C-M-S-f'</span>
<span class="linecomment">;;    (file-name completion on demand) to complete (relative) file</span>
<span class="linecomment">;;    names to insert as shell-command arguments as part of the</span>
<span class="linecomment">;;    command line to submit to the shell.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Completion On Demand").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `M-o' anytime in the minibuffer to complete against</span>
<span class="linecomment">;;    a previous input.  This means that if you have previously</span>
<span class="linecomment">;;    entered some complex shell command (e.g. with various switches</span>
<span class="linecomment">;;    or arguments), then you can use `M-o' to retrieve it for reuse</span>
<span class="linecomment">;;    (possibly editing it).  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc2.el" :to "Using Completion to Insert Previous Inputs: `M-o'")</span>
 
<span class="linecomment">;;(@* "Icicles Dired Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Dired Enhancements</span>
<span class="linecomment">;;  --------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles can help with Dired in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use Icicles search-and-replace on the marked files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can save marked file names as completion candidates for</span>
<span class="linecomment">;;    reuse later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can open Dired on saved file names, that is, names that you</span>
<span class="linecomment">;;    previously saved as a completion candidates set or as an Emacs</span>
<span class="linecomment">;;    fileset.  It does not matter how the file names were saved or</span>
<span class="linecomment">;;    which directories the files are in.  The set of saved file names</span>
<span class="linecomment">;;    can be persistent or just for the current Emacs session.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use file-name completion when you use `!'  or `&' to</span>
<span class="linecomment">;;    execute a shell command.  This is an optional feature that is</span>
<span class="linecomment">;;    not enabled by default.  See also (@&gt; "Icicles Shell-Command Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Search-and-Replace Marked Files")</span>
<span class="linecomment">;;  ** Search-and-Replace Marked Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Dired, `A' searches the marked files using a regexp, and `Q'</span>
<span class="linecomment">;;  launches `query-replace-regexp' on them.  But suppose that you</span>
<span class="linecomment">;;  want to change only a few occurrences in each file, perhaps among</span>
<span class="linecomment">;;  the first occurrences.  Using `Q', you are forced to review each</span>
<span class="linecomment">;;  search hit in turn - all of them; you cannot simply skip the rest</span>
<span class="linecomment">;;  in one file and continue with the next file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  [I suggested that this feature be added to Emacs, and it has been</span>
<span class="linecomment">;;  added in Emacs 23: you can now skip to the next file.]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One workaround is to use `M-&gt;' to go to the end of a file, and</span>
<span class="linecomment">;;  then `M-,' to resume query-replace.  Or you can quit the command</span>
<span class="linecomment">;;  altogether, unmark the file you're finished searching, and then</span>
<span class="linecomment">;;  hit `Q' again, but that's not very convenient.  A similar problem</span>
<span class="linecomment">;;  applies to searching using `A'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Dired with Icicles, you can use `M-s i'</span>
<span class="linecomment">;;  (`icicle-search-dired-marked') to search the files and possibly</span>
<span class="linecomment">;;  replace search hits.  This runs `icicle-search', so you have</span>
<span class="linecomment">;;  available all of its features, including accessing search hits</span>
<span class="linecomment">;;  directly, in any order.  To skip a whole file, just match its name</span>
<span class="linecomment">;;  with your minibuffer input and then use `C-~' to remove all of its</span>
<span class="linecomment">;;  occurrences from the set of hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: You can similarly use `M-s i' in Ibuffer or Buffer Menu to</span>
<span class="linecomment">;;  search all marked buffers using Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Save Marked Files as Completion Candidates")</span>
<span class="linecomment">;;  ** Save Marked Files as Completion Candidates **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Dired with Icicles, you can use `C-M-&gt;'</span>
<span class="linecomment">;;  (`icicle-dired-save-marked') to save the marked file names as a</span>
<span class="linecomment">;;  set of completion candidates, for reuse later (e.g., using</span>
<span class="linecomment">;;  `C-M-&lt;').  Similarly, you can use `C-&gt;' to add the marked files to</span>
<span class="linecomment">;;  an existing saved set of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These bindings act similarly to `C-M-&gt;' and `C-&gt;' in the</span>
<span class="linecomment">;;  minibuffer: a prefix argument controls whether you save candidates</span>
<span class="linecomment">;;  to a variable or a cache file.  Also, `C-M-}' saves to a variable</span>
<span class="linecomment">;;  you name, and `C-}' saves to a cache file - see</span>
<span class="linecomment">;;  (@* "Marked Files as a Project"), below.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use such a saved set of file names as candidates during</span>
<span class="linecomment">;;  file-name completion.  They are saved as absolute names,</span>
<span class="linecomment">;;  which means you can use them with, say, `C-u C-x C-f'.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Absolute File Names and Different Directories").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Open Dired for a Set of File Names")</span>
<span class="linecomment">;;  ** Open Dired for a Set of File Names **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Dired with Icicles you can use `C-M-&lt;'</span>
<span class="linecomment">;;  (`icicle-dired-chosen-files-other-window') to open Dired for a set</span>
<span class="linecomment">;;  of file or directory names that you choose interactively or that</span>
<span class="linecomment">;;  you have previously saved (persistently or not) as completion</span>
<span class="linecomment">;;  candidates or as an Emacs fileset.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, this opens Dired on all files whose names match the</span>
<span class="linecomment">;;  regexp `.*foo.*bar' (the initial `.*' is implicit):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-M-&lt;  foo.*bar  S-TAB  C-!  C-g</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Dired buffer that is created is named `Icy File Set' (suffixed</span>
<span class="linecomment">;;  with &lt;1&gt;, &lt;2&gt;, etc. as needed), and it contains only the chosen</span>
<span class="linecomment">;;  file names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The file names are checked to be sure they reference existing</span>
<span class="linecomment">;;  files.  If any of the names are relative names, those files are</span>
<span class="linecomment">;;  checked for existence in the Dired directory.  If you use a prefix</span>
<span class="linecomment">;;  argument, then you are prompted for the directory to use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Marked Files as a Project")</span>
<span class="linecomment">;;  ** Marked Files as a Project **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Just as `C-}' in the minibuffer is a shortcut for `C-u C-M-&gt;',</span>
<span class="linecomment">;;  which saves the current set of completion candidates persistently,</span>
<span class="linecomment">;;  so `C-}' in Dired saves the marked file names in a cache file or,</span>
<span class="linecomment">;;  with a prefix arg, an Emacs fileset.  Similarly, just as `C-{' in</span>
<span class="linecomment">;;  the minibuffer is a shortcut for `C-u C-M-&lt;', which retrieves</span>
<span class="linecomment">;;  candidates from a persistent set, so `C-{' in Dired retrieves a</span>
<span class="linecomment">;;  persistent set of file names and opens them in a separate Dired</span>
<span class="linecomment">;;  buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can think of such persistent file-name sets as projects.</span>
<span class="linecomment">;;  `C-}' is bound to command `icicle-dired-save-marked-as-project'</span>
<span class="linecomment">;;  (aka `icicle-dired-save-marked-persistently').  `C-{' is bound to</span>
<span class="linecomment">;;  command `icicle-dired-project-other-window'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Again, you can use such a project as a candidate set for file-name</span>
<span class="linecomment">;;  completion at any time.  In addition, `C-}' and `C-{' can be handy</span>
<span class="linecomment">;;  in Dired for working with projects even without using completion.</span>
<span class="linecomment">;;  The files in a project can be distributed among any directories</span>
<span class="linecomment">;;  anywhere.  This gives you an easy way to open Dired on just the</span>
<span class="linecomment">;;  files you want and operate on them there.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And while in a project in Dired you can use `C-M-&lt;' to mark a</span>
<span class="linecomment">;;  project subset to work on, and then use `C-M-&gt;' to operate on that</span>
<span class="linecomment">;;  subset using Icicles completion.  And you can have any number of</span>
<span class="linecomment">;;  projects - you access each by its name (with completion) and need</span>
<span class="linecomment">;;  not remember its cache file name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Shell Commands on Marked Files")</span>
<span class="linecomment">;;  ** Shell Commands on Marked Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is an optional feature that is not enabled by default.  See</span>
<span class="linecomment">;;  also (@&gt; "Icicles Shell-Command Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicle mode, `!' and `&' in Dired let you complete a shell</span>
<span class="linecomment">;;  command.  You can optionally use Icicles file-name completion for</span>
<span class="linecomment">;;  the shell command, by customizing option</span>
<span class="linecomment">;;  `icicle-functions-to-redefine' to add the shell-related functions</span>
<span class="linecomment">;;  `dired-read-shell-command' and `read-shell-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you do that, then Icicle mode will substitute Icicles functions</span>
<span class="linecomment">;;  for these standard functions and you will get the Icicles</span>
<span class="linecomment">;;  completion described here.  This is the same optional program-file</span>
<span class="linecomment">;;  completion that is available anywhere when a shell command is read</span>
<span class="linecomment">;;  (see (@&gt; "Icicles Shell-Command Enhancements")), but in Dired the</span>
<span class="linecomment">;;  extra, proxy candidates include commands that Icicles thinks might</span>
<span class="linecomment">;;  be particularly appropriate for the marked files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These proxy candidates are not necessarily only command names.</span>
<span class="linecomment">;;  They can include switches (options) that specialize a command.</span>
<span class="linecomment">;;  For example, if a PDF file (*.pdf) is marked in Dired, the</span>
<span class="linecomment">;;  completion candidates might include `gv -safer', `pdftotext ?  -',</span>
<span class="linecomment">;;  and `xpdf'.  The first two of these are not just command names</span>
<span class="linecomment">;;  (`-safer' is a command switch).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Starting with Emacs 23, Icicles uses both of the following methods</span>
<span class="linecomment">;;  to guess extra (proxy) candidates that are file type-specific:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * MIME-type associations</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The rules defined by user option `dired-guess-shell-alist-user'</span>
<span class="linecomment">;;    and variable `dired-guess-shell-alist-default' (provided you use</span>
<span class="linecomment">;;    Dired X, that is, standard library `dired-x.el')</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Prior to Emacs 23, MIME types are not used.  In the example of a</span>
<span class="linecomment">;;  PDF file, candidates `gv -safer' and `pdftotext ? -' are provided</span>
<span class="linecomment">;;  by MIME-type associations, and candidate `xpdf' is provided by the</span>
<span class="linecomment">;;  Dired X rules.  Note that you can customize the rules.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Any candidates that are specific to the marked files are Icicles</span>
<span class="linecomment">;;  proxy candidates - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Completions Display").</span>
<span class="linecomment">;;  These are available regardless of the current default-directory.</span>
<span class="linecomment">;;  They are not treated as file-name candidates, even though they are</span>
<span class="linecomment">;;  available during file-name completion.  Icicles proxy candidates</span>
<span class="linecomment">;;  have face `icicle-proxy-candidates' in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Again, everything that is true for shell-command completion</span>
<span class="linecomment">;;  elsewhere is also true for shell-command completion in Dired.  See</span>
<span class="linecomment">;;  (@&gt; "Icicles Shell-Command Enhancements").  This includes adding</span>
<span class="linecomment">;;  all commands from your search path as proxy candidates if option</span>
<span class="linecomment">;;  `icicle-guess-commands-in-path' is non-`nil', and providing help</span>
<span class="linecomment">;;  on individual candidates (shell commands or files) during</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Shell-Command Enhancements") for more information</span>
<span class="linecomment">;;    about shell-command completion</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates")</span>
<span class="linecomment">;;    for information about saved completion candidates</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;    for the use of `C-~' to remove matching candidates</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for information about</span>
<span class="linecomment">;;    `icicle-search'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Search and Replace") for how to replace selected search hits</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;    for more information about using persistent sets</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Support for Projects") for more information about working</span>
<span class="linecomment">;;    with projects</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `dired+.el', which has related features such as `C-M-*'</span>
<span class="linecomment">;;    to open Dired on just the marked files and `M-g' to `grep' just</span>
<span class="linecomment">;;    the marked files.</span>
 
<span class="linecomment">;;(@* "Icicles Info Enhancements")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Info Enhancements</span>
<span class="linecomment">;;  -------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles can help with Info in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Icicles completion is available for any input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `icicle-search' on part or all of a manual, if you</span>
<span class="linecomment">;;    flatten it first with `Info-merge-subnodes' .</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Completion for Info")</span>
<span class="linecomment">;;  ** Icicles Completion for Info **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever completion is available for Info commands, such as `g'</span>
<span class="linecomment">;;  (`Info-goto-node'), `i' (`Info-index'), and `m' (`Info-menu'), you</span>
<span class="linecomment">;;  can take advantage of Icicles completion.  For instance, if you</span>
<span class="linecomment">;;  type `g yan', you can use `S-TAB' for apropos completion and</span>
<span class="linecomment">;;  choose node `Isearch Yank', whose name contains `yan' but does not</span>
<span class="linecomment">;;  start with it.  This is an obvious and standard Icicles feature.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Although vanilla Emacs also accepts a substring as input for `i',</span>
<span class="linecomment">;;  it does not provide substring or regexp completion, and it will</span>
<span class="linecomment">;;  not accept a regexp as final input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles binds `g', `i', and `m' to multi-commands</span>
<span class="linecomment">;;  `icicle-Info-goto-node', `icicle-Info-index', and</span>
<span class="linecomment">;;  `icicle-Info-menu', which means that you can also use `g', `i',</span>
<span class="linecomment">;;  and `m' with `C-next', `C-RET', `C-mouse-2', and so on, to browse</span>
<span class="linecomment">;;  among matching Info nodes.  Unlike browsing with repeated use of</span>
<span class="linecomment">;;  `,' after `i' in vanilla Emacs, you can continue to see all of the</span>
<span class="linecomment">;;  matching candidates, in buffer `*Completions*', and you need not</span>
<span class="linecomment">;;  visit the index hits in sequential order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `M-g' in the minibuffer to toggle</span>
<span class="linecomment">;;  `icicle-use-C-for-actions-flag', then you can use just `next'</span>
<span class="linecomment">;;  instead of `C-next' to navigate.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Option `icicle-use-C-for-actions-flag'").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As usual in Icicles, you can sort completion candidates in various</span>
<span class="linecomment">;;  ways, using `C-,' (`icicle-change-sort-order').  For `g', in</span>
<span class="linecomment">;;  particular, although the default order is alphabetical, you can</span>
<span class="linecomment">;;  choose `in book order', which shows the node candidates in the</span>
<span class="linecomment">;;  same order as in the book.  In that case, using `g' and then</span>
<span class="linecomment">;;  navigating among candidates sequentially using `C-down', `C-up',</span>
<span class="linecomment">;;  `C-next', `C-prior', `C-end', or `C-home', visits the nodes in</span>
<span class="linecomment">;;  their natural order.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a special case of this, if you use a negative prefix argument</span>
<span class="linecomment">;;  (that is, `M-- g'), then not only are the candidate nodes</span>
<span class="linecomment">;;  presented `in book order', they are also limited to the nodes that</span>
<span class="linecomment">;;  follow your current location in the book - that is, to the</span>
<span class="linecomment">;;  remainder of the book.  (A non-negative numeric prefix argument</span>
<span class="linecomment">;;  has the same meaning as for `Info-goto-node'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, except when you are at the `Top' node, a pseudo-node</span>
<span class="linecomment">;;  `..' is added to the set of completion candidates.  Choosing this</span>
<span class="linecomment">;;  takes you up to the parent of the current node.  You can thus use</span>
<span class="linecomment">;;  `g' in Info not only to explore nodes by name, but also as another</span>
<span class="linecomment">;;  means to traverse the Info menu hierarchy.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Virtual Info Books")</span>
<span class="linecomment">;;  *** Virtual Info Books ***</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can take advantage of Icicles completion-candidate set</span>
<span class="linecomment">;;  operations to create your own virtual Info books.  That is, you</span>
<span class="linecomment">;;  can define and save sets of Info nodes or Info index entries, and</span>
<span class="linecomment">;;  then reuse them later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Both `m' and `g' in Info use nodes as candidates, so you can use</span>
<span class="linecomment">;;  `m' or `g' or a combination of `m' and `g' to define a node set,</span>
<span class="linecomment">;;  and you can use either `m' or `g' to reuse a node set.  A set of</span>
<span class="linecomment">;;  index entries is different: You must use `i' to create and reuse</span>
<span class="linecomment">;;  such a set.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Remember that you can define a candidate set incrementally, adding</span>
<span class="linecomment">;;  more elements using `C-&gt;', `C-)', `insert', `M-S-mouse-2',</span>
<span class="linecomment">;;  `M-mouse-3', or `mouse-1 mouse-3 mouse-3'.  And you can save a</span>
<span class="linecomment">;;  candidate set persistently. [*]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can even create a virtual book that includes Info nodes from</span>
<span class="linecomment">;;  different manuals.  For example, you might want to collect</span>
<span class="linecomment">;;  together specific nodes that deal with some particular topic, such</span>
<span class="linecomment">;;  as faces, from both the Emacs manual and the Elisp manual.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You do this using `C-u g' (a plain prefix argument).  This</span>
<span class="linecomment">;;  prepends the Info file name (book identifier) to each node-name</span>
<span class="linecomment">;;  completion candidate.  For example, when you are in the Emacs</span>
<span class="linecomment">;;  manual, each node candidate is prefixed by `(emacs)', and in the</span>
<span class="linecomment">;;  Elisp manual each candidate is prefixed by `(elisp)'.  You define</span>
<span class="linecomment">;;  a set of candidates in the usual Icicles ways, changing manuals as</span>
<span class="linecomment">;;  needed to add additional nodes to the set you save.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A node name prefixed by its file name is analogous to an absolute</span>
<span class="linecomment">;;  file name, that is, a relative file name prefixed by its</span>
<span class="linecomment">;;  directory.  Because such a saved candidate has a book prefix,</span>
<span class="linecomment">;;  e.g. `(emacs)', it is absolute and unambiguous.  You can use it</span>
<span class="linecomment">;;  wherever you happen to be in Info, to go directly to that node.</span>
<span class="linecomment">;;  This is a feature of `g' even in vanilla Emacs: you can go to a</span>
<span class="linecomment">;;  node in a different manual from the one you are currently</span>
<span class="linecomment">;;  visiting.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you want to reuse a virtual book, hit `g' again, retrieve the</span>
<span class="linecomment">;;  saved set of node candidates that defines the book, and navigate</span>
<span class="linecomment">;;  among the saved nodes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use library `info+.el', you can also take advantage of its</span>
<span class="linecomment">;;  definition of virtual books and saved Info nodes.  That library</span>
<span class="linecomment">;;  defines command `Info-virtual-book', which opens Info on a Table</span>
<span class="linecomment">;;  of Contents of a virtual book of nodes that you have saved either</span>
<span class="linecomment">;;  using command `Info-save-current-node' or by customizing user</span>
<span class="linecomment">;;  option `Info-saved-nodes'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles command `icicle-Info-virtual-book' extends</span>
<span class="linecomment">;;  `Info-virtual-book' by letting you define the virtual book nodes</span>
<span class="linecomment">;;  using completion.  That is, you can use `g' to save a set of</span>
<span class="linecomment">;;  node-name completion candidates (as the value of variable</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates'), and then use command</span>
<span class="linecomment">;;  `icicle-Info-virtual-book' to open an Info buffer with those nodes</span>
<span class="linecomment">;;  as a menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you have not saved any node-name candidates, then</span>
<span class="linecomment">;;  `icicle-Info-virtual-book' acts the same as `Info-virtual-book':</span>
<span class="linecomment">;;  it opens the virtual book that is defined by `Info-saved-nodes'.</span>
<span class="linecomment">;;  With `info+.el', the key `.' adds the current node to</span>
<span class="linecomment">;;  `Info-saved-nodes', which gives you a convenient way to build up a</span>
<span class="linecomment">;;  virtual book as you read.  This is like Emacs bookmarking, but it</span>
<span class="linecomment">;;  keeps your saved Info nodes separate from your other bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With a prefix argument, `icicle-Info-virtual-book' lets you choose</span>
<span class="linecomment">;;  a persistently saved completion set to use instead of</span>
<span class="linecomment">;;  `icicle-saved-completion-candidates' or `Info-saved-nodes'.  This</span>
<span class="linecomment">;;  means that you can have any number of such saved node sets as</span>
<span class="linecomment">;;  virtual books, to use at any time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates")</span>
<span class="linecomment">;;  for information about defining, saving, and reusing sets of</span>
<span class="linecomment">;;  completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Bookmark Enhancements") for information about using Info bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  [* If you click `mouse-1' on a candidate and (starting with Emacs</span>
<span class="linecomment">;;  22) `mouse-1-click-follows-link' is an integer, then you will need</span>
<span class="linecomment">;;  to hold the mouse button depressed longer than that many seconds,</span>
<span class="linecomment">;;  or else that candidate will simply by chosen.  If the value is</span>
<span class="linecomment">;;  `t', then this will not work at all.  Any other value presents no</span>
<span class="linecomment">;;  problem.  (Personally, I use `nil'.)]</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Icicle-Search With Info")</span>
<span class="linecomment">;;  ** Using Icicle-Search With Info **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles searching (`icicle-search') is not Isearch.  It searches</span>
<span class="linecomment">;;  for all matches in the portion of text you tell it to search.</span>
<span class="linecomment">;;  This means that you cannot use it to search an entire manual in</span>
<span class="linecomment">;;  one operation, unless you have the entire manual available in a</span>
<span class="linecomment">;;  single buffer to be searched.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, when you use `icicle-search' (`C-c `') to search with Info,</span>
<span class="linecomment">;;  you are limited to a few options:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use it normally, to search within a single Info node.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can widen the visible portion of the Info buffer</span>
<span class="linecomment">;;    (`C-x n w'), to use it on an entire Info file.  However:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    1. It is not obvious how a given Info manual is divided into</span>
<span class="linecomment">;;       files.  That is, you need to be aware of the point at which</span>
<span class="linecomment">;;       the manual moves from one file to the next.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    2. Only the nodes in the same file that you have already visited</span>
<span class="linecomment">;;       are highlighted, and lots of ugly Info "plumbing" becomes</span>
<span class="linecomment">;;       visible in the other nodes.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    3. You lose all Info features, such as navigation using links.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * There is another way to search across nodes, which addresses #1</span>
<span class="linecomment">;;    and #2, but still does not give you navigable links and such.</span>
<span class="linecomment">;;    Think of it as a hack that can sometimes be handy.  That is what</span>
<span class="linecomment">;;    is described below.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The idea is to flatten a subtree of Info nodes - possibly an</span>
<span class="linecomment">;;  entire manual, but more typically a node and its children - and</span>
<span class="linecomment">;;  then use `icicle-search' (`C-c `') over that flattened document.</span>
<span class="linecomment">;;  What is needed is a command that flattens Info subtrees.  Library</span>
<span class="linecomment">;;  `info+.el' provides such a command, `Info-merge-subnodes', and</span>
<span class="linecomment">;;  binds it to `+' in Info.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can control how you want the flattening to occur, by using</span>
<span class="linecomment">;;  different values of prefix argument.  For searching, you probably</span>
<span class="linecomment">;;  want complete flattening of the chosen subtree, in a single</span>
<span class="linecomment">;;  buffer, so you use a prefix arg of zero: `C-u 0 +'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This does not replace the `*Info*' buffer that you started with;</span>
<span class="linecomment">;;  it creates a new buffer, named after the root node of the subtree</span>
<span class="linecomment">;;  you flattened.  A principle use of `Info-merge-subnodes' is to</span>
<span class="linecomment">;;  print out a manual or a portion of it.  Also, I wrote a library</span>
<span class="linecomment">;;  (`mkhtml.el', outdated now) that lets you convert the result to</span>
<span class="linecomment">;;  HTML.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In sum, you can use Icicles search in Info: `C-u 0 +', then</span>
<span class="linecomment">;;  `C-c `'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One caveat, however: You will generally want to limit your search</span>
<span class="linecomment">;;  to a reasonably small subtree of a manual, instead of flattening</span>
<span class="linecomment">;;  and then searching the entire manual.  Flattening a large manual</span>
<span class="linecomment">;;  can take a while: it took me 10 minutes to flatten the Emacs</span>
<span class="linecomment">;;  Manual.  Of course, you could flatten a large manual once, and</span>
<span class="linecomment">;;  save the result in a file for later searches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Obviously, flattening in order to search is less convenient than</span>
<span class="linecomment">;;  using manual-wide incremental search (`C-s') with Info (starting</span>
<span class="linecomment">;;  with Emacs 22), and it is often less convenient than using</span>
<span class="linecomment">;;  `Info-search' (bound to `s' in Info).  Icicles searching is</span>
<span class="linecomment">;;  different from both, and it has its advantages and disadvantages.</span>
<span class="linecomment">;;  When you want the advantages of Icicles searching in Info, the</span>
<span class="linecomment">;;  flattening hack can be useful.  When you do not need those</span>
<span class="linecomment">;;  advantages, other search methods can sometimes be more</span>
<span class="linecomment">;;  appropriate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Multi-Commands") for</span>
<span class="linecomment">;;    information on using multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Search Commands, Overview") for information about</span>
<span class="linecomment">;;    command `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `info+.el' for information about `Info-merge-subnodes'.</span>
 
<span class="linecomment">;;(@* "Support for Projects")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Support for Projects</span>
<span class="linecomment">;;  ----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section mainly provides pointers to other sections of the</span>
<span class="linecomment">;;  Icicles doc that describe features that can help you work with a</span>
<span class="linecomment">;;  project that involves multiple files, buffers, or bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Bookmarks for Project Access and Organization")</span>
<span class="linecomment">;;  ** Bookmarks for Project Access and Organization **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use Bookmark+ (library `bookmark+.el'), then you can use</span>
<span class="linecomment">;;  bookmarks of various types, including the following, to help</span>
<span class="linecomment">;;  manage software projects:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Dired buffers, with specific sets of files and subdirectories</span>
<span class="linecomment">;;    that are marked or omitted, and using specific listing switches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `*Bookmark List*' buffers, with specific sets of bookmarks that</span>
<span class="linecomment">;;    are marked or hidden.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Multiple alternative bookmark files.  For example, use a</span>
<span class="linecomment">;;    different one for each project.  Or use different ones for</span>
<span class="linecomment">;;    subprojects and use them together for a full project.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Desktops, which include sets of variables and visited buffers</span>
<span class="linecomment">;;    and files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Composite, or sequence, bookmarks, which combine other</span>
<span class="linecomment">;;    bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also associate tags, in the del.icio.us sense, with most</span>
<span class="linecomment">;;  types of bookmarks.  (Such tags are unrelated to the Emacs</span>
<span class="linecomment">;;  source-code tags that use tags files.)  A bookmark can have any</span>
<span class="linecomment">;;  number of tags, and multiple bookmarks can have the same tag,</span>
<span class="linecomment">;;  which means you can use them to organize their target objects.</span>
<span class="linecomment">;;  And tags can be more than just names: they can be user-defined</span>
<span class="linecomment">;;  attributes, with Emacs-Lisp objects as their values.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These and other Bookmark+ features give you different ways to</span>
<span class="linecomment">;;  save, restore, filter, access, and otherwise organize projects, as</span>
<span class="linecomment">;;  collections of information about source-code components and</span>
<span class="linecomment">;;  related software.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances access to such features.</span>
<span class="linecomment">;;  See (@&gt; "Icicles Bookmark Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "A Tags File Can Define a Project")</span>
<span class="linecomment">;;  ** A Tags File Can Define a Project **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One simple kind of a project includes the files that are in or</span>
<span class="linecomment">;;  under a single directory.  Such a project is limited, but it can</span>
<span class="linecomment">;;  often be useful, and it has the advantage of being supported by</span>
<span class="linecomment">;;  several existing Emacs features.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another simple kind of project includes the files that are listed</span>
<span class="linecomment">;;  in a given Emacs tags file.  This is obviously more complex and</span>
<span class="linecomment">;;  flexible than a directory listing.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides multi-commands for visiting one or more files</span>
<span class="linecomment">;;  that are listed in the current tags table:</span>
<span class="linecomment">;;  `icicle-find-file-in-tags-table' and</span>
<span class="linecomment">;;  `icicle-find-file-in-tags-table-other-window'.  See also</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icicles Commands that Read File Names").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Navigating Among Code Definitions")</span>
<span class="linecomment">;;  ** Navigating Among Code Definitions **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For software projects, you need to be able to navigate among code</span>
<span class="linecomment">;;  definitions.  Imenu and Emacs tags features are useful for this,</span>
<span class="linecomment">;;  as are `grep' and compilation buffers.  Icicles improves all of</span>
<span class="linecomment">;;  these.  (A tags file is just a saved index for project files.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Imenu")</span>
<span class="linecomment">;;  * (@&gt; "Icicles Enhancements for Emacs Tags")</span>
<span class="linecomment">;;  * (@&gt; "Compile/Grep Search")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Searching Project Files")</span>
<span class="linecomment">;;  ** Searching Project Files **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Searching within your project is another area where Icicles can</span>
<span class="linecomment">;;  help.  Icicles search is both search and navigation.  Navigating</span>
<span class="linecomment">;;  among tags definitions that match a regexp is also really</span>
<span class="linecomment">;;  searching, and the same is true for Imenu and grep navigation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See also (@&gt; "Icicles Search Commands, Overview") and its</span>
<span class="linecomment">;;  subsections for information about the many ways that you can use</span>
<span class="linecomment">;;  Icicles search to access parts of your projects.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See also (@&gt; "Icicles Dired Enhancements") for an easy way to</span>
<span class="linecomment">;;  search marked files in Dired with Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See also (@&gt; "Searching Bookmarked Objects") for ways to search</span>
<span class="linecomment">;;  bookmarked objects, including the files that have a given set of</span>
<span class="linecomment">;;  del.icio.us-style tags and the bookmarks that are marked in a</span>
<span class="linecomment">;;  given bookmark-list state.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And do not forget that all uses of Icicles search also let you do</span>
<span class="linecomment">;;  search-and-replace on the fly.  This applies to `grep' results,</span>
<span class="linecomment">;;  searching marked files in Dired, tags navigation, and Imenu</span>
<span class="linecomment">;;  navigation.  You can at any time replace the current search hit or</span>
<span class="linecomment">;;  just the part of it that matches your current input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Defining and Saving Sets of Files or Buffers")</span>
<span class="linecomment">;;  ** Defining and Saving Sets of Files or Buffers **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Let's assume that you have one or more sets of files or buffers</span>
<span class="linecomment">;;  that you use frequently.  For each such set of objects, you create</span>
<span class="linecomment">;;  an Emacs option whose value is a list of the file or buffer names</span>
<span class="linecomment">;;  (strings).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Later, you use the option value to refer to those objects by name.</span>
<span class="linecomment">;;  This brings you back to the context of working with just those</span>
<span class="linecomment">;;  particular files or buffers that belong to your project.  You can</span>
<span class="linecomment">;;  search such sets or navigate among their objects.  Icicles has a</span>
<span class="linecomment">;;  number of features that can help with these tasks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Bookmarks are also persistent references to files and</span>
<span class="linecomment">;;  buffers, and you can use sets of bookmarks similarly.  Bookmarking</span>
<span class="linecomment">;;  is a vanilla Emacs feature.  Being able to manipulate explicit</span>
<span class="linecomment">;;  sets of bookmarks is a Bookmark+ feature (library `bookmark+.el').</span>
<span class="linecomment">;;  Bookmarking features are described elsewhere, but they work in</span>
<span class="linecomment">;;  concert with Icicles to offer very good project support.</span>
<span class="linecomment">;;  See (@&gt; "Icicles Bookmark Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Before you can name and save a set of file or buffer names, you</span>
<span class="linecomment">;;  must define its members: pick the file and buffer names that you</span>
<span class="linecomment">;;  want to belong to a given project.  Icicles can help with this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For buffers, use commands `icicle-add-buffer-config' and</span>
<span class="linecomment">;;  `icicle-remove-buffer-config' to define one or more buffer</span>
<span class="linecomment">;;  configurations.  These are named sets of buffers, sort functions,</span>
<span class="linecomment">;;  and other parameters that control completion of buffer names.</span>
<span class="linecomment">;;  Thereafter, you can use command `icicle-buffer-config' to choose a</span>
<span class="linecomment">;;  configuration to be current.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To define a set of files, you use Icicles completion against file</span>
<span class="linecomment">;;  names.  You can use progressive completion, chip away the</span>
<span class="linecomment">;;  non-elephant, and so on, to get just the file names you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For this completion, you can use a command that calls</span>
<span class="linecomment">;;  `read-file-name', and so matches relative file names using the</span>
<span class="linecomment">;;  current `default-directory'.  Or you can use a command that calls</span>
<span class="linecomment">;;  `completing-read', and so matches file names only as ordinary</span>
<span class="linecomment">;;  strings, that is, with no notion that they are file names.  In the</span>
<span class="linecomment">;;  latter case, the file names are often absolute, which means that</span>
<span class="linecomment">;;  you can match not only file names but also directory components.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Examples of the former type are `icicle-find-file' and</span>
<span class="linecomment">;;  `icicle-find-file-read-only' (`C-x C-r' by default).  Examples of</span>
<span class="linecomment">;;  the latter type are `icicle-find-file-absolute',</span>
<span class="linecomment">;;  `icicle-find-file-in-tags-table', `icicle-recent-file', and</span>
<span class="linecomment">;;  `icicle-locate-file'.  Command `icicle-file' (bound to `C-x C-f'</span>
<span class="linecomment">;;  by default) lets you do both, depending on the prefix argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You save a set of file names the same way you save any set of</span>
<span class="linecomment">;;  completion candidates.  You can save all of the names that match</span>
<span class="linecomment">;;  your current input.  You can add a set of names or individual</span>
<span class="linecomment">;;  names to a set of names that you have already saved.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, you can save the marked files in Dired as a set of</span>
<span class="linecomment">;;  project files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Your project is not only files that are all in the same directory,</span>
<span class="linecomment">;;  of course.  You can save file names from multiple directories in</span>
<span class="linecomment">;;  the same set.  And you can include directory names as well, for</span>
<span class="linecomment">;;  use later with commands that operate on directories.  Finally, you</span>
<span class="linecomment">;;  can also save file names as Emacs filesets and use those the same</span>
<span class="linecomment">;;  way.  An Icicles set of saved file names can include Emacs</span>
<span class="linecomment">;;  filesets - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Filesets and Icicles Saved Completion Sets").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Persistent Sets of Completion Candidates")</span>
<span class="linecomment">;;  * (@&gt; "Icicles Bookmark Enhancements")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Chip Away the Non-Elephant")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere")</span>
<span class="linecomment">;;  * (@&gt; "Save Marked Files as Completion Candidates") (Dired)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Retrieving and Reusing a Saved Project")</span>
<span class="linecomment">;;  ** Retrieving and Reusing a Saved Project **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section could also be called "Using Retrieved Saved Sets".</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You retrieve a set of saved file names (a project) the same way</span>
<span class="linecomment">;;  you retrieve any saved set of completion candidates.  That is, you</span>
<span class="linecomment">;;  access the files defined for your project by retrieving their</span>
<span class="linecomment">;;  names during completion, to serve as the current set of completion</span>
<span class="linecomment">;;  candidates.  This odd feature is unique to Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There's nothing much more to say about this, except that you</span>
<span class="linecomment">;;  should be taking advantage of it now.  Define and save a set of</span>
<span class="linecomment">;;  project files (or buffers), and later use just those files,</span>
<span class="linecomment">;;  staying within the bounds of your project for your navigation,</span>
<span class="linecomment">;;  search, compilation, etc. needs.  Even if the files you use in a</span>
<span class="linecomment">;;  given project are scattered all over your file system, Icicles</span>
<span class="linecomment">;;  lets you access them together as a named unit.  For more</span>
<span class="linecomment">;;  information, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use library `bookmark+.el' then you can open a project that</span>
<span class="linecomment">;;  is defined by a set of bookmarks, by doing one of the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Using a project-specific bookmark file.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Using a bookmark-list bookmark (it records a `*Bookmark List*'</span>
<span class="linecomment">;;    buffer state, including which bookmarks are marked or omitted).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also open Dired for a project or for a list of file names</span>
<span class="linecomment">;;  saved non-persistently as completion candidates - only those files</span>
<span class="linecomment">;;  are listed in the Dired buffer.</span>
<span class="linecomment">;;  See (@&gt; "Icicles Dired Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also run `grep' on a saved list of file names using</span>
<span class="linecomment">;;  command `icicle-grep-saved-file-candidates'.  If you use library</span>
<span class="linecomment">;;  `dired+.el', then you can also `grep' the files in a project or</span>
<span class="linecomment">;;  saved list of file names by opening it in Dired and then using</span>
<span class="linecomment">;;  `M-g' (`diredp-do-grep').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Finally, note that among the sets of completion candidates that</span>
<span class="linecomment">;;  you can save are Icicles search hits.  That's right.  Icicles</span>
<span class="linecomment">;;  search lets you search multiple buffers, files, or bookmarks, and</span>
<span class="linecomment">;;  you can save selected search hits or all matching hits for later</span>
<span class="linecomment">;;  use.  When you save search hits, Icicles records the buffer or</span>
<span class="linecomment">;;  file names and the hit locations within those buffers or files.</span>
<span class="linecomment">;;  When you retrieve such a saved set to access its hits, Icicles</span>
<span class="linecomment">;;  automatically takes you to the proper files.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A related feature is being able to filter tags definitions and</span>
<span class="linecomment">;;  then save the filtered hit list.  This works the same way, and it</span>
<span class="linecomment">;;  gives you the equivalent of per-project tags files: A saved hit</span>
<span class="linecomment">;;  list acts just like a custom tags file when you reuse it.  And</span>
<span class="linecomment">;;  unlike some of your project files, a tags file does not change</span>
<span class="linecomment">;;  often, so saved hit sets stay accurate longer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Semantics? Roll Your Own?")</span>
<span class="linecomment">;;  ** Semantics? Roll Your Own? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I no longer develop software.  I just putz around with Emacs Lisp</span>
<span class="linecomment">;;  for my own enjoyment, entertainment, and enlightenment.  So I do</span>
<span class="linecomment">;;  not use things like ECB (Emacs Code Browser) or Semantic</span>
<span class="linecomment">;;  (Bovinator).  I do not use any IDE that has knowledge of a</span>
<span class="linecomment">;;  particular programming language.  The Icicles commands I've</span>
<span class="linecomment">;;  written therefore use little or no semantic or language</span>
<span class="linecomment">;;  information; they rely upon syntax for the most part, and they are</span>
<span class="linecomment">;;  essentially language-agnostic (i.e. ignorant).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But you are a different story.  If you use, say, Semantic, you</span>
<span class="linecomment">;;  could write a little Emacs-Lisp code to take advantage of Icicles</span>
<span class="linecomment">;;  in combination with Semantic's parser information.  With complete</span>
<span class="linecomment">;;  ignorance of Semantic, I dare say it would not be hard.  If you</span>
<span class="linecomment">;;  can get an alist of completion candidates for something from</span>
<span class="linecomment">;;  Semantic in some context, then you can exploit all of the Icicles</span>
<span class="linecomment">;;  features: apropos completion, progressive completion,</span>
<span class="linecomment">;;  multi-commands, Icicles search, and so on.  Likewise for any other</span>
<span class="linecomment">;;  IDE that plays well with Emacs and for any other programming</span>
<span class="linecomment">;;  language support.  Think about it.  Others would appreciate your</span>
<span class="linecomment">;;  contribution.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides lots of features for Emacs-Lisp programmers.  The</span>
<span class="linecomment">;;  end-user commands I've written using some of those features are</span>
<span class="linecomment">;;  really just a demonstration of what you can do.  Try rolling your</span>
<span class="linecomment">;;  own Icicles commands.  See Also: (@&gt; "Note to Programmers").</span>
 
<span class="linecomment">;;(@* "Using Complex Completion Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using Complex Completion Candidates</span>
<span class="linecomment">;;  -----------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section could also be called "Applying a Function</span>
<span class="linecomment">;;  Interactively" or "Mapping over Sets".  It is about applying a</span>
<span class="linecomment">;;  function to members of a set of completion candidates that you</span>
<span class="linecomment">;;  select interactively.  The candidates can represent arbitrarily</span>
<span class="linecomment">;;  complex data, and the function is applied to the associated data</span>
<span class="linecomment">;;  as well, not just to the displayed (string) candidate that names</span>
<span class="linecomment">;;  the data.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You already know that you can manipulate sets of candidates - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates").</span>
<span class="linecomment">;;  The elements of those sets are strings; you choose</span>
<span class="linecomment">;;  candidate names.  Sometimes, however, you need to choose among</span>
<span class="linecomment">;;  named items that are themselves complex, containing more</span>
<span class="linecomment">;;  information than just the name.  That is the idea behind</span>
<span class="linecomment">;;  multi-command `icicle-apply', which this section introduces.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You (or a command that you use) can obtain the information</span>
<span class="linecomment">;;  associated with a name after you choose the name.  This is what</span>
<span class="linecomment">;;  happens, for instance, when you use `find-file'; the command looks</span>
<span class="linecomment">;;  up the file associated with the file name you choose.  Icicles</span>
<span class="linecomment">;;  multi-commands such as `icicle-file' perform this lookup both when</span>
<span class="linecomment">;;  you act on a candidate during completion (e.g. `C-RET') and when</span>
<span class="linecomment">;;  you make a final candidate selection (`RET') - see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Names and their associated information can be available in Emacs</span>
<span class="linecomment">;;  Lisp in the form of an association list (alist), that is, a list</span>
<span class="linecomment">;;  whose items are conses (cons cells).  An alist is often used to</span>
<span class="linecomment">;;  represent a function that maps one set of things to another.  The</span>
<span class="linecomment">;;  conses in the alist represent the tuples (typically pairs) of</span>
<span class="linecomment">;;  related items.  The car of each cons is called its "key"; the cdr</span>
<span class="linecomment">;;  is called its "value".  Different alists have different kinds of</span>
<span class="linecomment">;;  keys and values.  Typical key types include symbols and strings;</span>
<span class="linecomment">;;  typical value types include symbols, strings, numbers, and lists.</span>
<span class="linecomment">;;  There are quite a few standard Emacs-Lisp variables whose value is</span>
<span class="linecomment">;;  an alist.  Most are internal variables, but some are user options.</span>
<span class="linecomment">;;  See the Emacs-Lisp manual for more about alists.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The completion mechanism of Emacs function `completing-read' can</span>
<span class="linecomment">;;  take an alist as input: the keys are the completion-candidate</span>
<span class="linecomment">;;  strings that you choose from.  For Emacs completion, however, the</span>
<span class="linecomment">;;  value (cdr) of each alist key/value entry is completely ignored.</span>
<span class="linecomment">;;  Icicles uses `completing-read', and it works the same way.  If a</span>
<span class="linecomment">;;  command needs to access the value associated with a key</span>
<span class="linecomment">;;  (candidate), then it must somehow do so independently of</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-search' offers an example of this.  The completion</span>
<span class="linecomment">;;  alist contains key/value pairs whose car (key) is a search-hit</span>
<span class="linecomment">;;  string that matches your search string and whose cdr (value) is</span>
<span class="linecomment">;;  the buffer position for the hit.  When you use completion with</span>
<span class="linecomment">;;  this command, you work only with the keys, but `icicle-search'</span>
<span class="linecomment">;;  also keeps track of the corresponding buffer positions for you.</span>
<span class="linecomment">;;  The logic for doing this is coded into the definition of</span>
<span class="linecomment">;;  `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is common to want to do something interesting interactively</span>
<span class="linecomment">;;  with the values also, not just the keys, of a completion alist.</span>
<span class="linecomment">;;  Why lose the important value information when you choose a key?</span>
<span class="linecomment">;;  And instead of requiring the logic of each command to deal with</span>
<span class="linecomment">;;  this need individually, why not provide a general mechanism for</span>
<span class="linecomment">;;  accessing this information - both by program and interactively?</span>
<span class="linecomment">;;  This is what command `icicle-apply' is for.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To make use of completion alist values, you need to access the cdr</span>
<span class="linecomment">;;  of a key/value cons (pair).  Different alists are structured</span>
<span class="linecomment">;;  differently: the cdr can itself be complex (structured - a cons).</span>
<span class="linecomment">;;  In general, you want to access not just the cdr (value) but the</span>
<span class="linecomment">;;  key as well, the key/value pair as a whole, to do what you want</span>
<span class="linecomment">;;  with it - that is, to apply some function to it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs-Lisp programmers sometimes map functions over lists to</span>
<span class="linecomment">;;  obtain a different list.  For example, mapping the function `1+'</span>
<span class="linecomment">;;  over the list (3 1 4 1 5 9) gives the list (4 2 5 2 6 10).  Or if</span>
<span class="linecomment">;;  interested only in the side effects, they apply a function</span>
<span class="linecomment">;;  iteratively over a list without bothering to accumulate the</span>
<span class="linecomment">;;  results as a new list.  The command `icicle-apply' is inspired by</span>
<span class="linecomment">;;  these common practices of mapping and iterating over a list, but</span>
<span class="linecomment">;;  it applies only to alists.  And it lets you choose interactively</span>
<span class="linecomment">;;  which alist elements to act on, instead of always acting on all</span>
<span class="linecomment">;;  elements.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-apply' lets you apply a function of your choice to any</span>
<span class="linecomment">;;  number of key/value entries in an alist.  As user of the command,</span>
<span class="linecomment">;;  you choose the entries to act on.  The alist is used for</span>
<span class="linecomment">;;  completion; you choose among the keys.  The function is applied to</span>
<span class="linecomment">;;  the corresponding key/value pairs, however, not to the keys alone.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, given the alist `auto-mode-alist' and the function</span>
<span class="linecomment">;;  `cdr', you can choose to apply `cdr' to selected alist entries.</span>
<span class="linecomment">;;  This acts as a simple lookup function, because `cdr' just returns</span>
<span class="linecomment">;;  the value associated with a chosen key.  If you choose, for</span>
<span class="linecomment">;;  example, the candidate (key) "\.el\'", then the (value) result is</span>
<span class="linecomment">;;  the symbol `emacs-lisp-mode'.  In this case, the chosen key/value</span>
<span class="linecomment">;;  pair is ("\\.el\\'" . emacs-lisp-mode).  (A literal backslash must</span>
<span class="linecomment">;;  be doubled in an Emacs-Lisp string.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `cdr' returns the value, which is `emacs-lisp-mode' here.</span>
<span class="linecomment">;;  If instead of `cdr' you use the function (lambda (x)</span>
<span class="linecomment">;;  (describe-function (cdr x))), then the result of choosing</span>
<span class="linecomment">;;  candidate "\.el\'" is to display the help for function</span>
<span class="linecomment">;;  `emacs-lisp-mode'.  This function first uses `cdr' to obtain the</span>
<span class="linecomment">;;  value (the mode) and then applies `describe-function' to that</span>
<span class="linecomment">;;  value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A typical use of `icicle-apply' is to define your own</span>
<span class="linecomment">;;  multi-command that you or someone else can use to act on objects</span>
<span class="linecomment">;;  selected by name.  The definition of command `icicle-goto-marker'</span>
<span class="linecomment">;;  provides an example.  It uses an alist whose elements are pairs</span>
<span class="linecomment">;;  composed of a text line (the key) and the marker (the value) in</span>
<span class="linecomment">;;  that line.  It applies a function that moves to the marker.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If called interactively (as opposed to being used to define</span>
<span class="linecomment">;;  another command), `icicle-apply' lets you use completion to choose</span>
<span class="linecomment">;;  not only the objects to act on but also the function to apply to</span>
<span class="linecomment">;;  them and the alist to choose them from.  See the doc string of</span>
<span class="linecomment">;;  `icicle-apply' for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that you can type in a lambda expression when prompted for</span>
<span class="linecomment">;;  the function.  You can use any function, provided it targets a</span>
<span class="linecomment">;;  key/value pair (a cons).  This is why you could not simply use</span>
<span class="linecomment">;;  `describe-function' itself as the function to apply in the example</span>
<span class="linecomment">;;  above: `describe-function' expects a symbol argument, not a cons.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So what is `icicle-apply' really for?  Anything you want.  You can</span>
<span class="linecomment">;;  use it to simply browse an alist or to perform actions on complex</span>
<span class="linecomment">;;  things.  The idea is to let you take advantage of Icicles features</span>
<span class="linecomment">;;  to interactively filter and manipulate a set of completion keys,</span>
<span class="linecomment">;;  and then apply any function you like to them - not just to the</span>
<span class="linecomment">;;  keys, but to the keys or their values, or both.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use apropos (regexp) matching or prefix matching to filter</span>
<span class="linecomment">;;  the alist, as always, during completion.  You can use `C-RET' and</span>
<span class="linecomment">;;  so on to act on (that is, apply the function to) selected</span>
<span class="linecomment">;;  key/value pairs that match your current input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also act on *all* such pairs, by using `C-!' or `M-!'.</span>
<span class="linecomment">;;  `C-!' corresponds to iterating over the items in a list, applying</span>
<span class="linecomment">;;  a function to each.  `M-!' applies a function not to each chosen</span>
<span class="linecomment">;;  pair, but to the *list* of all chosen pairs.  By default, the</span>
<span class="linecomment">;;  completion candidates are not sorted, but you can of course sort</span>
<span class="linecomment">;;  them in various ways, either interactively or by program.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an Emacs-Lisp programmer, you can use function `icicle-apply'</span>
<span class="linecomment">;;  programmatically to let users look things up in alists that you</span>
<span class="linecomment">;;  construct or to act on selected alist entries in complex ways.</span>
<span class="linecomment">;;  Icicles just provides the interactive completion features.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The real value of `icicle-apply' comes from what you do with it.</span>
<span class="linecomment">;;  Use it with a database of geographical coordinates to look up</span>
<span class="linecomment">;;  location names provided by users and draw corresponding vicinity</span>
<span class="linecomment">;;  maps.  Use it with a list of hardware configurations to let users</span>
<span class="linecomment">;;  perform diagnostic or maintenance operations on selected</span>
<span class="linecomment">;;  equipment.  You get the idea - use your imagination.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: Although completion alists normally require string-valued</span>
<span class="linecomment">;;  keys, `icicle-apply' is designed to work with any alist.</span>
 
<span class="linecomment">;;(@* "Icicles OO: Object-Action Interaction")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles OO: Object-Action Interaction</span>
<span class="linecomment">;;  --------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's another crazy Icicles feature: Instead of choosing a</span>
<span class="linecomment">;;  function (e.g. command) and then the object to apply it to, choose</span>
<span class="linecomment">;;  the object first and then the function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first thing to say about this feature is that Emacs is not</span>
<span class="linecomment">;;  really designed for this, so it's not feasible to do this in a</span>
<span class="linecomment">;;  entirely satisfactory way.  In particular, there is no practical</span>
<span class="linecomment">;;  way, given an object, to find all of the functions that apply to</span>
<span class="linecomment">;;  it, in order to allow all of those functions, and only those</span>
<span class="linecomment">;;  functions, as completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second thing to say is that there are several ways that</span>
<span class="linecomment">;;  Icicles helps you operate on an object that you have already</span>
<span class="linecomment">;;  chosen:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * apropos completion - (1) choose an object type by name, (2)</span>
<span class="linecomment">;;    choose a function, (3) choose the target object</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * alternative action by type, during completion - (1) choose a</span>
<span class="linecomment">;;    target object, (2) choose a function appropriate for the</span>
<span class="linecomment">;;    object's type.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-RET' during completion - (1) choose a target object, (2)</span>
<span class="linecomment">;;    choose any function</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-object-action' and `icicle-anything' - (1) choose an</span>
<span class="linecomment">;;    object type by name, (2) choose the target object, (3) choose a</span>
<span class="linecomment">;;    function</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a special case, if you use library Anything (`anything.el'),</span>
<span class="linecomment">;;  then `icicle-object-action' lets you apply one or more Anything</span>
<span class="linecomment">;;  actions defined for the object.  See (@&gt; "Icicles with Anything")</span>
<span class="linecomment">;;  for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Apropos Completion as OO")</span>
<span class="linecomment">;;  ** Apropos Completion as OO **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use apropos completion with `M-x' to narrow the set of</span>
<span class="linecomment">;;  possible commands to those that have a given object type in their</span>
<span class="linecomment">;;  name.  You choose the command before the individual object, but</span>
<span class="linecomment">;;  you at least choose the object type first (which narrows the set</span>
<span class="linecomment">;;  of possible objects).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use Icicles, you already use apropos completion this way,</span>
<span class="linecomment">;;  but you might not have thought about it in these terms.  If you</span>
<span class="linecomment">;;  want to invoke some command on a buffer, you might start by typing</span>
<span class="linecomment">;;  `M-x buffer S-TAB' or `M-x buff S-TAB'.  This is simple, but it</span>
<span class="linecomment">;;  really does get you most of the way toward object-action</span>
<span class="linecomment">;;  interaction.  And you can of course then use progressive</span>
<span class="linecomment">;;  completion (`M-*') to filter the matching commands for additional</span>
<span class="linecomment">;;  object-type names; for example `M-* window' keeps only those</span>
<span class="linecomment">;;  commands whose names contain both `buffer' and `window'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Of course, this approach requires the command name to actually</span>
<span class="linecomment">;;  advertise truthfully the object types that it operates on.  There</span>
<span class="linecomment">;;  are false positives and true negatives, but Emacs is generally</span>
<span class="linecomment">;;  quite helpful in this respect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Alternative Action as OO")</span>
<span class="linecomment">;;  ** Alternative Action as OO **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As explained in</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Alternative Actions"),</span>
<span class="linecomment">;;  many Icicles commands, as their alternative action</span>
<span class="linecomment">;;  (e.g. `C-S-RET'), prompt you to choose an action to be applied to</span>
<span class="linecomment">;;  the current completion candidate.  The actions you can choose are</span>
<span class="linecomment">;;  all appropriate functions for the current type of object</span>
<span class="linecomment">;;  (candidate).  If you use library Anything (see below), then any</span>
<span class="linecomment">;;  actions defined for the current type by Anything are included.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Alternative Actions").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "M-RET")</span>
<span class="linecomment">;;  ** M-RET **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `M-RET' (`icicle-candidate-read-fn-invoke') during completion</span>
<span class="linecomment">;;  provides a typeless object-action interaction, which is always</span>
<span class="linecomment">;;  available.  (You can also use `ESC RET' or `ESC C-m'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is similar to the action choice provided for some</span>
<span class="linecomment">;;  commands by `C-S-RET', except that there is no notion of the</span>
<span class="linecomment">;;  current object type - you can choose from among all Emacs-Lisp</span>
<span class="linecomment">;;  functions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever you cycle through completion candidates, `M-RET' enters a</span>
<span class="linecomment">;;  recursive edit that prompts you for a function to apply to the</span>
<span class="linecomment">;;  current candidate.  `M-mouse-2' does the same thing.  For example,</span>
<span class="linecomment">;;  if the current candidate is a buffer named `foo.el', then `M-RET'</span>
<span class="linecomment">;;  prompts you for a function to apply to it.  (Actually, the</span>
<span class="linecomment">;;  function is applied to the candidate, which is the buffer name in</span>
<span class="linecomment">;;  this case, but many functions accept an object name in place of</span>
<span class="linecomment">;;  the object.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The function you enter can be anything, including a lambda</span>
<span class="linecomment">;;  expression that accepts an argument of the appropriate type.  The</span>
<span class="linecomment">;;  function is read with (lax) completion.  It is up to you to choose</span>
<span class="linecomment">;;  a function that is appropriate for the current object type.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use a prefix argument (`C-u M-RET' or `C-u M-mouse-2'),</span>
<span class="linecomment">;;  then the result of the function application is pretty-printed.</span>
<span class="linecomment">;;  Otherwise, the function is called for effect only.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "`icicle-object-action' and `icicle-anything'")</span>
<span class="linecomment">;;  ** `icicle-object-action' and `icicle-anything' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way that Icicles helps with object-action interaction is</span>
<span class="linecomment">;;  provided by command `icicle-object-action'.  This reads an</span>
<span class="linecomment">;;  object-type name ("what"), with completion; then it reads an</span>
<span class="linecomment">;;  object of that type ("which"), with completion; then it reads a</span>
<span class="linecomment">;;  function (name or lambda expression) to apply to the object</span>
<span class="linecomment">;;  ("how"), with (lax) completion.  Again, use a prefix argument if</span>
<span class="linecomment">;;  you want to pretty-print the result.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `what-which-how' is an alias for command `icicle-object-action'.</span>
<span class="linecomment">;;  It is easy to remember, taking its name from the successive input</span>
<span class="linecomment">;;  prompts: "What?" - a file.  "Which?" - icicles.el.  "How?" open.</span>
<span class="linecomment">;;  Another alias for the same command is `a', because it acts on a</span>
<span class="linecomment">;;  file, a buffer, a symbol, a process, and so on.  The first thing</span>
<span class="linecomment">;;  it does is prompt you for the type of object, so you do `M-x a RET</span>
<span class="linecomment">;;  buffer', `M-x a RET symbol', and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The aliases `what-which-how' and `a' are just convenience</span>
<span class="linecomment">;;  commands.  They are defined only if user option</span>
<span class="linecomment">;;  `icicle-define-alias-commands-flag' is non-`nil'.  Two related</span>
<span class="linecomment">;;  commands are also defined only if this option is non-`nil':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `file'   - same as `a RET file'</span>
<span class="linecomment">;;  * `buffer' - same as `a RET buffer'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example: `M-x file RET'.  You are prompted for a file to act</span>
<span class="linecomment">;;  on, and then for the action to use.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: If you use AUCTeX, then be aware of an AUCTeX bug that</span>
<span class="linecomment">;;  causes problems if `icicle-define-alias-commands-flag' is</span>
<span class="linecomment">;;  non-`nil'.  Here is the bug description, filed 2007/10/05 by Bjorn</span>
<span class="linecomment">;;  Haagensen:</span>
<span class="linecomment">;;  http://lists.gnu.org/archive/html/bug-auctex/2007-10/msg00006.html.</span>
<span class="linecomment">;;  The problem is that AUCTeX mistakenly invokes the Icicles `file'</span>
<span class="linecomment">;;  command, in an inappropriate context.  AUCTeX does not define any</span>
<span class="linecomment">;;  function `file' when it is loaded, but it invokes one, if defined.</span>
<span class="linecomment">;;  This appears to be a name-capture problem.  Since there is no</span>
<span class="linecomment">;;  `file' function defined when Icicles is loaded, Icicles defines</span>
<span class="linecomment">;;  its command.  AUCTeX developers will no doubt fix this bug.  Until</span>
<span class="linecomment">;;  then, AUCTeX users can avoid the bug by setting</span>
<span class="linecomment">;;  `icicle-define-alias-commands-flag' to `nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The "type" of an object is one of these:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  a. A type defining an entry in user option</span>
<span class="linecomment">;;     `icicle-predicate-types-alist'.  These are type predicates,</span>
<span class="linecomment">;;     such as `bufferp', `keywordp', or `atom'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  b. The `type' of an Anything source, or its `name' if it has no</span>
<span class="linecomment">;;     `type'.  This is available only if you use library</span>
<span class="linecomment">;;     `anything.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  c. A type defining an entry in user option</span>
<span class="linecomment">;;     `icicle-type-actions-alist'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles completion is available for each prompt: the type, the</span>
<span class="linecomment">;;  object, and the action to apply to the object.  Types defined by</span>
<span class="linecomment">;;  Anything are highlighted in buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-special-candidate'.  In the case of an Anything type, you</span>
<span class="linecomment">;;  can use multi-command features to act on multiple objects in</span>
<span class="linecomment">;;  multiple ways, all within a single `a' invocation.  See</span>
<span class="linecomment">;;  (@&gt; "Icicles with Anything") for more information about using</span>
<span class="linecomment">;;  Anything types.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The objects of types (b) and (c) are easily named, and their names</span>
<span class="linecomment">;;  serve as the completion candidates when you choose them.  So, for</span>
<span class="linecomment">;;  instance, if you choose type `buffer', then you can act on a</span>
<span class="linecomment">;;  buffer by choosing its name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The objects of predicate type (type a, above) are not necessarily</span>
<span class="linecomment">;;  named.  The completion candidates for these objects are symbols</span>
<span class="linecomment">;;  whose values are the objects that are acted upon. The object-type</span>
<span class="linecomment">;;  names used for these candidates are really Emacs-Lisp type</span>
<span class="linecomment">;;  predicate names, which all end in `p', except for `atom'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, for instance, if you choose type `bufferp', then you can</span>
<span class="linecomment">;;  choose a symbol whose value is a buffer, in order to act on that</span>
<span class="linecomment">;;  buffer.  A buffer is of course always named, but an object of type</span>
<span class="linecomment">;;  `stringp' is not.  The value of `emacs-version' is one such string</span>
<span class="linecomment">;;  that you can act on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Be aware that the action function you choose must accommodate the</span>
<span class="linecomment">;;  object you choose as its only argument.  Also, completion of the</span>
<span class="linecomment">;;  function candidate itself is lax, so you can enter a lambda</span>
<span class="linecomment">;;  expression as the action.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Objects that are naturally associated with names are treated</span>
<span class="linecomment">;;  differently, depending on the type.  Besides Anything types, the</span>
<span class="linecomment">;;  following object types are used for named objects: `buffer',</span>
<span class="linecomment">;;  `command', `face', `frame', `function', `option', `process',</span>
<span class="linecomment">;;  `symbol', `variable', `window'.  For all of these except `window',</span>
<span class="linecomment">;;  the name of the object is used.  For `window', the candidate</span>
<span class="linecomment">;;  objects are the names of the buffers that are currently shown in a</span>
<span class="linecomment">;;  window (on any frame).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You'll note that some types are treated both ways, 1) using named</span>
<span class="linecomment">;;  objects and 2) using symbols whose values are objects.  An example</span>
<span class="linecomment">;;  is `frame' and `framep': the completion candidates (objects) for</span>
<span class="linecomment">;;  type `frame' are frame names; the candidates for type `framep' are</span>
<span class="linecomment">;;  symbols whose values are frames.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles with Anything")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Apropos Completions").</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
 
<span class="linecomment">;;(@* "Icicles with Anything")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles with Anything</span>
<span class="linecomment">;;  ---------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library Anything (`anything.el') lets you define object types and</span>
<span class="linecomment">;;  associate actions with them.  It provides command `anything',</span>
<span class="linecomment">;;  which you can use to apply an action to an object, choosing the</span>
<span class="linecomment">;;  object first by name.  All objects (of all types) that have a name</span>
<span class="linecomment">;;  that matches your input are candidates.  You can use command</span>
<span class="linecomment">;;  `anything' while in Icicle mode; it has the same behavior with</span>
<span class="linecomment">;;  Icicles as without it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles also integrates some Anything features within its own</span>
<span class="linecomment">;;  completion environment, so that you can use Icicles features such</span>
<span class="linecomment">;;  as progressive completion at the same time.  In particular, you</span>
<span class="linecomment">;;  can act on multiple Anything objects in the same command</span>
<span class="linecomment">;;  invocation, and you can act on them using multiple Anything</span>
<span class="linecomment">;;  actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-anything' (alias `any') is just command</span>
<span class="linecomment">;;  `icicle-object-action' (alias `a') restricted to Anything types -</span>
<span class="linecomment">;;  see (@&gt; "Icicles OO: Object-Action Interaction").  It is more</span>
<span class="linecomment">;;  convenient than `a' if you know that you want to use an Anything</span>
<span class="linecomment">;;  type, because the set of type candidates to choose from is more</span>
<span class="linecomment">;;  limited.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you act on an object of an Anything type, you are not</span>
<span class="linecomment">;;  prompted for the action ("how").  The default Anything action is</span>
<span class="linecomment">;;  applied, or you can choose a different Anything action.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `any' (or command `a' when applied to an Anything type) is</span>
<span class="linecomment">;;  a multi-command (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-RET', `C-mouse-2', and so on perform the default Anything</span>
<span class="linecomment">;;    action on each chosen object.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-S-RET', `C-S-mouse-2', and so on, prompt you, for each chosen</span>
<span class="linecomment">;;    object, to choose one or more Anything actions (with</span>
<span class="linecomment">;;    completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can thus act on any number of Anything objects in any number</span>
<span class="linecomment">;;  of Anything ways, all in the same `any' command invocation.  And</span>
<span class="linecomment">;;  you can of course use Icicles completion and cycling to choose.</span>
<span class="linecomment">;;  User option `icicle-anything-transform-candidates-flag' determines</span>
<span class="linecomment">;;  whether Anything function `anything-transform-candidates' is</span>
<span class="linecomment">;;  applied to displayed Anything candidates in Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's an example of using command `any'.  Let's assume that you</span>
<span class="linecomment">;;  have an `action' entry such as this in `anything-type-attributes'</span>
<span class="linecomment">;;  for the Anything type `command':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (action ("Call interactively"</span>
<span class="linecomment">;;           . (lambda (command-name)</span>
<span class="linecomment">;;               (call-interactively (intern command-name))))</span>
<span class="linecomment">;;          ("Describe command"</span>
<span class="linecomment">;;           . (lambda (command-name)</span>
<span class="linecomment">;;               (describe-function (intern command-name))))</span>
<span class="linecomment">;;          ("Add command to kill ring" . kill-new)</span>
<span class="linecomment">;;          ("Go to command's definition"</span>
<span class="linecomment">;;           . (lambda (command-name)</span>
<span class="linecomment">;;               (find-function (intern command-name)))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This defines four actions for objects of type `command', the</span>
<span class="linecomment">;;  default action being the first listed ("Call interactively").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You enter command `any', choose the Anything type `command', and</span>
<span class="linecomment">;;  then choose the command `icicle-face-list' to act on:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x any RET</span>
<span class="linecomment">;;    What (type): command RET</span>
<span class="linecomment">;;    Which (command): icicle-face-list RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This invokes command `icicle-face-list', because the default</span>
<span class="linecomment">;;  Anything action for an object of type `command' is to call it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `C-RET' instead of `RET' when choosing command</span>
<span class="linecomment">;;  `icicle-face-list', then you remain within the `any' invocation,</span>
<span class="linecomment">;;  and you can do something with another command after</span>
<span class="linecomment">;;  `icicle-face-list'.  If you use `C-S-RET' when choosing a command,</span>
<span class="linecomment">;;  then you are prompted for the action to invoke for that command:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Which (command): icicle-face-list C-S-RET</span>
<span class="linecomment">;;    How (action): Go to command's definition RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you choose the Anything action "Go to command's definition",</span>
<span class="linecomment">;;  then, well, that's what happens: here, you go to the definition of</span>
<span class="linecomment">;;  `icicle-face-list'.  Again, you could use `C-RET' instead of</span>
<span class="linecomment">;;  `RET', to perform this action on the command and then choose and</span>
<span class="linecomment">;;  apply (via `RET' or `C-RET') another action to the same command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  After you've stopped (via `RET' or `C-g') acting on command</span>
<span class="linecomment">;;  `icicle-face-list', you can clear the minibuffer (using `M-k') and</span>
<span class="linecomment">;;  type another command to act on, and so on.  Or, you can stop (via</span>
<span class="linecomment">;;  `RET' or `C-g') and end the invocation of command `any'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  At each prompt, you can use (apropos or prefix) completion or</span>
<span class="linecomment">;;  cycling to pick a candidate.  So, for instance, using completion,</span>
<span class="linecomment">;;  you could simply do this to choose `command', `icicle-face-list',</span>
<span class="linecomment">;;  and "Go to command definition":</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x any RET c RET face-l S-TAB C-S-RET g TAB RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles enhances Anything by providing multi-command features, as</span>
<span class="linecomment">;;  well as by providing all of the other standard Icicles features:</span>
<span class="linecomment">;;  apropos and prefix completion, cycling, progressive completion,</span>
<span class="linecomment">;;  help on individual candidates, and so on.  On the other hand,</span>
<span class="linecomment">;;  Anything by itself provides some features that Icicles does not</span>
<span class="linecomment">;;  exploit.  The aim of command `any' is to give you the basic</span>
<span class="linecomment">;;  Anything features in an Icicles completion context.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A significant behavior difference between Anything (that is,</span>
<span class="linecomment">;;  command `anything') and Icicles command `any' is that with</span>
<span class="linecomment">;;  `anything' only the object name is used for filtering, whereas</span>
<span class="linecomment">;;  with Icicles command `any' you first narrow down the potential</span>
<span class="linecomment">;;  candidates by type, before the object name is matched (against</span>
<span class="linecomment">;;  objects of only that type).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, with Anything, your input pattern is matched against</span>
<span class="linecomment">;;  every possible object of every possible type.  You then choose</span>
<span class="linecomment">;;  among the matches.  If you want, after that wide-net matching you</span>
<span class="linecomment">;;  can cycle among only the matches of a given type (e.g. file), but</span>
<span class="linecomment">;;  matching against all other types has already taken place.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This behavior of starting with typeless matching can be convenient</span>
<span class="linecomment">;;  sometimes (you need not specify the object type), but it can also</span>
<span class="linecomment">;;  be inconvenient (and unnecessarily slow) to match objects of types</span>
<span class="linecomment">;;  totally unrelated to what you're after.  In such cases, it can</span>
<span class="linecomment">;;  require either a long input pattern or cycling among more</span>
<span class="linecomment">;;  candidates, to disambiguate among the hits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With Icicles command `any', you have the inconvenience of needing</span>
<span class="linecomment">;;  to specify first the type of object you want, but this has the</span>
<span class="linecomment">;;  advantage of eliminating searching among irrelevant types.</span>
<span class="linecomment">;;  Finally, remember that you can use both `anything' and `any' -</span>
<span class="linecomment">;;  choose whichever is most convenient for the current task.</span>
 
<span class="linecomment">;;(@* "Multi-Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-Completions</span>
<span class="linecomment">;;  -----------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is about using completion candidates that are</span>
<span class="linecomment">;;  composed of more than one part: strings that you can complete</span>
<span class="linecomment">;;  against separately and simultaneously.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles Multi-Completion Commands")</span>
<span class="linecomment">;;  ** Icicles Multi-Completion Commands **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Have you ever used standard Emacs command `apropos-documentation'?</span>
<span class="linecomment">;;  It searches the doc strings of all Emacs-Lisp symbols for matches</span>
<span class="linecomment">;;  to an input regexp, and displays the hits.  It can be useful when</span>
<span class="linecomment">;;  you do not remember the name of a function or variable but you can</span>
<span class="linecomment">;;  guess at terms that might occur in its doc string.  Typically,</span>
<span class="linecomment">;;  people resort to it only after first trying apropos commands that</span>
<span class="linecomment">;;  match against the function or variable name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The idea behind `apropos-documentation' also motivates Icicles</span>
<span class="linecomment">;;  command `icicle-doc'.  This is a multi-command (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")),</span>
<span class="linecomment">;;  so you can use `C-RET' and `C-next' to browse the regexp matches,</span>
<span class="linecomment">;;  displaying the documentation of each match in turn, and you can</span>
<span class="linecomment">;;  change the regexp to get different matches during the same command</span>
<span class="linecomment">;;  invocation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like `apropos-documentation', `icicle-doc' lets you match a regexp</span>
<span class="linecomment">;;  against the doc strings of symbols such as functions, variables,</span>
<span class="linecomment">;;  and faces.  You can of course use progressive completion to match</span>
<span class="linecomment">;;  multiple regexps.  Here, for example, is a query that shows all doc</span>
<span class="linecomment">;;  strings (functions, variables, faces - a lot! of doc strings)</span>
<span class="linecomment">;;  that match both `mail' and `mode line', in either order,</span>
<span class="linecomment">;;  as completion candidates:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-doc RET mail S-SPC mode line</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You cannot do that with vanilla Emacs `apropos-documentation' or</span>
<span class="linecomment">;;  with any other vanilla Emacs `apropos*' command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Commands `icicle-vardoc', `icicle-fundoc', and `icicle-plist' are</span>
<span class="linecomment">;;  similar to `icicle-doc' in the kind of functionality they provide.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Each of these commands gathers a tremendous amount of information</span>
<span class="linecomment">;;  to construct an initial set of completion candidates based on all</span>
<span class="linecomment">;;  existing Emacs symbols (in the standard `obarray').  This is</span>
<span class="linecomment">;;  time-consuming.  Since the set of symbols that have property lists</span>
<span class="linecomment">;;  or that name functions, variables, or faces changes little, you</span>
<span class="linecomment">;;  can optionally bypass this gathering and reuse the last initial</span>
<span class="linecomment">;;  set of candidates for that command.  You do this by invoking the</span>
<span class="linecomment">;;  command using a prefix argument (non-negative prefix arg, for</span>
<span class="linecomment">;;  `icicle-vardoc' and `icicle-plist').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Each of these particular commands also uses Icicles</span>
<span class="linecomment">;;  multi-completion.  A "multi-completion" is a completion candidate</span>
<span class="linecomment">;;  that has multiple parts.  A multi-completion command lets your</span>
<span class="linecomment">;;  input match any or all parts individually, at the same time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Commands `icicle-vardoc' and `icicle-fundoc' let you match both</span>
<span class="linecomment">;;    the function or variable name and the doc string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-doc' lets you match any combination of the</span>
<span class="linecomment">;;    following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - the function, variable, or face name</span>
<span class="linecomment">;;    - the type: FUNCTION, VARIABLE, or FACE (uppercase)</span>
<span class="linecomment">;;    - the doc string</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-plist' lets you match both a symbol name and its</span>
<span class="linecomment">;;    property list.  You can use it to find symbols with certain</span>
<span class="linecomment">;;    property-list keys or values.  By default (for Emacs 22 or</span>
<span class="linecomment">;;    later), plists are pretty-printed (in `*Help*' and</span>
<span class="linecomment">;;    `*Completions*'), but if you use a negative prefix argument then</span>
<span class="linecomment">;;    pretty-printing is skipped, gaining a little time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Command `icicle-describe-option-of-type' (bound to `C-h C-o' in</span>
<span class="linecomment">;;    Icicle mode) lets you match both an option name and the option's</span>
<span class="linecomment">;;    `defcustom' type definition.  There are several ways to match</span>
<span class="linecomment">;;    type definitions, controlled by the prefix argument - see the</span>
<span class="linecomment">;;    command's doc string.  You can match a type directly or taking</span>
<span class="linecomment">;;    type inheritance into account.  You can match a type as a sexp</span>
<span class="linecomment">;;    or using a regexp.  You can match a type expression or match the</span>
<span class="linecomment">;;    option's current value against a type.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Other Icicles commands that use multi-completion include</span>
<span class="linecomment">;;  `icicle-locate-file', `icicle-locate-file-other-window',</span>
<span class="linecomment">;;  `icicle-recent-file', and `icicle-recent-file-other-window'.</span>
<span class="linecomment">;;  These commands let you match against two-part multi-completion</span>
<span class="linecomment">;;  candidates that are composed of an absolute file name and the</span>
<span class="linecomment">;;  file's last modification date.  This means that you can easily</span>
<span class="linecomment">;;  find those notes you took sometime last week...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The way multi-completion commands work is a bit inelegant perhaps,</span>
<span class="linecomment">;;  and it can take a little getting used to, but it is quite powerful</span>
<span class="linecomment">;;  and lets you do things with completion that are otherwise</span>
<span class="linecomment">;;  impossible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the case of commands that use two-part multi-completions, you</span>
<span class="linecomment">;;  provide two regexps as input, one to match the name of a symbol</span>
<span class="linecomment">;;  (e.g. a function or variable) and one to match some associated</span>
<span class="linecomment">;;  information (doc string, property list, or type definition).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, since completion candidates are not actually multipart,</span>
<span class="linecomment">;;  you in fact type a single regexp that is the concatenation of the</span>
<span class="linecomment">;;  two.  You join these two regexps using `icicle-list-join-string'</span>
<span class="linecomment">;;  (a user option), which, by default, is `^G^J', that is, a</span>
<span class="linecomment">;;  control-G character followed by a control-J (newline) character.</span>
<span class="linecomment">;;  As always, you can input control characters using `C-q', so to</span>
<span class="linecomment">;;  input `^G^J' you can use `C-q C-g C-q C-j'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, in Icicles, `C-j' (newline) is self-inserting during</span>
<span class="linecomment">;;  completion, so you do not need to quote it with `C-q' - you can</span>
<span class="linecomment">;;  use just `C-q C-g C-j'.  Better yet, you can use `C-M-j'</span>
<span class="linecomment">;;  (`icicle-insert-list-join-string') to insert `^G^J'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This has the added benefit (in Emacs 22 or later) of hiding the</span>
<span class="linecomment">;;  `^G' - it's there, but you do not see it.  This hiding is only</span>
<span class="linecomment">;;  cosmetic; you still match the characters `^G' and `^J'.  In the</span>
<span class="linecomment">;;  same way, Icicles hides the `^G' part of `^G^J' in</span>
<span class="linecomment">;;  `*Completions*', so the join string appears as a newline</span>
<span class="linecomment">;;  character.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This hiding of `^G' happens only when option</span>
<span class="linecomment">;;  `icicle-list-join-string' has its (ugly but useful) default value.</span>
<span class="linecomment">;;  If not seeing the join string confuses you and you would prefer to</span>
<span class="linecomment">;;  distinguish multi-completion part separators from ordinary newline</span>
<span class="linecomment">;;  characters, then customize `icicle-list-join-string' - just remove</span>
<span class="linecomment">;;  the following from the Lisp sexp that defines the default value:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (set-text-properties 0 1 '(display "") strg)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of using a multi-completion command, you can use the</span>
<span class="linecomment">;;  following to match a function name that contains `dired' and its</span>
<span class="linecomment">;;  doc string that contains `file':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired^G^Jfile S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, you type this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired C-q C-g C-j file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  or this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired C-M-j file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Well, almost.  The way it actually works is that the completion</span>
<span class="linecomment">;;  candidates are themselves formed by concatenating symbol names</span>
<span class="linecomment">;;  with their doc strings, using `icicle-list-join-string'.  Your</span>
<span class="linecomment">;;  input regexp is matched against those candidates.  This means that</span>
<span class="linecomment">;;  the input regexp `dired^G^Jfile' would actually match only</span>
<span class="linecomment">;;  function names that *end* with `dired' and doc strings that</span>
<span class="linecomment">;;  *begin* with `file'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To match `file' against any part of the doc string, you must</span>
<span class="linecomment">;;  explicitly link the two component regexps with a regexp that</span>
<span class="linecomment">;;  matches anything.  If you want to search only the first lines of</span>
<span class="linecomment">;;  doc strings, you can use `.*' to do that: `dired.*^G^J.*file' will</span>
<span class="linecomment">;;  match all functions whose names contain `dired' and whose doc</span>
<span class="linecomment">;;  strings' first lines contain `file'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Why only the first lines?  Because `.' matches any character</span>
<span class="linecomment">;;  except a newline - it does not look past the first line.  If you</span>
<span class="linecomment">;;  want to search the entire doc strings (or property lists, for</span>
<span class="linecomment">;;  `icicle-plist'), then you need to use a connecting regexp that</span>
<span class="linecomment">;;  matches any character, including a newline.  That means a regexp</span>
<span class="linecomment">;;  such as `\(.\|\n\)'.  Or you can just use the Icicles multi-line</span>
<span class="linecomment">;;  dot feature - see (@&gt; "Dot, Dot, Dot").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Without a multi-line dot, you would use something like this to</span>
<span class="linecomment">;;  search whole, multi-line doc strings for `file':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired.*^G^J\(.\|\n\)*file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, you would type (without the spaces):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired.* C-M-j \ ( . \ | C-j \ ) * file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With a multi-line dot, you would type just this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc dired.* C-M-j . * file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What if you want to match, say, `file' in either the function name</span>
<span class="linecomment">;;  or the doc string, not necessarily both?  Remember that a</span>
<span class="linecomment">;;  multi-completion is in fact a single string, with a separator such</span>
<span class="linecomment">;;  as `^G^J' in the middle somewhere.  Because it is a single string,</span>
<span class="linecomment">;;  the simple minibuffer input `file' matches the substring `file'</span>
<span class="linecomment">;;  anywhere in the multi-completion.  So the answer is just this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-fundoc file S-TAB</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Even this simple command expression combines the effect of Emacs</span>
<span class="linecomment">;;  commands `apropos-function' with that of `apropos-documentation'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "How Multi-Completions Work")</span>
<span class="linecomment">;;  ** How Multi-Completions Work **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These commands that accept a multipart regexp are examples of</span>
<span class="linecomment">;;  Icicles multi-completion.  Icicles extends standard function</span>
<span class="linecomment">;;  `completing-read' so that it will accept, as the set of completion</span>
<span class="linecomment">;;  candidates, an alist argument whose candidates are not only</span>
<span class="linecomment">;;  individual strings but can also be lists of strings.  Each string</span>
<span class="linecomment">;;  in the list is one part of a multipart completion candidate, that</span>
<span class="linecomment">;;  is, a multi-completion.  The strings are joined together pairwise</span>
<span class="linecomment">;;  using `icicle-list-join-string' by `completing-read'.  Commands</span>
<span class="linecomment">;;  `icicle-fundoc' and`icicle-vardoc' each use lists of two strings</span>
<span class="linecomment">;;  (name and doc), but a multi-completion can have any number of</span>
<span class="linecomment">;;  strings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Why is the default value of `icicle-list-join-string' so odd:</span>
<span class="linecomment">;;  `^G^J'?  You can use any string you like, but here is the</span>
<span class="linecomment">;;  rationale behind the default choice:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  - ^G does not normally occur in simple strings such as doc strings</span>
<span class="linecomment">;;  - a newline (^J) visually separates the multiple component strings</span>
<span class="linecomment">;;  - ^G^J is not too difficult to enter: `C-M-j' or `C-q C-g C-j'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is important that the value of `icicle-list-join-string' not be</span>
<span class="linecomment">;;  something that is, itself, likely to match any of the candidates.</span>
<span class="linecomment">;;  Otherwise, it would not serve its role as separator.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I find that it helps a bit (in Emacs 22 or later) to customize</span>
<span class="linecomment">;;  face `escape-glyph', which is used for control characters such as</span>
<span class="linecomment">;;  `^G', in such a way that it stands out a bit, especially because</span>
<span class="linecomment">;;  control characters can be used in regexps that also use `^' as a</span>
<span class="linecomment">;;  special character.  I use an orange background with a blue</span>
<span class="linecomment">;;  foreground for this face.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because multi-completions often extend over multiple lines, and</span>
<span class="linecomment">;;  candidates in buffer `*Completions*' appear one right after the</span>
<span class="linecomment">;;  other, it's helpful to add additional separation between</span>
<span class="linecomment">;;  multi-completion candidates.  That is the purpose of user option</span>
<span class="linecomment">;;  `icicle-list-end-string', whose default value is "^J^J" (two</span>
<span class="linecomment">;;  newline characters).  It is automatically appended to each</span>
<span class="linecomment">;;  candidate, for purposes of both display and matching.  Remember</span>
<span class="linecomment">;;  that it is part of each multi-completion candidate, especially if</span>
<span class="linecomment">;;  you use a regexp that ends in `$', matching the end of the</span>
<span class="linecomment">;;  candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi-Completions Let You Match Multiple Things in Parallel")</span>
<span class="linecomment">;;  ** Multi-Completions Let You Match Multiple Things in Parallel **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Consider the command `describe-option-of-type', defined in my</span>
<span class="linecomment">;;  library `help-fns+.el' (or `help+.el', for Emacs 20).  This lets</span>
<span class="linecomment">;;  you first pick a `defcustom' type using completion and then pick</span>
<span class="linecomment">;;  an option of that type to describe.  There are two separate,</span>
<span class="linecomment">;;  sequential acts of completion.  For each completion act, your</span>
<span class="linecomment">;;  current input defines a set of matches.  You can see all option</span>
<span class="linecomment">;;  types that match, say, the regexp `.*string', which means all</span>
<span class="linecomment">;;  types that contain `string'.  After you choose one of those types,</span>
<span class="linecomment">;;  you can see all options of that type whose names start with</span>
<span class="linecomment">;;  `icicle' and then pick one.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can thus tweak the type regexp to filter types, and you can</span>
<span class="linecomment">;;  tweak the name regexp to filter option names.  And you can of</span>
<span class="linecomment">;;  course use progressive completion to whittle down either set of</span>
<span class="linecomment">;;  matches, piecemeal.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What you cannot do, however, using `describe-option-of-type' is</span>
<span class="linecomment">;;  filter both sets at the same time: narrow down the set of type</span>
<span class="linecomment">;;  matches and name matches simultaneously.  For that, you need</span>
<span class="linecomment">;;  Icicles multi-completion.  Without it, you must commit 100% to a</span>
<span class="linecomment">;;  type before you can choose among the options of that type.  With</span>
<span class="linecomment">;;  it, you can change the type (or the name) part of your input</span>
<span class="linecomment">;;  regexp on the fly, and see immediately the set of matching names</span>
<span class="linecomment">;;  (or types) as well.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi-Completions vs `completing-read-multiple'")</span>
<span class="linecomment">;;  ** Multi-Completions vs `completing-read-multiple' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that there is (only) a superficial similarity between Icicles</span>
<span class="linecomment">;;  multi-completion and the functionality provided by function</span>
<span class="linecomment">;;  `completing-read-multiple' of standard Emacs library `crm.el'.</span>
<span class="linecomment">;;  The latter lets you complete multiple strings in the minibuffer,</span>
<span class="linecomment">;;  one at a time.  It involves ordinary Emacs prefix completion, and</span>
<span class="linecomment">;;  it uses the same set of completion candidates for each of the</span>
<span class="linecomment">;;  strings in the input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By contrast, Icicles multi-completion completes each part of your</span>
<span class="linecomment">;;  input against a different set of completion candidates.  For</span>
<span class="linecomment">;;  example, when you use `icicle-vardoc', it completes the</span>
<span class="linecomment">;;  variable-name part of your input against the names of defined</span>
<span class="linecomment">;;  variables, and the variable-description part against the doc</span>
<span class="linecomment">;;  strings of defined variables.  Standard Emacs command</span>
<span class="linecomment">;;  `completing-read-multiple' lets you complete several different</span>
<span class="linecomment">;;  variable names at the same minibuffer prompt, but they each</span>
<span class="linecomment">;;  complete against the same set of variable names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-completion matches a list of regexps in parallel.  See also</span>
<span class="linecomment">;;  the description of `M-*', which matches a list of regexps in</span>
<span class="linecomment">;;  series: (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
<span class="linecomment">;;  You can combine these features, of course.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Sorting Candidates by Their Second Part")</span>
<span class="linecomment">;;  ** Sorting Candidates by Their Second Part **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most multi-completions have two parts.  Typically, the first part</span>
<span class="linecomment">;;  is the main part, that is, the part that you will most frequently</span>
<span class="linecomment">;;  complete against.  Many candidate sort orders involve some flavor</span>
<span class="linecomment">;;  of alphabetic order, and this means alphabetizing first with</span>
<span class="linecomment">;;  respect to the first multi-completion part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, it can sometimes be convenient to sort instead by the</span>
<span class="linecomment">;;  second part first.  That is what the Icicles sort order "by 2nd</span>
<span class="linecomment">;;  parts alphabetically" is for.  You can use it, for example, with</span>
<span class="linecomment">;;  command `icicle-locate-file' to sort file-name candidates first by</span>
<span class="linecomment">;;  date, and then by file-name for the same date.  This gives you an</span>
<span class="linecomment">;;  easy way to look up files that you modified during a given time</span>
<span class="linecomment">;;  period.  For example, your input regexp can limit candidates to</span>
<span class="linecomment">;;  those files last modified sometime in July, 2008, and you can then</span>
<span class="linecomment">;;  access these chronologically (by cycling or in buffer</span>
<span class="linecomment">;;  `*Completions*').  And do not forget that you can always reverse</span>
<span class="linecomment">;;  the current sort order, using `C-N C-,' where N is an integer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Programming Multi-Completions") for information about</span>
<span class="linecomment">;;    changing the appearance and behavior of Icicles</span>
<span class="linecomment">;;    multi-completions using Emacs-Lisp code.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Progressive Completion")</span>
 
<span class="linecomment">;;(@* "Dot, Dot, Dot")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Dot, Dot, Dot</span>
<span class="linecomment">;;  -------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is about dot, that is, `.', and its role as a regexp</span>
<span class="linecomment">;;  special character in apropos completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Since the inception of regular-expression matching, `.' has</span>
<span class="linecomment">;;  matched any character *except* a newline character (aka `^J', aka</span>
<span class="linecomment">;;  `C-j').  Recent languages typically have an additional mode in</span>
<span class="linecomment">;;  which `.' can match any character, including a newline.  See, for</span>
<span class="linecomment">;;  example, http://www.regular-expressions.info/dot.html and this</span>
<span class="linecomment">;;  language comparison for regexp features:</span>
<span class="linecomment">;;  http://www.regular-expressions.info/refflavors.html.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is not unusual to manipulate multi-line completion candidates</span>
<span class="linecomment">;;  in Icicles, in which case it can be handy to let `.' match any</span>
<span class="linecomment">;;  character, including a newline.  For this and more general</span>
<span class="linecomment">;;  reasons, I long ago requested such a mode for Emacs, but there was</span>
<span class="linecomment">;;  little interest in implementing it.  In Emacs, dot never matches a</span>
<span class="linecomment">;;  newline.  Too bad.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The regexp `\(.\|[\n]\)' is good enough, of course: it matches any</span>
<span class="linecomment">;;  character: any character any except newline, plus newline.  But it</span>
<span class="linecomment">;;  is a bit unwieldly, especially when used within a larger regexp,</span>
<span class="linecomment">;;  and especially if used more than once in the same regexp.</span>
<span class="linecomment">;;  Interactively, you input the `\n' using `C-j', and it appears in</span>
<span class="linecomment">;;  the minibuffer as a newline character; that is, it creates another</span>
<span class="linecomment">;;  line of input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For convenience in multi-line matching, I added a *multi-line</span>
<span class="linecomment">;;  dot*, or dot-matches-newline-too, hack to Icicles.  This feature</span>
<span class="linecomment">;;  is turned off, by default.  You can toggle it on/off, using</span>
<span class="linecomment">;;  command `icicle-toggle-dot', which is bound to `C-M-.' in the</span>
<span class="linecomment">;;  minibuffer during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When it is turned on, `.' is highlighted in the minibuffer (using</span>
<span class="linecomment">;;  face `highlight'), and it matches newlines also.  In fact,</span>
<span class="linecomment">;;  although it appears as just a highlighted dot, the ugly regexp</span>
<span class="linecomment">;;  `\(.\|[\n]\)' is really used, under the covers.  Icicles takes</span>
<span class="linecomment">;;  care of things so that you can edit normally (delete and transpose</span>
<span class="linecomment">;;  characters, etc.): A multi-line `.' acts just like a normal,</span>
<span class="linecomment">;;  single character, even though it is really a string of ten</span>
<span class="linecomment">;;  characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you prefer to see the full regexp, `\(.\|[\n]\)', but</span>
<span class="linecomment">;;  highlighted, then set option `icicle-dot-show-regexp-flag' to</span>
<span class="linecomment">;;  non-`nil'.  (In Emacs 20, the newline-matching dot is always shown</span>
<span class="linecomment">;;  as that full regexp.)  If you prefer to turn on newline matching</span>
<span class="linecomment">;;  by default, then just customize option `icicle-dot-string'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This match-anything dot is handy, but sometimes you might want to</span>
<span class="linecomment">;;  match anything except a newline, perhaps in the same input pattern</span>
<span class="linecomment">;;  where you also want to match any character (possibly a newline) at</span>
<span class="linecomment">;;  other positions.  How can you get the plain dot behavior, when</span>
<span class="linecomment">;;  multi-line dot is turned on?</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One way is just to use a regexp that matches anything except</span>
<span class="linecomment">;;  newline: `[^\n]' (which you input using `[ ^ C-j ]').  Another way</span>
<span class="linecomment">;;  is to use a plain prefix argument: `C-u .'.  (A numeric prefix</span>
<span class="linecomment">;;  argument N inserts N multi-line dots, each of which matches any</span>
<span class="linecomment">;;  single character.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-u' flips the behavior of `.' when you hit it: If by default `.'</span>
<span class="linecomment">;;  enters a multi-line dot, then `C-u .' enters a plain dot.  If by</span>
<span class="linecomment">;;  default `.' enters a plain dot, then `C-u .' enters a multi-line</span>
<span class="linecomment">;;  dot.  So `C-u' also gives you a way to enter a one-off multi-line</span>
<span class="linecomment">;;  dot, if you prefer to generally have `.' not match a newline.</span>
<span class="linecomment">;;  Either way, what you see in the minibuffer is the single character</span>
<span class="linecomment">;;  `.', highlighted if it is a multi-line dot, unhighlighted if it is</span>
<span class="linecomment">;;  a plain dot.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-line dots are converted to plain dots automatically when you</span>
<span class="linecomment">;;  use prefix completion.  And if you then move back to apropos</span>
<span class="linecomment">;;  completion during the same completion operation, you get back any</span>
<span class="linecomment">;;  multi-line dots you had before, and any plain dots that you</span>
<span class="linecomment">;;  entered before remain plain.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So when is a multi-line dot useful?  Whenever you want to match</span>
<span class="linecomment">;;  against multi-line candidates.  Typical use cases include</span>
<span class="linecomment">;;  `icicle-search' and the Icicles doc commands, `icicle-vardoc',</span>
<span class="linecomment">;;  `icicle-fundoc', and `icicle-doc'.</span>
 
<span class="linecomment">;;(@* "Fuzzy Completion")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Fuzzy Completion</span>
<span class="linecomment">;;  ----------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are a few different kinds of what might be called "fuzzy"</span>
<span class="linecomment">;;  matching used in Icicles completion, in addition to apropos</span>
<span class="linecomment">;;  (regexp) matching and prefix matching.  And if you have your own</span>
<span class="linecomment">;;  method of matching then you can use that as well, by adding it to</span>
<span class="linecomment">;;  option `icicle-S-TAB-completion-methods-alist'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following methods are predefined:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Fuzzy - This method uses a fairly sophisticated matching</span>
<span class="linecomment">;;    algorithm that seems to account for various typing mistakes.</span>
<span class="linecomment">;;    This algorithm is provided by library `fuzzy-match.el', so I</span>
<span class="linecomment">;;    call its use in Icicles `fuzzy' completion.  You must have</span>
<span class="linecomment">;;    library `fuzzy-match.el' to use this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Swank - Symbols are completed using the algorithm of</span>
<span class="linecomment">;;    `el-swank-fuzzy.el' - see that library for details.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Scatter - This is a simple, poor man's fuzzy matching method</span>
<span class="linecomment">;;    that I call `scatter' matching.  Ido calls it `flex' matching.</span>
<span class="linecomment">;;    The TextMate editor has the same thing for file-name matching</span>
<span class="linecomment">;;    (only), without naming it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Levenshtein - This method checks whether two strings differ by</span>
<span class="linecomment">;;    at most a given number of character operations, the so-called</span>
<span class="linecomment">;;    "Levenshtein distance".  You must have library `levenshtein.el'</span>
<span class="linecomment">;;    to use this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Jaro-Winkler - This method gives matching weight to having both</span>
<span class="linecomment">;;    (a) more characters that match in the right positions (Jara) and</span>
<span class="linecomment">;;    (b) a longer exact prefix within the first four characters</span>
<span class="linecomment">;;    (Winkler).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  My opinion about the relative usefulness of the various methods:</span>
<span class="linecomment">;;  Basic (prefix) completion and apropos completion are by far the</span>
<span class="linecomment">;;  most useful.  They are followed, in order of decreasing</span>
<span class="linecomment">;;  usefulness, by scatter, fuzzy, Levenshtein, vanilla, Jaro-Winkler,</span>
<span class="linecomment">;;  and swank completion. YMMV.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Besides these methods, remember that you can get ordinary</span>
<span class="linecomment">;;  substring matching with `S-TAB' by using `C-`' to turn off</span>
<span class="linecomment">;;  (toggle) escaping of regexp special characters.  With special</span>
<span class="linecomment">;;  characters escaped, `S-TAB' does literal substring completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The type of completion matching that is used when you hit `S-TAB'</span>
<span class="linecomment">;;  and `TAB' is controlled by user options</span>
<span class="linecomment">;;  `icicle-S-TAB-completion-methods-alist' and</span>
<span class="linecomment">;;  `icicle-TAB-completion-methods', respectively.  The possible</span>
<span class="linecomment">;;  methods for `TAB' are predefined, but you can add additional</span>
<span class="linecomment">;;  methods for `S-TAB' by customizing</span>
<span class="linecomment">;;  `icicle-S-TAB-completion-methods-alist'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Changing Completion Method")</span>
<span class="linecomment">;;  ** Changing Completion Method **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use fuzzy or swank completion in place of prefix</span>
<span class="linecomment">;;  completion (`TAB').  You can use scatter, Levenshtein, or</span>
<span class="linecomment">;;  Jaro-Winkler completion in place of apropos completion (`S-TAB').</span>
<span class="linecomment">;;  You can change completion methods easily at any time, by hitting a</span>
<span class="linecomment">;;  key in the minibuffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-(' (command `icicle-next-TAB-completion-method') to cycle</span>
<span class="linecomment">;;    among `TAB' completion methods: `basic', `vanilla', `fuzzy', and</span>
<span class="linecomment">;;    `swank' (`vanilla' only for Emacs 23 and later; `fuzzy' only if</span>
<span class="linecomment">;;    you have library `fuzzy-match.el'; `swank' only if you have</span>
<span class="linecomment">;;    library `el-swank-fuzzy.el').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `M-(' (command `icicle-next-S-TAB-completion-method') to cycle</span>
<span class="linecomment">;;    `S-TAB' completion methods: `apropos', `scatter', `Levenshtein',</span>
<span class="linecomment">;;    `Levenshtein strict', and `Jaro-Winkler' (only if you have the</span>
<span class="linecomment">;;    Autocomplete library `fuzzy.el').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Repeating `C-(' and `TAB' or `M-(' and `S-TAB' on the fly for the</span>
<span class="linecomment">;;  same input can be a good way to learn the differences between the</span>
<span class="linecomment">;;  various completion methods.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you provide a prefix argument to `C-(' or `M-(', then the newly</span>
<span class="linecomment">;;  chosen method is used only for the current command.  More</span>
<span class="linecomment">;;  precisely, the previously active method is restored as soon as you</span>
<span class="linecomment">;;  return to the top level.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The completion methods available for cycling via `C-(' or `M-('</span>
<span class="linecomment">;;  are defined by options `icicle-TAB-completion-methods' and</span>
<span class="linecomment">;;  `icicle-S-TAB-completion-methods-alist', respectively.  By</span>
<span class="linecomment">;;  default, the first method in each list is used for matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Sometimes you might want to make a different set of completion</span>
<span class="linecomment">;;  methods available during input.  You can use options</span>
<span class="linecomment">;;  `icicle-TAB-completion-methods-per-command' and</span>
<span class="linecomment">;;  `icicle-S-TAB-completion-methods-per-command' to do this.  These</span>
<span class="linecomment">;;  define the methods to be made available during specific commands</span>
<span class="linecomment">;;  (that read input with completion).  That is, they give you</span>
<span class="linecomment">;;  command-specific control over `C-(' and `M-('.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The per-command control is provided by advising (`defadvice') the</span>
<span class="linecomment">;;  particular commands.  You can also do this interactively, using</span>
<span class="linecomment">;;  commands `icicle-set-TAB-methods-for-command' and</span>
<span class="linecomment">;;  `icicle-set-S-TAB-methods-for-command'.  Invoking one of these</span>
<span class="linecomment">;;  with a negative prefix argument removes the advice, restoring the</span>
<span class="linecomment">;;  default choice of methods for the target command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, this sets the available `TAB' methods for command</span>
<span class="linecomment">;;  `icicle-read-color' to fuzzy (the default for this command) and</span>
<span class="linecomment">;;  basic:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    M-x icicle-set-TAB-methods-for-command RET</span>
<span class="linecomment">;;    Command: icicle-read-color RET</span>
<span class="linecomment">;;    TAB methods: fuzzy RET</span>
<span class="linecomment">;;    TAB methods: basic RET</span>
<span class="linecomment">;;    TAB methods: RET</span>
<span class="linecomment">;;      </span>
<span class="linecomment">;;  And this removes the special treatment for `C-(' during</span>
<span class="linecomment">;;  `icicle-read-color', restoring the default `TAB' methods that are</span>
<span class="linecomment">;;  defined by option `icicle-TAB-completion-methods':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    C-- M-x icicle-set-TAB-methods-for-command RET</span>
<span class="linecomment">;;    Command: icicle-read-color RET</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Partial Completion")</span>
<span class="linecomment">;;  ** Partial Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section pertains to Emacs releases starting with Emacs 23.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If option `icicle-TAB-completion-methods' includes `vanilla'</span>
<span class="linecomment">;;  (which it does, by default), and you choose `vanilla' completion</span>
<span class="linecomment">;;  for `TAB' (by cycling using `C-(' or by customizing</span>
<span class="linecomment">;;  `icicle-TAB-completion-methods' to use `vanilla' as the default),</span>
<span class="linecomment">;;  then Icicles `TAB' completion respects the standard Emacs option</span>
<span class="linecomment">;;  `completion-styles', so the behavior of `TAB' is similar to what</span>
<span class="linecomment">;;  it is in vanilla Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Emacs includes `partial-completion' in the default value of</span>
<span class="linecomment">;;  `completion-styles'.  This means that Icicles too will make use of</span>
<span class="linecomment">;;  partial completion when you use `TAB' (with `vanilla').  Icicles</span>
<span class="linecomment">;;  makes no use of `completion-styles' when you use `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Partial completion is not really a kind of fuzzy completion, but</span>
<span class="linecomment">;;  its effect can sometimes be similar.  In some ways, it is similar</span>
<span class="linecomment">;;  to scatter-match completion (see next), but it requires you to</span>
<span class="linecomment">;;  explicitly mark where to skip ahead (using `*', ` ' (space), or</span>
<span class="linecomment">;;  `-').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles does not support using the mode `partial-completion-mode',</span>
<span class="linecomment">;;  and Emacs itself is in the process of deprecating it, now that the</span>
<span class="linecomment">;;  partial-completion style is active by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I do not necessarily recommend using `vanilla' for `TAB'</span>
<span class="linecomment">;;  completion, or, if you do, including `partial-completion' as an</span>
<span class="linecomment">;;  entry in `completion-styles', because its effect is often</span>
<span class="linecomment">;;  counter-intuitive or confusing.  But it is included by default in</span>
<span class="linecomment">;;  Emacs, and Icicles supports it.  You might find it useful in</span>
<span class="linecomment">;;  file-name completion, to be able to complete directory components,</span>
<span class="linecomment">;;  for instance.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Scatter-Match Completion")</span>
<span class="linecomment">;;  ** Scatter-Match Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The idea behind scatter-match completion is very simple: input</span>
<span class="linecomment">;;  characters are matched in order against completion candidates, but</span>
<span class="linecomment">;;  possibly with intervening characters.  That is, your input</span>
<span class="linecomment">;;  scatter-matches a completion candidate if each character is also</span>
<span class="linecomment">;;  in the candidate, and the character order is respected.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What this really amounts to is matching input `abc' as if it were</span>
<span class="linecomment">;;  the regexp `a.*b.*c'.  That's all.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use Icicles scatter matching at any time in place of</span>
<span class="linecomment">;;  apropos (regexp) matching.  Unlike the cases of swank and fuzzy</span>
<span class="linecomment">;;  completion (see below), you can use it to complete file names</span>
<span class="linecomment">;;  also.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Swank (Fuzzy Symbol) Completion")</span>
<span class="linecomment">;;  ** Swank (Fuzzy Symbol) Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you choose `swank' completion, what you get in Icicles is fuzzy</span>
<span class="linecomment">;;  completion (see next), except regarding symbols.  That is, swank</span>
<span class="linecomment">;;  completion per se applies only to symbols.  Symbols are completed</span>
<span class="linecomment">;;  using the algorithm of `el-swank-fuzzy.el' - see that library for</span>
<span class="linecomment">;;  details.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles options `icicle-swank-timeout' and</span>
<span class="linecomment">;;  `icicle-swank-prefix-length' give you some control over the</span>
<span class="linecomment">;;  behavior.  When the `TAB' completion method is `swank', you can</span>
<span class="linecomment">;;  use `C-x 1' (`icicle-doremi-increment-swank-timeout+') and `C-x 2'</span>
<span class="linecomment">;;  (`icicle-doremi-increment-swank-prefix-length+') in the minibuffer</span>
<span class="linecomment">;;  to increment these options on the fly using the arrow keys `up'</span>
<span class="linecomment">;;  and `down'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Swank symbol completion uses heuristics that relate to supposedly</span>
<span class="linecomment">;;  typical patterns found in symbol names.  It also uses a timeout</span>
<span class="linecomment">;;  that can limit the number of matches.  It is generally quite a bit</span>
<span class="linecomment">;;  slower than fuzzy completion, and it sometimes does not provide</span>
<span class="linecomment">;;  all candidates that you might think should match, even when all of</span>
<span class="linecomment">;;  your input is a prefix (or even when it is already complete!).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If swank completion produces no match when you think it should,</span>
<span class="linecomment">;;  remember that you can use `C-(' on the fly to change the</span>
<span class="linecomment">;;  completion method.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I do not necessarily recommend swank symbol completion, but it is</span>
<span class="linecomment">;;  available for those who appreciate it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Like fuzzy completion (see next), swank completion always sorts</span>
<span class="linecomment">;;  candidate symbols according to its own scoring, putting what it</span>
<span class="linecomment">;;  thinks are the best matches first.  This means that using `C-,' in</span>
<span class="linecomment">;;  the minibuffer to sort candidates differently has no effect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Fuzzy-Match Completion")</span>
<span class="linecomment">;;  ** Fuzzy-Match Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Fuzzy completion takes more explaining.  It is described in detail</span>
<span class="linecomment">;;  in the commentary of library `fuzzy-match.el'; please refer to</span>
<span class="linecomment">;;  that documentation.  Here are some things to keep in mind when you</span>
<span class="linecomment">;;  use Icicles fuzzy completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * File-name completion is never fuzzy.  Basic prefix completion is</span>
<span class="linecomment">;;    used for file names.</span>
<span class="linecomment">;;  * Fuzzy completion is always case-sensitive.  This means that</span>
<span class="linecomment">;;    `C-A' in the minibuffer has no effect on fuzzy completion.</span>
<span class="linecomment">;;  * Fuzzy completion always takes a space prefix in your input into</span>
<span class="linecomment">;;    account.  This means that `M-_' in the minibuffer has no effect</span>
<span class="linecomment">;;    on fuzzy completion.</span>
<span class="linecomment">;;  * Fuzzy completion candidates are always sorted by decreasing</span>
<span class="linecomment">;;    match strength.  This means that using `C-,' in the minibuffer</span>
<span class="linecomment">;;    to sort candidates differently has no effect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Fuzzy completion is a form of prefix completion in which some</span>
<span class="linecomment">;;  input characters might not be present in a matched candidate.</span>
<span class="linecomment">;;  Matching finds the candidates that have the most characters in</span>
<span class="linecomment">;;  common with your input, in the same order and with a minimum of</span>
<span class="linecomment">;;  non-matching characters.  It can skip over non-matching</span>
<span class="linecomment">;;  characters, as long as the number of characters skipped in the</span>
<span class="linecomment">;;  candidate is less that those following them that match.  After the</span>
<span class="linecomment">;;  matching candidates are found, they are sorted by skip length and</span>
<span class="linecomment">;;  then candidate length.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some examples:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Input         Completion Domain  Matches (Candidates)</span>
<span class="linecomment">;;  -----         -----------------  --------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  abc           {xxabcxx, xabcxxx,</span>
<span class="linecomment">;;                          xabx}    {xabcxxx, xxabcxx}</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  point-mx      Emacs variables    {point-max, point-max-marker}</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  begining-of-l Emacs commands     {beginning-of-line,</span>
<span class="linecomment">;;                                    beginning-of-line-text,</span>
<span class="linecomment">;;                                    move-beginning-of-line,</span>
<span class="linecomment">;;                                    widget-beginning-of-line}</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The last example shows that although fuzzy matching is a kind of</span>
<span class="linecomment">;;  prefix matching, your input is not necessarily a prefix of each</span>
<span class="linecomment">;;  matching candidate.  It is prefix matching because it tries to</span>
<span class="linecomment">;;  match your input starting at its beginning.  This input prefix is</span>
<span class="linecomment">;;  matched against candidate substrings, not necessarily candidate</span>
<span class="linecomment">;;  prefixes, but the non-matching part (if any) preceding the matched</span>
<span class="linecomment">;;  substring must not be longer than the matching part.  That is,</span>
<span class="linecomment">;;  non-matching substrings can be skipped over, but they must be no</span>
<span class="linecomment">;;  longer than the matching substrings that follow them.  If an input</span>
<span class="linecomment">;;  prefix does not match under these conditions, it is skipped over.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  After matching an input prefix this way, the same process is</span>
<span class="linecomment">;;  repeated, recursively, for input text following that prefix and</span>
<span class="linecomment">;;  for match positions following the matches found.  That is, after</span>
<span class="linecomment">;;  each such prefix match, the process starts again where it left off</span>
<span class="linecomment">;;  in both the input and the candidates.  The resulting matches</span>
<span class="linecomment">;;  contain one or more substrings of your input that are each at</span>
<span class="linecomment">;;  least as long as the non-matching parts that immediately precede</span>
<span class="linecomment">;;  them.  Only matches with the highest number of matching characters</span>
<span class="linecomment">;;  are retained.  They are sorted by two criteria: (1) nearness of</span>
<span class="linecomment">;;  matches to the start of the candidate and (2) candidate length.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The fuzzy-match algorithm is detailed in library `fuzzy-match.el'.</span>
<span class="linecomment">;;  However, it is easier to get a feel for what it does by trying it</span>
<span class="linecomment">;;  than by reading any description.  Just give it a try.  Do not</span>
<span class="linecomment">;;  expect it to rival apropos completion in power or expressivity,</span>
<span class="linecomment">;;  however.  Instead, think of it as prefix completion for lazy or</span>
<span class="linecomment">;;  inaccurate typists!  If that sounds like you, then you might find</span>
<span class="linecomment">;;  it useful.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example, here are some command-name candidates for the input</span>
<span class="linecomment">;;  `fo' (there are lots more):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  fortune          forms-mode       focus-frame</span>
<span class="linecomment">;;  follow-mode      forward-sexp     forward-list</span>
<span class="linecomment">;;  forward-word     forward-line     forward-page</span>
<span class="linecomment">;;  ...</span>
<span class="linecomment">;;  ifconfig         info             Info-up</span>
<span class="linecomment">;;  Info-edit        Info-next        Info-help</span>
<span class="linecomment">;;  ...</span>
<span class="linecomment">;;  Info-mouse-follow-nearest-node    Info-goto-emacs-key-command-node</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And here are all the command-name candidates for the input `fol':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  follow-mode            follow-delete-other-windows-and-split</span>
<span class="linecomment">;;  Info-last              info-lookup-file       info-lookup-reset</span>
<span class="linecomment">;;  Info-last-preorder     info-lookup-symbol     Info-last-menu-item</span>
<span class="linecomment">;;  nnfolder-generate-active-file     mh-folder-mode</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first thing to notice is the distribution of candidates for</span>
<span class="linecomment">;;  input `fo'.  Candidates are in decreasing order of match fit:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The nearer the match to the start of the candidate, the better</span>
<span class="linecomment">;;    the fit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The greater the ratio of matched text to unmatched text, the</span>
<span class="linecomment">;;    better the fit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note too the candidate `ifconfig'.  First, note that it has no</span>
<span class="linecomment">;;  strict match for substring `fo'.  Its match is in fact in two</span>
<span class="linecomment">;;  parts: `f', then `o'.  Second, note that it is considered a better</span>
<span class="linecomment">;;  fuzzy match than the candidate `info'.  This is because its match</span>
<span class="linecomment">;;  (`f') is nearer to the start of the candidate (second character,</span>
<span class="linecomment">;;  versus third).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The second thing to notice is that when you type the third input</span>
<span class="linecomment">;;  character, `l', the candidates are not a subset of the original</span>
<span class="linecomment">;;  set that matches `fo'.  The candidates in the second screenshot</span>
<span class="linecomment">;;  all match `fol' in a fuzzy way, even though one of them,</span>
<span class="linecomment">;;  `mh-folder-mode', does not match `fo' sufficiently well to be</span>
<span class="linecomment">;;  included as a candidate.  Why?  Because in the `fo' case, the</span>
<span class="linecomment">;;  match is only two characters long and it starts after three</span>
<span class="linecomment">;;  non-matching characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For both inputs: If all input prefixes are fair game for matching,</span>
<span class="linecomment">;;  why doesn't `*Completions*' also include other command names that</span>
<span class="linecomment">;;  match only the prefix `f' and nothing else?  Because there is at</span>
<span class="linecomment">;;  least one match that matches more than that - only the best</span>
<span class="linecomment">;;  matches are retained.  In this case, the best matches for input</span>
<span class="linecomment">;;  `fo' match both the `f' and the `o', and the best matches for</span>
<span class="linecomment">;;  input `fol' match all three of those characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Refer to `fuzzy-match.el' for a precise description of fuzzy</span>
<span class="linecomment">;;  matching.  It refers to "matchiness" for how many characters match</span>
<span class="linecomment">;;  and "closeness" for the ratio of number of characters matched to</span>
<span class="linecomment">;;  candidate length.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note: It is not practical to try to highlight the exact candidate</span>
<span class="linecomment">;;  portions that match different parts of your input.  Because</span>
<span class="linecomment">;;  fuzzy-match input does not function as a literal string for</span>
<span class="linecomment">;;  matching purposes, it is more akin to substring matching than to</span>
<span class="linecomment">;;  plain prefix matching.  For this reason, regexp-match highlighting</span>
<span class="linecomment">;;  is used for fuzzy matching.  That is why you see the input `fo'</span>
<span class="linecomment">;;  highlighted in `*Completions*' candidates in other than just the</span>
<span class="linecomment">;;  prefix position.  It is also why the matching `f' and `o' in</span>
<span class="linecomment">;;  candidate `ifconfig' are not highlighted: for highlighting</span>
<span class="linecomment">;;  purposes, your input is treated as a regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One takeaway here is that fuzzy completion is complicated.  Rather</span>
<span class="linecomment">;;  than try to understand how it works and think ahead in those</span>
<span class="linecomment">;;  terms, you just need to get a feel for it - learn by doing.  Have</span>
<span class="linecomment">;;  fun!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Levenshtein Completion")</span>
<span class="linecomment">;;  ** Levenshtein Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The "Levenshtein distance" is the maximum number of character</span>
<span class="linecomment">;;  insertions, deletions, or replacements that are needed to</span>
<span class="linecomment">;;  transform one string to another.  The more similar two strings</span>
<span class="linecomment">;;  are, the smaller their Levenshtein distance.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When this kind of completion is used, Icicles considers your input</span>
<span class="linecomment">;;  to match a completion candidate if their Levenshtein distance is</span>
<span class="linecomment">;;  no greater than the value of option `icicle-levenshtein-distance'.</span>
<span class="linecomment">;;  The default value of the option is 1, meaning that the difference</span>
<span class="linecomment">;;  is at most one character operation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Using a strict definition of the distance, this also requires the</span>
<span class="linecomment">;;  length of your input to be within the Levenshtein distance of the</span>
<span class="linecomment">;;  length of a completion candidate, for it to match.  That is quite</span>
<span class="linecomment">;;  restrictive.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is more flexible to consider your input to match a candidate if</span>
<span class="linecomment">;;  it is within `icicle-levenshtein-distance' of some *substring* of</span>
<span class="linecomment">;;  the candidate.  Because candidate substrings are tested, the</span>
<span class="linecomment">;;  length of your input need not be nearly the same as the candidate</span>
<span class="linecomment">;;  length.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you cycle among `S-TAB' completion methods using `M-(', there</span>
<span class="linecomment">;;  are thus two choices for Levenshtein completion: `Levenshtein' and</span>
<span class="linecomment">;;  `Levenshtein strict'.  The former is generally more useful.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The larger the value of `icicle-levenshtein-distance', the slower</span>
<span class="linecomment">;;  Levenshtein completion becomes, since it must test more</span>
<span class="linecomment">;;  possibilities.  Also, when the value is 1 (except for `Levenshtein</span>
<span class="linecomment">;;  strict'), Icicles uses a fast, special-case algorithm, and it</span>
<span class="linecomment">;;  highlights the matching parts of candidates in buffer</span>
<span class="linecomment">;;  `*Completions*'.  1 is the most useful value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the value is other than 1 (or if it is 1 with `Levenshtein</span>
<span class="linecomment">;;  strict'), then you must also use library `levenshtein.el', and</span>
<span class="linecomment">;;  Levenshtein completion can be quite slow.  In that case, you will</span>
<span class="linecomment">;;  no doubt want to turn off incremental completion (`C-#').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Jaro-Winkler Completion")</span>
<span class="linecomment">;;  **  Jaro-Winkler Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Jaro-Winkler method was developed for comparing names for the</span>
<span class="linecomment">;;  U.S. census.  It tends to take into account some typical spelling</span>
<span class="linecomment">;;  mistakes, and it is best suited for use with short candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When checking whether two strings match, higher matching weight</span>
<span class="linecomment">;;  results when there are more characters in each string that are</span>
<span class="linecomment">;;  also present in the other, and in approximately the same</span>
<span class="linecomment">;;  positions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Looking only at those characters that nearly match in this sense</span>
<span class="linecomment">;;  (same character in about the same position), the more exact</span>
<span class="linecomment">;;  matches there are (same character in exactly the same position),</span>
<span class="linecomment">;;  the higher the matching weight.  That is, weight is reduced for</span>
<span class="linecomment">;;  characters that nearly match but are not quite in the right</span>
<span class="linecomment">;;  position.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So far, this describes Jaro matching.  The Jaro matching weight is</span>
<span class="linecomment">;;  the average of three values; (a) the ratio of the first string's</span>
<span class="linecomment">;;  near matches to its length, the same for the second string, and</span>
<span class="linecomment">;;  (c) the ratio of exact matches to total matches (near and exact).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The Winkler part of the method comes from giving additional weight</span>
<span class="linecomment">;;  for prefixes that match exactly.  The longer the exact prefix</span>
<span class="linecomment">;;  match (up to 4 characters) the greater the weight.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Unlike the other matching methods, for Jaro-Winkler to complete</span>
<span class="linecomment">;;  your input it must have the same number of characters as the</span>
<span class="linecomment">;;  candidate to be matched, plus or minus two (actually</span>
<span class="linecomment">;;  `fuzzy-accept-length-difference').  In particular, this means that</span>
<span class="linecomment">;;  you cannot hit `S-TAB' with an empty minibuffer to see all of the</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Icicles Multi `M-x'")</span>
<span class="linecomment">;;    for completion of command abbreviations</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Apropos Completions")</span>
<span class="linecomment">;;    for completion with regexp matching</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * http://en.wikipedia.org/wiki/Jaro-Winkler_distance for</span>
<span class="linecomment">;;    information about Jaro-Winkler matching</span>
 
<span class="linecomment">;;(@* "Completion in Other Buffers")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Completion in Other Buffers</span>
<span class="linecomment">;;  ---------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition to input completion, you can use Icicles to complete</span>
<span class="linecomment">;;  words and symbols in other buffers, besides the minibuffer.</span>
<span class="linecomment">;;  Icicles enhances this completion in these ways:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Lisp symbol completion via `M-TAB' (`lisp-complete-symbol').</span>
<span class="linecomment">;;     (This is also `ESC-TAB' and `C-M-i'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Word completion using the dynamic abbreviation of standard</span>
<span class="linecomment">;;     Emacs library `dabbrev.el', via `C-M-/'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Mailing information completion for BBDB (Insidious Big Brother</span>
<span class="linecomment">;;     Database).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Word completion using the words and phrases in a thesaurus, via</span>
<span class="linecomment">;;     `C-c /' (requires library `synonyms.el').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. `TAB' completion of the following in Shell mode and ESS modes</span>
<span class="linecomment">;;     (and other, similar interpreters):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     * Commands</span>
<span class="linecomment">;;     * Previous inputs - commands plus their arguments</span>
<span class="linecomment">;;     * File names</span>
<span class="linecomment">;;     * Environment variables</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whenever multiple completion candidates are available, you can use</span>
<span class="linecomment">;;  Icicles completion, with all of its features: cycling of</span>
<span class="linecomment">;;  candidates (`TAB', `down', or `next'), apropos (regexp) completion</span>
<span class="linecomment">;;  (`S-TAB'), progressive completion (`M-SPC'), help on individual</span>
<span class="linecomment">;;  candidates (`C-M-RET'), and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Dynamic Abbreviation")</span>
<span class="linecomment">;;  ** Dynamic Abbreviation **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `dabbrev.el' lets you type a few characters in a buffer</span>
<span class="linecomment">;;  and then prefix-complete them (in the same buffer) to a full word</span>
<span class="linecomment">;;  or symbol name.  The completion candidates come from words or</span>
<span class="linecomment">;;  symbol names in buffers that you are editing.  This functionality</span>
<span class="linecomment">;;  is called "dynamic abbreviation", though that is not a very good</span>
<span class="linecomment">;;  term for it (words are completed, not abbreviated, dynamically).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Emacs, there are two ways to "dynamically abbreviate" text:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  a. `M-/' (command `dabbrev-expand') completes to a candidate word.</span>
<span class="linecomment">;;     Repeating it replaces the completion with a different one -</span>
<span class="linecomment">;;     that is, it cycles candidates in the text buffer (not in the</span>
<span class="linecomment">;;     minibuffer).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  b. `C-M-/' (command `dabbrev-completion') completes to the common</span>
<span class="linecomment">;;     prefix of all matching completion candidates.  Repeating it</span>
<span class="linecomment">;;     displays buffer `*Completions*' for you to choose a candidate.</span>
<span class="linecomment">;;     However, in this case, there is no way to cycle among the</span>
<span class="linecomment">;;     candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If there are many candidate completions, then cycling among them</span>
<span class="linecomment">;;  with `M-/' can be tedious.  You can use `C-M-/' to complete to a</span>
<span class="linecomment">;;  common prefix, thus narrowing the set of candidates, but then you</span>
<span class="linecomment">;;  lose the ability to cycle among them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-functions-to-redefine' contains an entry</span>
<span class="linecomment">;;  for `dabbrev-completion' (which it does by default) then Icicles</span>
<span class="linecomment">;;  redefines command `dabbrev-completion' (it does not change</span>
<span class="linecomment">;;  `dabbrev-expand') so that it uses Icicles completion when there</span>
<span class="linecomment">;;  are multiple completions.  You can use any Icicles features, such</span>
<span class="linecomment">;;  as apropos completion and candidate cycling.  In addition, you can</span>
<span class="linecomment">;;  even complete an empty prefix, starting from scratch with apropos</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "BBDB Completion")</span>
<span class="linecomment">;;  ** BBDB Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `bbdb.el', available at http://bbdb.sourceforge.net/, is a</span>
<span class="linecomment">;;  rolodex-like database program for GNU Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If user option `icicle-functions-to-redefine' contains an entry</span>
<span class="linecomment">;;  for `bbdb-complete-name' (which it does by default) then Icicles</span>
<span class="linecomment">;;  redefines command `bbdb-complete-name' so that it uses Icicles</span>
<span class="linecomment">;;  completion when there are multiple completions.  You can use any</span>
<span class="linecomment">;;  Icicles features, such as apropos completion and candidate</span>
<span class="linecomment">;;  cycling.  For this feature to take effect, you must load BBDB</span>
<span class="linecomment">;;  before you load Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Thesaurus Completion")</span>
<span class="linecomment">;;  ** Thesaurus Completion **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Library `synonyms.el' provides various features for defining a</span>
<span class="linecomment">;;  thesaurus and looking up words and phrases in it.  Command</span>
<span class="linecomment">;;  `icicle-complete-thesaurus-entry' takes advantage of these</span>
<span class="linecomment">;;  features.  You can use it to complete a word in a text buffer to</span>
<span class="linecomment">;;  any word or phrase in the thesaurus.  With the default value of</span>
<span class="linecomment">;;  option `icicle-top-level-key-bindings', this is bound to `C-c /'</span>
<span class="linecomment">;;  in Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Tip: You can use `icicle-complete-thesaurus-entry' to quickly</span>
<span class="linecomment">;;  check the spelling of a word.  If it is correctly spelled, then it</span>
<span class="linecomment">;;  appears as a complete completion (is highlighted as such in the</span>
<span class="linecomment">;;  minibuffer).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another Icicles command that uses the thesaurus is</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry'.  It lets you use Icicles</span>
<span class="linecomment">;;  completion, cycling, and so on to insert thesaurus words and</span>
<span class="linecomment">;;  phrases in any buffer.  It does not complete the word at point.</span>
<span class="linecomment">;;  It is a multi-command (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")), so you</span>
<span class="linecomment">;;  can, within a single call to it, insert any number of thesaurus</span>
<span class="linecomment">;;  entries, in succession.  If you wanted to, you could write an</span>
<span class="linecomment">;;  entire book using a single call to</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry'!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Both commands, `icicle-complete-thesaurus-entry' and</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry', require that you first load</span>
<span class="linecomment">;;  library `synonyms.el'.  See library `synonyms.el' for more</span>
<span class="linecomment">;;  information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Completion in Comint Modes")</span>
<span class="linecomment">;;  ** Completion in Comint Modes **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `TAB' in a shell or similar buffer provides Icicles completion for</span>
<span class="linecomment">;;  command names, file names, and environment variables that are</span>
<span class="linecomment">;;  known to the shell (or other interpreter).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also complete input using your previous inputs as the set</span>
<span class="linecomment">;;  of candidates.  Just type something at the prompt, hit `C-c `',</span>
<span class="linecomment">;;  and pick one or more previous inputs to execute again (this uses</span>
<span class="linecomment">;;  `icicle-search', so it is a multi-command).  You need not</span>
<span class="linecomment">;;  re-execute the exact same shell command; you can edit your</span>
<span class="linecomment">;;  previous input before hitting `RET' to enter the command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These features are available for Comint mode and several modes</span>
<span class="linecomment">;;  that inherit from it, including Shell mode, Shell Script (SH)</span>
<span class="linecomment">;;  mode, various ESS modes (Emacs Speaks Statistics), Inferior</span>
<span class="linecomment">;;  Emacs-Lisp mode (IELM), Grand Unified Debugger (GUD) mode, Tcl</span>
<span class="linecomment">;;  mode, Rlogin mode, and NS Lookup mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Icicles Shell-Command Enhancements") for more information</span>
<span class="linecomment">;;    about Icicles enhancements for Comint mode and related modes</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Other Icicles Search Commands") for information about other</span>
<span class="linecomment">;;    Icicles search enhancements for Comint mode and related modes</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Buffer-Text Completion for Comint Modes") for</span>
<span class="linecomment">;;    information about how you can add Icicles completion to other</span>
<span class="linecomment">;;    modes that inherit from Comint mode</span>
 
<span class="linecomment">;;(@* "Customization and General Tips")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Customization and General Tips</span>
<span class="linecomment">;;  ------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section contains some tips on using Icicles and descriptions</span>
<span class="linecomment">;;  of Icicles user options.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "File-Name and Directory-Name Completion Tips") for tips on</span>
<span class="linecomment">;;    using Icicles to complete file names.  User options related to</span>
<span class="linecomment">;;    file-name and directory-name completion are presented there, not</span>
<span class="linecomment">;;    here.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Dealing With Large Candidate Sets")</span>
<span class="linecomment">;;    for tips on improving performance when dealing with a large</span>
<span class="linecomment">;;    number of completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Customizing Key Bindings") for information on customizing</span>
<span class="linecomment">;;    Icicles key bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Icicles with Delete Selection Mode")</span>
<span class="linecomment">;;  ** Using Icicles with Delete Selection Mode **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles works especially well with Delete Selection mode, which I</span>
<span class="linecomment">;;  use and recommend.  (Likewise, for PC selection mode, which uses</span>
<span class="linecomment">;;  Delete Selection mode.)  In Delete Selection mode, whenever the</span>
<span class="linecomment">;;  region (selection) is active (highlighted), you can simply type to</span>
<span class="linecomment">;;  replace text in the region, or hit `DEL' (Backspace) or `C-d'</span>
<span class="linecomment">;;  (Delete) to delete the region.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, library `delsel.el', which provides Delete Selection</span>
<span class="linecomment">;;  mode, binds keys in minibuffer maps that are also bound by</span>
<span class="linecomment">;;  Icicles.  For this reason, if you use both Icicles and Delete</span>
<span class="linecomment">;;  Selection mode, you must turn on Icicle mode after you turn on</span>
<span class="linecomment">;;  Delete Selection mode.  If you forget to do this, you will notice</span>
<span class="linecomment">;;  that `C-g' does not abort minibuffer input.  The remedy is simply</span>
<span class="linecomment">;;  to turn Icicle mode off, then on again.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicles User Options and Faces")</span>
<span class="linecomment">;;  ** Icicles User Options and Faces **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many user options (user variables) and several faces</span>
<span class="linecomment">;;  that Icicles defines, and you can also use various standard user</span>
<span class="linecomment">;;  options, including Icomplete options, that control various aspects</span>
<span class="linecomment">;;  of completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One thing that can be important to understand is that if you</span>
<span class="linecomment">;;  customize an option, and if the default value of that option</span>
<span class="linecomment">;;  changes later in a more recent Icicles version, then your</span>
<span class="linecomment">;;  customization will preclude your taking advantage of any new</span>
<span class="linecomment">;;  features represented by that default option value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is important particularly for complex options such as</span>
<span class="linecomment">;;  `icicle-top-level-key-bindings'.  Taking that option as an</span>
<span class="linecomment">;;  example, if Icicles later adds more commands with default key</span>
<span class="linecomment">;;  bindings then you will not see those bindings if you have a</span>
<span class="linecomment">;;  customized value of `icicle-top-level-key-bindings'.  There is</span>
<span class="linecomment">;;  nothing wrong with that; I just want you to be aware of it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In general, it can be a good idea to look at the latest change-log</span>
<span class="linecomment">;;  entry for `icicles-opt.el' in `icicles-chg.el', to see what</span>
<span class="linecomment">;;  changes have been made.  If you then want to take advantage of</span>
<span class="linecomment">;;  some change, you can use `M-x customize option' and visually</span>
<span class="linecomment">;;  compare your customized value with the new default value in</span>
<span class="linecomment">;;  `icicles-opt.el', then edit your customized value as you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-mode-hook' is a normal hook containing</span>
<span class="linecomment">;;    functions that are run after entering and exiting Icicle mode.</span>
<span class="linecomment">;;    This is `nil', by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-minibuffer-setup-hook' is a list of</span>
<span class="linecomment">;;    functions to be run at the end of minibuffer setup for Icicle</span>
<span class="linecomment">;;    mode.  This is `nil', by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-update-input-hook' is a list of functions to</span>
<span class="linecomment">;;    be run when minibuffer input is updated (typing or deleting).</span>
<span class="linecomment">;;    This is `nil', by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-no-match-hook' is a list of functions to be</span>
<span class="linecomment">;;    run during completion (`TAB' or `S-TAB') when there are no</span>
<span class="linecomment">;;    completion candidates that match the current input.  This is</span>
<span class="linecomment">;;    `nil', by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Case sensitivity: The following standard user options control</span>
<span class="linecomment">;;    whether completion distinguishes between uppercase and lowercase</span>
<span class="linecomment">;;    letters:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    * `completion-ignore-case'</span>
<span class="linecomment">;;    * `read-file-name-completion-ignore-case' (Emacs 22 and later)</span>
<span class="linecomment">;;    * `read-buffer-completion-ignore-case' (Emacs 23 and later)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    In addition, you can toggle case-sensitivity at any time using</span>
<span class="linecomment">;;    `C-A' (that is, `C-S-a') in the minibuffer.  This toggles</span>
<span class="linecomment">;;    `case-fold-search' and `completion-ignore-case'.  With a prefix</span>
<span class="linecomment">;;    argument, it also toggles</span>
<span class="linecomment">;;    `read-file-name-completion-ignore-case' and</span>
<span class="linecomment">;;    `read-buffer-completion-ignore-case'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    More precisely, it toggles the default value of</span>
<span class="linecomment">;;    `case-fold-search', and then it sets the other variables to the</span>
<span class="linecomment">;;    value of `case-fold-search'.  Because the default value of</span>
<span class="linecomment">;;    `case-fold-search' is changed, all buffers are affected.  Note</span>
<span class="linecomment">;;    that because some Icicles commands bind one or more of these</span>
<span class="linecomment">;;    variables, toggling case-sensitivity during command execution</span>
<span class="linecomment">;;    will not necessarily toggle their global values.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You can tell whether completion is currently case-sensitive by</span>
<span class="linecomment">;;    looking at the Icicle minor-mode lighter in the mode line, if</span>
<span class="linecomment">;;    `icicle-highlight-lighter-flag' is non-`nil'.  If</span>
<span class="linecomment">;;    case-sensitive, then the lighter text (with or without</span>
<span class="linecomment">;;    multi-command symbol `+') is `Icy'; if not, it is `ICY'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-region-background',</span>
<span class="linecomment">;;    `icicle-point-position-in-candidate',</span>
<span class="linecomment">;;    `icicle-mark-position-in-candidate', and</span>
<span class="linecomment">;;    `icicle-change-region-background-flag' are all used to define</span>
<span class="linecomment">;;    the region (the selected text) when cycling completion</span>
<span class="linecomment">;;    candidates.  They are described below individually.  The region</span>
<span class="linecomment">;;    is active when cycling, so you can easily delete it or replace</span>
<span class="linecomment">;;    it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-point-position-in-candidate' defines the</span>
<span class="linecomment">;;    minibuffer cursor position (point) while cycling candidate</span>
<span class="linecomment">;;    completions.  By default, the cursor is placed at the end of the</span>
<span class="linecomment">;;    root being completed.  You can instead place it at the root</span>
<span class="linecomment">;;    beginning or at the beginning or end of the complete minibuffer</span>
<span class="linecomment">;;    input.  For file-name input, the beginning of minibuffer input</span>
<span class="linecomment">;;    starts after the directory name (which is inserted</span>
<span class="linecomment">;;    automatically).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Similarly, user option `icicle-mark-position-in-candidate'</span>
<span class="linecomment">;;    defines the position of the mark; by default, it is at the end</span>
<span class="linecomment">;;    of the input.  Together, these two options control the size and</span>
<span class="linecomment">;;    placement of the region in a flexible way.  You can make the</span>
<span class="linecomment">;;    region include all of the input, only the root, from beginning</span>
<span class="linecomment">;;    to root, or from root to end.  You can put the cursor at either</span>
<span class="linecomment">;;    end of the region.  You can get rid of the region altogether, by</span>
<span class="linecomment">;;    making point and mark coincide (at any of the possible</span>
<span class="linecomment">;;    positions).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Because the region background color is often quite different</span>
<span class="linecomment">;;    from the frame background color (in order to have it stand out),</span>
<span class="linecomment">;;    it can be a bit hard to read the completion candidates when the</span>
<span class="linecomment">;;    region is highlighted during input cycling.  If user option</span>
<span class="linecomment">;;    `icicle-change-region-background-flag' is non-`nil', however,</span>
<span class="linecomment">;;    then the region background is changed to a color that differs</span>
<span class="linecomment">;;    only slightly from the frame background, making it easier to</span>
<span class="linecomment">;;    read the completion candidates.  The actual background color</span>
<span class="linecomment">;;    used is the value of `icicle-region-background', which you can</span>
<span class="linecomment">;;    customize.  If you make this color the same as the frame</span>
<span class="linecomment">;;    background, then the region background is, in effect, invisible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The default value of `icicle-change-region-background-flag' is</span>
<span class="linecomment">;;    determined by the current value of `delete-selection-mode', that</span>
<span class="linecomment">;;    is, whether or not Delete Selection mode is enabled, when</span>
<span class="linecomment">;;    Icicles is loaded.  For this reason, if you use Delete Selection</span>
<span class="linecomment">;;    mode and you want the region background to change in the</span>
<span class="linecomment">;;    minibuffer, you should either turn on Delete Selection mode</span>
<span class="linecomment">;;    before loading `icicles.el' or explicitly customize</span>
<span class="linecomment">;;    `icicle-change-region-background-flag' to non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-default-value' controls the treatment of a</span>
<span class="linecomment">;;    default value for minibuffer input.  This includes not only</span>
<span class="linecomment">;;    functions that read input with completion (`completing-read',</span>
<span class="linecomment">;;    `read-file-name'), but also other input-reading functions:</span>
<span class="linecomment">;;    `read-from-minibuffer' and `read-string'.  The default value of</span>
<span class="linecomment">;;    `t' gives the vanilla Emacs behavior: `completing-read' adds the</span>
<span class="linecomment">;;    default input value to the prompt as a hint (but</span>
<span class="linecomment">;;    `read-file-name' does not).  Non-`nil' and non-`t' means to</span>
<span class="linecomment">;;    automatically insert the default input value into the minibuffer</span>
<span class="linecomment">;;    as the initial value.  I prefer to have it inserted, as I often</span>
<span class="linecomment">;;    use the default value (perhaps editing it).  A value of `nil'</span>
<span class="linecomment">;;    neither inserts the default value nor adds it to the prompt.  If</span>
<span class="linecomment">;;    the value is `t' or `nil', remember that you can always insert</span>
<span class="linecomment">;;    the default value manually with `M-n'.  If the value is neither</span>
<span class="linecomment">;;    `t' nor `nil', you can always use `M-p' to remove the default</span>
<span class="linecomment">;;    value from the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    A non-`nil', non-`t' value of `icicle-default-value' controls</span>
<span class="linecomment">;;    also whether or not the initial value is preselected, and where</span>
<span class="linecomment">;;    to leave the cursor: at the beginning or end of the value.</span>
<span class="linecomment">;;    Preselecting the value can be useful in Delete Selection mode or</span>
<span class="linecomment">;;    PC Selection mode, because it makes it easy to replace that</span>
<span class="linecomment">;;    value by typing characters, or delete it by hitting `DEL'</span>
<span class="linecomment">;;    (Backspace) or `C-d' (Delete).  However, all of the initial</span>
<span class="linecomment">;;    input is lost if you type or hit `C-d' or `DEL', which is</span>
<span class="linecomment">;;    inconvenient if you want to edit it only slightly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-thing-at-point-functions' and</span>
<span class="linecomment">;;    `icicle-default-thing-insertion' control the behavior of `M-.'</span>
<span class="linecomment">;;    in the minibuffer, which grabs text from the current buffer and</span>
<span class="linecomment">;;    yanks it into the minibuffer.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Inserting Text Found Near the Cursor")</span>
<span class="linecomment">;;    and the doc string (`C-h v') of</span>
<span class="linecomment">;;    `icicle-thing-at-point-functions' for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-comint-dynamic-complete-replacements'</span>
<span class="linecomment">;;    specifies a list of function replacements for</span>
<span class="linecomment">;;    `icicle-comint-dynamic-complete' to replace the functions in</span>
<span class="linecomment">;;    `comint-dynamic-complete-functions'.  You can use this to</span>
<span class="linecomment">;;    provide Icicles completion for various modes that inherit from</span>
<span class="linecomment">;;    Comint mode.  By default, it treats Comint mode and Shell mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-input-string' is a regexp string that is</span>
<span class="linecomment">;;    inserted in the minibuffer when you use `C-='.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Inserting a Regexp from a Variable or Register").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In buffer `*Completions*', face `icicle-historical-candidate' is</span>
<span class="linecomment">;;    used to highlight completion candidates that you have used</span>
<span class="linecomment">;;    (entered with `RET') previously.  This highlighting is</span>
<span class="linecomment">;;    controlled by user option</span>
<span class="linecomment">;;    `icicle-highlight-historical-candidates-flag'.  You can toggle</span>
<span class="linecomment">;;    this option from the minibuffer at any time using `C-pause'.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In buffer `*Completions*', face `icicle-saved-candidate' is used</span>
<span class="linecomment">;;    to highlight completion candidates that you have saved (e.g.,</span>
<span class="linecomment">;;    using `C-M-&gt;').  This highlighting is controlled by user option</span>
<span class="linecomment">;;    `icicle-highlight-saved-candidates-flag'.  You can toggle this</span>
<span class="linecomment">;;    option from the minibuffer at any time using `S-pause'.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Saving and Retrieving Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * In buffer `*Completions*', face</span>
<span class="linecomment">;;    `icicle-current-candidate-highlight' highlights the current</span>
<span class="linecomment">;;    completion candidate, and, provided user option</span>
<span class="linecomment">;;    `icicle-expand-input-to-common-match-flag' is non-`nil', face</span>
<span class="linecomment">;;    `icicle-common-match-highlight-Completions' highlights the</span>
<span class="linecomment">;;    expanded common match among all completions.  Faces</span>
<span class="linecomment">;;    `icicle-match-highlight-Completions' and</span>
<span class="linecomment">;;    `icicle-match-highlight-minibuffer' highlight whatever your</span>
<span class="linecomment">;;    input matches, in buffer `*Completions*' and in the minibuffer,</span>
<span class="linecomment">;;    respectively.  In the minibuffer, face `icicle-complete-input'</span>
<span class="linecomment">;;    highlights your input when it is complete.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-touche-pas-aux-menus-flag' means</span>
<span class="linecomment">;;    that Icicles will not add menu items to menu-bar menus, except</span>
<span class="linecomment">;;    for the Icicles and Minibuf menus.  Default value `nil' means</span>
<span class="linecomment">;;    that whenever an appropriate menu-bar menu exists, Icicles items</span>
<span class="linecomment">;;    are added to it (when in Icicle mode).  For example, if `nil',</span>
<span class="linecomment">;;    then Delete File is added to the File menu; otherwise it is</span>
<span class="linecomment">;;    added to the Icicles menu.  The value of this option is used</span>
<span class="linecomment">;;    only when Icicle mode is initially established, so changing it</span>
<span class="linecomment">;;    has no effect after Icicles has been loaded.  However, you can</span>
<span class="linecomment">;;    change it and save the new value, so it will be used next time.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-functions-to-redefine' controls whether</span>
<span class="linecomment">;;    Icicles redefines some standard functions, enhancing them to use</span>
<span class="linecomment">;;    Icicles completion.  You can specify which functions to</span>
<span class="linecomment">;;    redefine.  The original function definitions are restored when</span>
<span class="linecomment">;;    you exit Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-inhibit-advice-functions' is a list of functions</span>
<span class="linecomment">;;    that Icicles redefines, and for which Icicle mode deactivates</span>
<span class="linecomment">;;    the advice.  The advice for each is reactivated when you leave</span>
<span class="linecomment">;;    Icicle mode.  Generally, it is a bad idea to use advice with</span>
<span class="linecomment">;;    functions that Icicles redefines, in particular minibuffer</span>
<span class="linecomment">;;    functions.  If you want to allow some such advice or prohibit</span>
<span class="linecomment">;;    advice for additional functions, then customize this list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: If you or a library you load advises one of these</span>
<span class="linecomment">;;    functions while you are in Icicle mode, then toggle Icicle mode</span>
<span class="linecomment">;;    twice, so that this option can have the proper effect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The following user options specify the keys to use for</span>
<span class="linecomment">;;    mode-specific completion-candidate cycling.  The default</span>
<span class="linecomment">;;    bindings are in parentheses.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-keys'                (`next')</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-keys'            (`prior')</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-keys'                 (`end')</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-keys'             (`home')</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-action-keys'         (`C-next')</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-action-keys'     (`C-prior')</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-action-keys'          (`C-end')</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-action-keys'      (`C-home')</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-alt-action-keys'     (`C-S-next')</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-alt-action-keys' (`C-S-prior')</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-alt-action-keys'      (`C-S-end')</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-alt-action-keys'  (`C-S-home')</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-help-keys'           (`C-M-next')</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-help-keys'       (`C-M-prior')</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-help-keys'            (`C-M-end')</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-help-keys'        (`C-M-home')</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The following user options specify the keys to use for cycling</span>
<span class="linecomment">;;    candidates according to the current completion mode.  The</span>
<span class="linecomment">;;    default bindings are in parentheses.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-keys'                  (`down')</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-keys'                    (`up')</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-action-keys'           (`C-down')</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-action-keys'             (`C-up')</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-alt-action-keys'       (`C-S-down')</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-alt-action-keys'         (`C-S-up')</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-help-keys'             (`C-M-down')</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-help-keys'               (`C-M-up')</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The completion mode, and hence the behavior of these keys, is</span>
<span class="linecomment">;;    changed only when you hit `TAB' or `S-TAB' during completion:</span>
<span class="linecomment">;;    the mode is prefix completion after `TAB' and apropos completion</span>
<span class="linecomment">;;    after `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: If your customizations of the modal and non-modal cycling</span>
<span class="linecomment">;;    keys conflict, the non-modal values win.  For example, if you</span>
<span class="linecomment">;;    define both `icicle-modal-cycle-up-keys' and</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-keys' as the list `([up])', then</span>
<span class="linecomment">;;    the `up' key will perform prefix cycling, not modal cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-default-cycling-mode' determines the</span>
<span class="linecomment">;;    completion mode to be used before you hit `TAB' or `S-TAB'.</span>
<span class="linecomment">;;    This affects only modal cycling - e.g. using keys such as `down'</span>
<span class="linecomment">;;    and `C-down'.  Values:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - `prefix' (default) means cycle prefix completions</span>
<span class="linecomment">;;    - `apropos' means cycle apropos completions</span>
<span class="linecomment">;;    - other non-`nil' value means cycle inputs from input history</span>
<span class="linecomment">;;    - `nil' means do not cycle: you must first hit a completion key</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For example, if the value is `apropos' then you can immediately</span>
<span class="linecomment">;;    cycle apropos completions without first hitting `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Once you have used `TAB' or `S-TAB', the only way to traverse</span>
<span class="linecomment">;;    the input history is to use `M-p' and `M-n'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-word-completion-keys' is a list of keys to</span>
<span class="linecomment">;;    use for word completion.  By default, the only such key is</span>
<span class="linecomment">;;    `M-SPC'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-apropos-complete-no-display-keys' is a list</span>
<span class="linecomment">;;    of keys to bind to `icicle-apropos-complete-no-display'.  By</span>
<span class="linecomment">;;    default, these keys are `C-M-S-tab' and `C-M-S-iso-lefttab',</span>
<span class="linecomment">;;    which together implement `C-M-S-TAB'.  Similarly,</span>
<span class="linecomment">;;    `icicle-prefix-complete-no-display-keys' is the list of keys for</span>
<span class="linecomment">;;    `icicle-prefix-complete-no-display'.  By default, the only such</span>
<span class="linecomment">;;    key is `C-M-tab'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-prefix-complete-keys' is the list of keys for</span>
<span class="linecomment">;;    `icicle-prefix-complete'.  By default, these keys are `tab' and</span>
<span class="linecomment">;;    `C-i', which together implement `TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-apropos-complete-keys' is the list of keys to</span>
<span class="linecomment">;;    bind to `icicle-apropos-complete'.  By default, these keys are</span>
<span class="linecomment">;;    `S-tab' and `S-iso-lefttab', which together implement `S-TAB'.</span>
<span class="linecomment">;;    (In Emacs 22 and later, `backtab' is the canonical key that</span>
<span class="linecomment">;;    represents both `S-tab' and `S-iso-lefttab', so that is used in</span>
<span class="linecomment">;;    the default value.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-key-complete-keys' is the list of keys to bind to</span>
<span class="linecomment">;;    `icicle-complete-keys'.  By default, these keys are `S-tab' and</span>
<span class="linecomment">;;    `S-iso-lefttab', which together implement `S-TAB'.  (In Emacs 22</span>
<span class="linecomment">;;    and later, `backtab' is the canonical key that represents both</span>
<span class="linecomment">;;    `S-tab' and `S-iso-lefttab', so that is used in the default</span>
<span class="linecomment">;;    value.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-previous-candidate-keys' is the list of keys to</span>
<span class="linecomment">;;    bind to `icicle-move-to-previous-completion', for moving among</span>
<span class="linecomment">;;    candidates in buffer `*Completions*'.  By default, these keys</span>
<span class="linecomment">;;    are `S-tab' and `S-iso-lefttab', which together implement</span>
<span class="linecomment">;;    `S-TAB'.  (In Emacs 22 and later, `backtab' is the canonical key</span>
<span class="linecomment">;;    that represents both `S-tab' and `S-iso-lefttab', so that is</span>
<span class="linecomment">;;    used in the default value.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-isearch-complete-keys' is the list of keys for</span>
<span class="linecomment">;;    `icicle-isearch-complete'.  By default, these keys are `M-TAB',</span>
<span class="linecomment">;;    `ESC TAB', `C-M-TAB', and `M-o'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-read+insert-file-name-keys' is the list of keys</span>
<span class="linecomment">;;    for invoking file-name completion on demand.  By default,</span>
<span class="linecomment">;;    `C-M-S-f' is the only such key.  Option</span>
<span class="linecomment">;;    `icicle-completing-read+insert-keys' is the list of keys for</span>
<span class="linecomment">;;    invoking non file-name completion on demand.  By default,</span>
<span class="linecomment">;;    `C-M-S-c' is the only such key.  See (@&gt; "Completion On Demand").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-act-before-cycle-flag' `nil' means that keys</span>
<span class="linecomment">;;    such as `C-next', which combine candidate action and cycling,</span>
<span class="linecomment">;;    cycle to the next (or previous) candidate and act on it.</span>
<span class="linecomment">;;    Non-`nil' means they act on the current candidate and then cycle</span>
<span class="linecomment">;;    to the next (or previous) candidate.  When the value is `nil',</span>
<span class="linecomment">;;    you can think of `C-next' as an operation on the next candidate.</span>
<span class="linecomment">;;    When the value is non-`nil', you can think of `C-next' as an</span>
<span class="linecomment">;;    operation on the current candidate, which ends by making the</span>
<span class="linecomment">;;    next candidate current.  Similarly for the other cycling keys</span>
<span class="linecomment">;;    that act, alternative-act, or show help on a candidate.  The</span>
<span class="linecomment">;;    default value is `nil'.  See also option</span>
<span class="linecomment">;;    `icicle-use-C-for-actions-flag', which changes the keys affected</span>
<span class="linecomment">;;    by `icicle-act-before-cycle-flag'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If option `icicle-use-C-for-actions-flag' is `nil', then the</span>
<span class="linecomment">;;    keys that cycle candidates are swapped with the keys that both</span>
<span class="linecomment">;;    cycle and act on a candidate.  You can then use `down', `up',</span>
<span class="linecomment">;;    `next', `prior', `end' and `home' to both cycle and act, and</span>
<span class="linecomment">;;    `C-down', `C-up', `C-next', `C-prior', `C-end', and `C-home' to</span>
<span class="linecomment">;;    merely cycle, without acting (e.g. navigating).  The option has</span>
<span class="linecomment">;;    no effect on other keys.  You can toggle this option at any time</span>
<span class="linecomment">;;    using `M-g' (`icicle-toggle-C-for-actions') in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (The keys mentioned here are the default bindings.  The actual</span>
<span class="linecomment">;;    keys swapped are those defined by these user options:</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-action-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-action-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-action-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-action-keys',</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-action-keys',</span>
<span class="linecomment">;;    `icicle-modal-cycle-up-action-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-next-keys',</span>
<span class="linecomment">;;    `icicle-prefix-cycle-previous-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-next-keys',</span>
<span class="linecomment">;;    `icicle-apropos-cycle-previous-keys',</span>
<span class="linecomment">;;    `icicle-modal-cycle-down-keys', `icicle-modal-cycle-up-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option</span>
<span class="linecomment">;;    `icicle-top-level-when-sole-completion-flag' means that whenever</span>
<span class="linecomment">;;    there is only one completion candidate that matches your input,</span>
<span class="linecomment">;;    that candidate is used immediately, without requiring you to hit</span>
<span class="linecomment">;;    `RET' or `S-RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * When `icicle-top-level-when-sole-completion-flag' is `nil',</span>
<span class="linecomment">;;    option `icicle-top-level-when-sole-completion-delay' is the</span>
<span class="linecomment">;;    number of seconds Icicles waits, before returning to top level</span>
<span class="linecomment">;;    with the sole completion.  (It has no effect if the flag is</span>
<span class="linecomment">;;    `nil'.)  The delay gives you a chance to forestall acceptance of</span>
<span class="linecomment">;;    the sole completion: editing the completion (typing or deleting</span>
<span class="linecomment">;;    a character) before the delay expires prevents its automatic</span>
<span class="linecomment">;;    acceptance.  The default value is 0 seconds (no delay).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-TAB-shows-candidates-flag' means</span>
<span class="linecomment">;;    that hitting `TAB' for prefix completion immediately shows the</span>
<span class="linecomment">;;    completion candidates in buffer `*Completions*'.  If `nil', then</span>
<span class="linecomment">;;    candidates are shown only after `TAB' is hit a second time,</span>
<span class="linecomment">;;    which is the standard Emacs behavior.  The default value is `t'.</span>
<span class="linecomment">;;    (Actually, the concerned keys are those defined by option</span>
<span class="linecomment">;;    `icicle-prefix-complete-keys', not necessarily `TAB'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-max-candidates' means truncate the list</span>
<span class="linecomment">;;    of completion candidates to at most this many.  If you use</span>
<span class="linecomment">;;    library `doremi.el' then you can use `C-x #' during completion</span>
<span class="linecomment">;;    to increment or decrement the option value using the vertical</span>
<span class="linecomment">;;    arrow keys or the mouse wheel.  A numeric prefix argument for</span>
<span class="linecomment">;;    `C-x #' sets the increment size.  A plain prefix argument</span>
<span class="linecomment">;;    (`C-u') resets `icicle-max-candidates' to `nil', meaning no</span>
<span class="linecomment">;;    truncation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-expand-input-to-common-match-flag'</span>
<span class="linecomment">;;    means that completion commands `TAB' and `S-TAB' expand your</span>
<span class="linecomment">;;    minibuffer input to (typically) the longest substring common to</span>
<span class="linecomment">;;    all completion candidates and that matches your (complete) input</span>
<span class="linecomment">;;    pattern.  This replaces the input you typed.  If you want to</span>
<span class="linecomment">;;    edit your original, raw input, use `C-l'.  If your input has</span>
<span class="linecomment">;;    been expanded, then hit `C-l' twice: once to replace a</span>
<span class="linecomment">;;    completion candidate (from, say, `next') with the common match</span>
<span class="linecomment">;;    string, and a second time to replace the common match string</span>
<span class="linecomment">;;    with your original input.  The main reason you might want to set</span>
<span class="linecomment">;;    this to `nil' is for apropos completion, if you want to always</span>
<span class="linecomment">;;    work with a regexp in the minibuffer.  You can toggle this</span>
<span class="linecomment">;;    option at any time using `C-;' in the minibuffer.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Expanded-Common-Match Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option</span>
<span class="linecomment">;;    `icicle-hide-common-match-in-Completions-flag' hides the common</span>
<span class="linecomment">;;    match for your current input from each candidate in</span>
<span class="linecomment">;;    `*Completions*'.  You can toggle this at any time during</span>
<span class="linecomment">;;    completion using `C-x .' (`icicle-toggle-hiding-common-match').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-show-Completions-initially-flag' controls</span>
<span class="linecomment">;;    whether or not buffer `*Completions*' is shown initially,</span>
<span class="linecomment">;;    without your needing to hit `TAB' or `S-TAB' to show it.</span>
<span class="linecomment">;;    However, if you type something before</span>
<span class="linecomment">;;    `icicle-incremental-completion-delay', then display is</span>
<span class="linecomment">;;    inhibited.  The default value is `nil', meaning that</span>
<span class="linecomment">;;    `*Completions*' is not shown until you hit `TAB' or `S-TAB'.</span>
<span class="linecomment">;;    More typical than setting this option to non-`nil' globally is</span>
<span class="linecomment">;;    to bind it to non-`nil' in Emacs-Lisp code, to display</span>
<span class="linecomment">;;    `*Completions*' as a menu.  For example, pass a non-`nil'</span>
<span class="linecomment">;;    binding to `icicle-define-command' to create a command that</span>
<span class="linecomment">;;    displays a multiple-choice menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For an alternative but similar behavior to using non-`nil' for</span>
<span class="linecomment">;;    `icicle-show-Completions-initially-flag', you can set option</span>
<span class="linecomment">;;    `icicle-incremental-completion-flag' to a value that is neither</span>
<span class="linecomment">;;    `nil' nor `t'.  That displays `*Completions*' as soon as you</span>
<span class="linecomment">;;    type or delete input, but not initially.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-incremental-completion-flag' controls</span>
<span class="linecomment">;;    whether or not `*Completions*' is updated incrementally</span>
<span class="linecomment">;;    (icompletion) as you type.  You can toggle incremental</span>
<span class="linecomment">;;    completion at any time using `C-#'.  For more information, see</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-incremental-completion-delay' and</span>
<span class="linecomment">;;    `icicle-incremental-completion-threshold' together cause a delay</span>
<span class="linecomment">;;    before incremental completion takes effect.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-Completions-display-min-input-chars' is the</span>
<span class="linecomment">;;    minimum number of input characters that allow buffer</span>
<span class="linecomment">;;    `*Completions*' to remain displayed.  By default, this is zero</span>
<span class="linecomment">;;    (0), meaning that any number of input characters, even none,</span>
<span class="linecomment">;;    allows `*Completions*' to remain displayed.  If you use</span>
<span class="linecomment">;;    incremental completion (see `icicle-incremental-completion-*'),</span>
<span class="linecomment">;;    and you are bothered by `*Completions*' being automatically</span>
<span class="linecomment">;;    updated when, for instance, you empty the minibuffer, then you</span>
<span class="linecomment">;;    might want to set this option to, say, 1 or 2.  With a value of</span>
<span class="linecomment">;;    2, for instance, whenever the minibuffer input has less than 2</span>
<span class="linecomment">;;    characters, incremental completion will remove the</span>
<span class="linecomment">;;    `*Completions*' window.  You can also remove the `*Completions*'</span>
<span class="linecomment">;;    window at any time using `C-x 0' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-show-Completions-help-flag' means</span>
<span class="linecomment">;;    display help (instructions) at the top of the `*Completions*'</span>
<span class="linecomment">;;    window.  These instructions are shown in faces</span>
<span class="linecomment">;;    `icicle-Completions-instruction-1' and</span>
<span class="linecomment">;;    `icicle-Completions-instruction-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-help-in-mode-line-delay' is the number of seconds</span>
<span class="linecomment">;;    to display help on individual completion candidates in the</span>
<span class="linecomment">;;    mode-line as you cycle or your input is completed.  The</span>
<span class="linecomment">;;    mode-line that is used is that of buffer `*Completions*', if it</span>
<span class="linecomment">;;    is displayed, or the current buffer, otherwise.  Typically, this</span>
<span class="linecomment">;;    mode-line candidate help is the first line of a doc string, but</span>
<span class="linecomment">;;    alternative help is available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Regardless of the option value, a user event (e.g. a key press)</span>
<span class="linecomment">;;    always interrupts (terminates) this help display.  Note too that</span>
<span class="linecomment">;;    `post-command-hook' actions do not take place until this display</span>
<span class="linecomment">;;    is finished.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Face `icicle-mode-line-help' is used to highlight Icicles help</span>
<span class="linecomment">;;    shown in the mode-line.  This includes that controlled by option</span>
<span class="linecomment">;;    `icicle-help-in-mode-line-delay' and the indication in</span>
<span class="linecomment">;;    `*Completions*' of the total number of matching candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-Completions-mouse-3-menu-entries' defines</span>
<span class="linecomment">;;    the contextual menu that is popped up when you click `C-mouse-3'</span>
<span class="linecomment">;;    on a candidate in `*Completions*'.  As an aid to customizing it,</span>
<span class="linecomment">;;    refer to any of the constants `icicle-Completions-*' that define</span>
<span class="linecomment">;;    its submenus.  The submenu definitions are easier to understand</span>
<span class="linecomment">;;    in the source code (`icicles-opt.el'), because Customize does</span>
<span class="linecomment">;;    not pretty-print them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-Completions-frame-at-right-flag' controls</span>
<span class="linecomment">;;    whether `icicle-candidate-action' moves the frame showing buffer</span>
<span class="linecomment">;;    `*Completions*' to the right, out of the way of other frames.</span>
<span class="linecomment">;;    This can be useful if you use one-buffer-per-frame (non-`nil'</span>
<span class="linecomment">;;    `pop-up-frames').  In that case, I recommend that you also try</span>
<span class="linecomment">;;    my library `oneonone.el'.</span>
<span class="linecomment">;;    See (@&gt; "Note on Non-`nil' `pop-up-frames' on MS Windows") for</span>
<span class="linecomment">;;    more advice about non-`nil' `pop-up-frames'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-Completions-window-max-height' is the</span>
<span class="linecomment">;;    maximum height of the `*Completions*' window, in lines.  The</span>
<span class="linecomment">;;    window is fit to the buffer size, with this as maximum height.</span>
<span class="linecomment">;;    This is not used if `*Completions*' is a special display buffer</span>
<span class="linecomment">;;    with its own frame, and it is not used in Emacs releases prior</span>
<span class="linecomment">;;    to 21.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Starting with Emacs 23, you can use option</span>
<span class="linecomment">;;    `icicle-Completions-text-scale-decrease' to change the size of</span>
<span class="linecomment">;;    the text used in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-candidate-width-factor' controls how many</span>
<span class="linecomment">;;    columns of completion candidates are displayed in</span>
<span class="linecomment">;;    `*Completions*'.  The widest current candidate is scaled by this</span>
<span class="linecomment">;;    percentage, and the window width is divided by that figure.</span>
<span class="linecomment">;;    Other things are taken into account also, but this gives you a</span>
<span class="linecomment">;;    way to tweak the number of columns: the larger this number, the</span>
<span class="linecomment">;;    fewer the columns.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If you use Do Re Mi (library `doremi.el'), then you can modify</span>
<span class="linecomment">;;    `icicle-candidate-width-factor' incrementally during completion,</span>
<span class="linecomment">;;    seeing the effect as it changes.  Use `C-x w' from the</span>
<span class="linecomment">;;    minibuffer, then use the `right' and `left' arrow keys or the</span>
<span class="linecomment">;;    mouse wheel to increment and decrement the value.  You can at</span>
<span class="linecomment">;;    the same time use the `up' and `down' keys to adjust the value</span>
<span class="linecomment">;;    of `icicle-inter-candidates-min-spaces'.  WYSIWYG.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-inter-candidates-min-spaces' is the minimum</span>
<span class="linecomment">;;    number of spaces between candidates displayed in</span>
<span class="linecomment">;;    `*Completions*'.  The default value is one space.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If you use Do Re Mi (library `doremi.el'), then you can modify</span>
<span class="linecomment">;;    `icicle-inter-candidates-min-spaces' incrementally during</span>
<span class="linecomment">;;    completion, seeing the effect as it changes.  Use `C-x |' from</span>
<span class="linecomment">;;    the minibuffer, then use the `up' and `down' arrow keys or the</span>
<span class="linecomment">;;    mouse wheel to increment and decrement the value.  You can at</span>
<span class="linecomment">;;    the same time use the `left' and `right' keys to adjust the</span>
<span class="linecomment">;;    value of `icicle-candidate-width-factor'.  WYSIWYG.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-image-files-in-Completions' means that</span>
<span class="linecomment">;;    thumbnail images are shown in `*Completions*' for candidates</span>
<span class="linecomment">;;    that are names of image files.  The default value is `t'.  If</span>
<span class="linecomment">;;    the value is `image-only', then only the thumbnail images are</span>
<span class="linecomment">;;    shown.  If it is otherwise non-`nil' then the file names are</span>
<span class="linecomment">;;    also shown.  You can cycle the option value using `C-x t' in the</span>
<span class="linecomment">;;    minibuffer at any time during completion.  This feature is</span>
<span class="linecomment">;;    available starting with Emacs 22.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-completions-format' controls whether candidates</span>
<span class="linecomment">;;    displayed in `*Completions*' are laid out horizontally (the</span>
<span class="linecomment">;;    default) or vertically.  Set the value to `vertical' for the</span>
<span class="linecomment">;;    latter.  Starting with Emacs 23.2, you can just use the vanilla</span>
<span class="linecomment">;;    option `completions-format' for this, if you want the same type</span>
<span class="linecomment">;;    of layout with Icicle mode turned on or off.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Multi-completions often involve complex, multi-line text for</span>
<span class="linecomment">;;    which a vertical `*Completions*' layout is not appropriate.  For</span>
<span class="linecomment">;;    this reason, when multi-line multi-completions are used the</span>
<span class="linecomment">;;    layout is horizontal, temporarily overriding any `vertical'</span>
<span class="linecomment">;;    value for `icicle-completions-format' or `completions-format'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If you need to override this override behavior for some command,</span>
<span class="linecomment">;;    use `icicle-minibuffer-setup-hook' and `minibuffer-exit-hook' to</span>
<span class="linecomment">;;    temporarily set and reset the internal variable</span>
<span class="linecomment">;;    `icicle-completions-format-internal'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If option `icicle-menu-items-to-history-flag' is non-`nil' (the</span>
<span class="linecomment">;;    default), then commands that you invoke using the menu-bar menu</span>
<span class="linecomment">;;    are included in the command history for `M-x'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-populate-interactive-history-flag'</span>
<span class="linecomment">;;    means that any interactive use of a command causes it to be</span>
<span class="linecomment">;;    added to the history `icicle-interactive-history'.  You can</span>
<span class="linecomment">;;    access this history by using `C-M-pause' during completion.  Be</span>
<span class="linecomment">;;    aware that addition of all interactive invocations to this</span>
<span class="linecomment">;;    history can slow Emacs down.  (This option is only available</span>
<span class="linecomment">;;    starting with Emacs 23.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-sort-comparer' controls the order of</span>
<span class="linecomment">;;    completion candidates during cycling and in buffer</span>
<span class="linecomment">;;    `*Completions*'.  If `nil', then no sorting is done.  If</span>
<span class="linecomment">;;    non-`nil', then the value must be a string-comparison function -</span>
<span class="linecomment">;;    the function is passed to the standard function `sort' to do the</span>
<span class="linecomment">;;    sorting.  The default value for `icicle-sort-comparer' is</span>
<span class="linecomment">;;    `icicle-case-string-less-p', which sorts alphabetically,</span>
<span class="linecomment">;;    possibly ignoring letter case.  During completion, you can</span>
<span class="linecomment">;;    toggle sorting using `C-,'.  If you are an Emacs-Lisp programmer</span>
<span class="linecomment">;;    and you write new commands using Icicles functionalities, you</span>
<span class="linecomment">;;    can bind `icicle-sort-comparer' temporarily to any sort function</span>
<span class="linecomment">;;    you need.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-alternative-sort-comparer' is an alternative</span>
<span class="linecomment">;;    to `icicle-sort-comparer, providing a different sort order.  By</span>
<span class="linecomment">;;    default, it is `icicle-historical-alphabetic-p', a function that</span>
<span class="linecomment">;;    sorts previously used completion candidates before candidates</span>
<span class="linecomment">;;    that have not yet been used, and sorts alphabetically within</span>
<span class="linecomment">;;    each of these groups of candidates.  In other words, it places</span>
<span class="linecomment">;;    inputs that you have used previously at the top of buffer</span>
<span class="linecomment">;;    `*Completions*' and makes them available for completion first.</span>
<span class="linecomment">;;    During completion, you can toggle normal and alternative sorting</span>
<span class="linecomment">;;    using `C-M-,'.  See (@&gt; "Sorting Candidates") and</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-change-sort-order-completion-flag' specifies</span>
<span class="linecomment">;;    whether `C-,' cycles among available sort orders or lets you</span>
<span class="linecomment">;;    choose a sort order using Icicles completion.  Non-`nil' means</span>
<span class="linecomment">;;    to use completion; `nil' (the default value) means to cycle.</span>
<span class="linecomment">;;    You can override the current setting at any time by using `C-u</span>
<span class="linecomment">;;    C-,'.  See (@&gt; "Sorting Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-sort-orders-alist' is an alist of possible</span>
<span class="linecomment">;;    sort orders for user to choose from using `C-,' or `M-,'.</span>
<span class="linecomment">;;    See (@&gt; "Sorting Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The value of user option `icicle-transform-function' is a</span>
<span class="linecomment">;;    function that is applied to the list of completion candidates,</span>
<span class="linecomment">;;    to transform them before they are presented to the user.  If</span>
<span class="linecomment">;;    `nil', then no transformation is done.  The default</span>
<span class="linecomment">;;    transformation is to remove duplicate candidates, when</span>
<span class="linecomment">;;    transformation is active, but the default value of this option</span>
<span class="linecomment">;;    is `nil'.  You can toggle transformation at any time using</span>
<span class="linecomment">;;    command `icicle-toggle-transforming', bound to `C-$' in the</span>
<span class="linecomment">;;    minibuffer.  Although this is a user option, you probably do</span>
<span class="linecomment">;;    *NOT* want to change its value by customizing it.  Icicles</span>
<span class="linecomment">;;    commands already "do the right thing" when it comes to candidate</span>
<span class="linecomment">;;    transformation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The value of this option can be changed by program locally, for</span>
<span class="linecomment">;;    use in particular contexts.  For example, when you use</span>
<span class="linecomment">;;    `icicle-search-generic' (`C-c `') in a *shell* buffer, Icicles</span>
<span class="linecomment">;;    uses this variable with a value of `icicle-remove-duplicates',</span>
<span class="linecomment">;;    to remove duplicate shell commands from your input history list.</span>
<span class="linecomment">;;    Lisp programmers can use this variable to transform the list of</span>
<span class="linecomment">;;    candidates in any way they like.  A typical use is to remove</span>
<span class="linecomment">;;    duplicates, by binding it to `icicle-remove-duplicates' or</span>
<span class="linecomment">;;    `icicle-remove-dups-if-extras'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-require-match-flag',</span>
<span class="linecomment">;;    `icicle-buffer-require-match-flag', and</span>
<span class="linecomment">;;    `icicle-file-require-match-flag' let you override the value of</span>
<span class="linecomment">;;    the REQUIRE-MATCH argument provided to `completing-read' or</span>
<span class="linecomment">;;    `read-file-name'.  They are provided mainly for use (binding) in</span>
<span class="linecomment">;;    `icicle-define-command' and `icicle-define-file-command', but</span>
<span class="linecomment">;;    you may also use them globally, if you wish.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Exiting the Minibuffer Without Confirmation").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    A typical use is made in the definition of command</span>
<span class="linecomment">;;    `icicle-buffer': `icicle-buffer-require-match-flag' is used to</span>
<span class="linecomment">;;    bind `icicle-require-match-flag', so that you can, for example,</span>
<span class="linecomment">;;    match only existing buffers and be able to match on partial</span>
<span class="linecomment">;;    input without explicitly completing (hitting `TAB' or `S-TAB').</span>
<span class="linecomment">;;    Simply set the option to `partial-match-ok' to get this</span>
<span class="linecomment">;;    behavior.  To apropos-complete and exit the minibuffer, use</span>
<span class="linecomment">;;    `S-RET' instead of `RET'.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Exiting the Minibuffer Without Confirmation"),</span>
<span class="linecomment">;;    for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-ignore-space-prefix-flag' means to</span>
<span class="linecomment">;;    ignore completion candidates that start with a space.  However,</span>
<span class="linecomment">;;    such candidates are not ignored for prefix completion if the</span>
<span class="linecomment">;;    input also starts with a space.  Naturally, apropos completion</span>
<span class="linecomment">;;    is not affected by whether or not the input starts with a space.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Option `icicle-buffer-ignore-space-prefix-flag' lets you</span>
<span class="linecomment">;;    override the value of `icicle-ignore-space-prefix-flag' for use</span>
<span class="linecomment">;;    with buffer-name completion (the names of internal buffers start</span>
<span class="linecomment">;;    with a space).  It is provided mainly for binding when using</span>
<span class="linecomment">;;    `icicle-define-command' (`icicle-buffer' does this).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    You can toggle `icicle-ignore-space-prefix-flag' at any time</span>
<span class="linecomment">;;    using `M-_' in the minibuffer.  If the current command binds</span>
<span class="linecomment">;;    this option locally, then it is the local, not the global, value</span>
<span class="linecomment">;;    that is changed.  For example, if</span>
<span class="linecomment">;;    `icicle-buffer-ignore-space-prefix-flag' is non-`nil', then</span>
<span class="linecomment">;;    `M-_' toggles `icicle-ignore-space-prefix-flag' to `nil' only</span>
<span class="linecomment">;;    for the duration of the buffer command (e.g. `icicle-buffer').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-test-for-remote-files-flag' means</span>
<span class="linecomment">;;    that Icicles tests for remote file names; `nil' means that it</span>
<span class="linecomment">;;    does not.  You can toggle this using `C-^' in the minibuffer</span>
<span class="linecomment">;;    (except during Icicles search).  Turning off remote file-name</span>
<span class="linecomment">;;    testing means that you cannot use remote files with Tramp; it</span>
<span class="linecomment">;;    disables Tramp's remote file-name handling and completion.  This</span>
<span class="linecomment">;;    can, for local files, slightly speed up incremental completion</span>
<span class="linecomment">;;    and the highlighting of the part of your current input that does</span>
<span class="linecomment">;;    not complete (see `icicle-highlight-input-completion-failure').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-regexp-quote-flag' reduces apropos</span>
<span class="linecomment">;;    completion to simple substring completion and Icicles regexp</span>
<span class="linecomment">;;    search to literal search.  Regexp special characters are no</span>
<span class="linecomment">;;    longer recognized as special; they simply match themselves.  You</span>
<span class="linecomment">;;    probably do not want to customize this option.  Instead, you can</span>
<span class="linecomment">;;    toggle it at any time using `C-`' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-command-abbrev-match-all-parts-flag',</span>
<span class="linecomment">;;    `icicle-command-abbrev-priority-flag', and</span>
<span class="linecomment">;;    `icicle-command-abbrev-alist' control the behavior of</span>
<span class="linecomment">;;    multi-command `icicle-command-abbrev' (`C-x SPC').  The first</span>
<span class="linecomment">;;    determines whether an abbreviation must match all parts of a</span>
<span class="linecomment">;;    command name.  The second controls whether command names or</span>
<span class="linecomment">;;    abbreviations take precedence in case of conflict.  The third is</span>
<span class="linecomment">;;    the persistent list of your command abbreviations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-S-TAB-completion-methods-alist' and</span>
<span class="linecomment">;;    `icicle-TAB-completion-methods' control which completion method</span>
<span class="linecomment">;;    is used by `S-TAB' and `TAB', respectively, to complete your</span>
<span class="linecomment">;;    input.  By default, the first method in each list is used for</span>
<span class="linecomment">;;    matching.  You can use `M-(' and `C-(' (commands</span>
<span class="linecomment">;;    `icicle-next-S-TAB-completion-method' and</span>
<span class="linecomment">;;    `icicle-next-TAB-completion-method') in the minibuffer to cycle</span>
<span class="linecomment">;;    among the `S-TAB' and `TAB' methods.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For fuzzy completion (choice `fuzzy' when cycling with `C-('),</span>
<span class="linecomment">;;    `TAB' completes non-filename input using fuzzy prefix matching</span>
<span class="linecomment">;;    as defined in library `fuzzy-match.el'.  See the Commentary in</span>
<span class="linecomment">;;    `fuzzy-match.el' for details about fuzzy matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Fuzzy completion is not available for file-name completion; it</span>
<span class="linecomment">;;    is always case-sensitive; leading spaces are taken into account;</span>
<span class="linecomment">;;    and completion candidates are always sorted by decreasing fuzzy</span>
<span class="linecomment">;;    match strength.  In other words, fuzzy completion is not</span>
<span class="linecomment">;;    affected by `C-A', `M-_', or `C-,'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-S-TAB-completion-methods-per-command' and</span>
<span class="linecomment">;;    `icicle-TAB-completion-methods-per-command' provide per-command</span>
<span class="linecomment">;;    control of the completion methods available when you cycle using</span>
<span class="linecomment">;;    `C-(' and `M-('.  Use them if you want to specify which methods</span>
<span class="linecomment">;;    are available for particular commands that read input with</span>
<span class="linecomment">;;    completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-levenshtein-distance' is the Levenshtein</span>
<span class="linecomment">;;    distance allowed for strings to be considered as matching during</span>
<span class="linecomment">;;    N-off completion.  This means that two strings match if they</span>
<span class="linecomment">;;    differ by at most this many character operations (insertion,</span>
<span class="linecomment">;;    deletion, replacement).  This option is used only if you have</span>
<span class="linecomment">;;    library `levenshtein.el'.  See (@&gt; "Fuzzy Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Top-level command `icicle-search' uses several faces to</span>
<span class="linecomment">;;    highlight found text that matches your input.  Faces</span>
<span class="linecomment">;;    `icicle-search-main-regexp-current' and</span>
<span class="linecomment">;;    `icicle-search-main-regexp-others' highlight what your</span>
<span class="linecomment">;;    search-context regexp (entered with `RET') matches.  The former</span>
<span class="linecomment">;;    highlights the current search context; the latter highlights all</span>
<span class="linecomment">;;    other search contexts.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Face `icicle-search-current-input' highlights what your current</span>
<span class="linecomment">;;    input (typically another regexp) matches; that is, it highlights</span>
<span class="linecomment">;;    a match within a search context.  Faces</span>
<span class="linecomment">;;    `icicle-search-context-level-1' through</span>
<span class="linecomment">;;    `icicle-search-context-level-8' highlight the first eight regexp</span>
<span class="linecomment">;;    subgroup matches, within a search context.  This highlighting is</span>
<span class="linecomment">;;    done whenever `icicle-search-highlight-context-levels-flag' is</span>
<span class="linecomment">;;    non-`nil' and the search context corresponds to the entire</span>
<span class="linecomment">;;    regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-highlight-context-levels-flag'</span>
<span class="linecomment">;;    controls highlighting of regexp subgroup matches within the</span>
<span class="linecomment">;;    search context.  Non-`nil' (the default value) means highlight</span>
<span class="linecomment">;;    them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-highlight-threshold' controls</span>
<span class="linecomment">;;    highlighting with face `icicle-search-main-regexp-others': this</span>
<span class="linecomment">;;    many matches, maximum, are highlighted.  If zero, then only the</span>
<span class="linecomment">;;    current match is highlighted.  The effect is similar to the</span>
<span class="linecomment">;;    Emacs 22+ lazy search highlighting of Isearch (except that the</span>
<span class="linecomment">;;    highlighting is not in fact lazy).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;    means highlight the current input match in all main search hits</span>
<span class="linecomment">;;    at the same time.  If `icicle-expand-input-to-common-match-flag'</span>
<span class="linecomment">;;    is also non-`nil', then what is highlighted for each input match</span>
<span class="linecomment">;;    is the expanded common match among all input matches throughout</span>
<span class="linecomment">;;    the search area.  If either is `nil', then only the exact input</span>
<span class="linecomment">;;    match is highlighted.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The default value of `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;    is `nil', because non-`nil' can impact performance negatively if</span>
<span class="linecomment">;;    there are many search contexts - the highlighting is updated</span>
<span class="linecomment">;;    with each input change.  You can toggle the value at any time</span>
<span class="linecomment">;;    using command `icicle-toggle-highlight-all-current', bound to</span>
<span class="linecomment">;;    `C-^' in the minibuffer (except during file-name completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If, in addition to `icicle-search-highlight-all-current-flag'</span>
<span class="linecomment">;;    and `icicle-expand-input-to-common-match-flag', option</span>
<span class="linecomment">;;    `icicle-search-replace-common-match-flag' is also non-`nil',</span>
<span class="linecomment">;;    then a search replacement replaces the expanded common match;</span>
<span class="linecomment">;;    otherwise, it replaces only the exact match.  You can toggle the</span>
<span class="linecomment">;;    value at any time using `M-;' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-search-cleanup-flag' means that</span>
<span class="linecomment">;;    `icicle-search' highlighting is removed after the search.  This</span>
<span class="linecomment">;;    is the default behavior.  If you set this to `nil' then you can</span>
<span class="linecomment">;;    remove search highlighting manually later using command</span>
<span class="linecomment">;;    `icicle-search-highlight-cleanup'.  You can toggle this search</span>
<span class="linecomment">;;    highlight removal at any time using command</span>
<span class="linecomment">;;    `icicle-toggle-search-cleanup', bound to `C-.' in the minibuffer</span>
<span class="linecomment">;;    (except during file-name completion).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    One use of `nil' `icicle-search-cleanup-flag' is to highlight</span>
<span class="linecomment">;;    regexp matches throughout a region or buffer (or multiple files</span>
<span class="linecomment">;;    or...).  In that capacity, Icicles search functions act like</span>
<span class="linecomment">;;    some of the highlighting commands in my library `highlight.el'.</span>
<span class="linecomment">;;    Note that when `icicle-search-cleanup-flag' is `nil', *all*</span>
<span class="linecomment">;;    Icicles search highlighting remains: last-visited search</span>
<span class="linecomment">;;    context, other context matches, current-input matches, and even</span>
<span class="linecomment">;;    regexp subgroups.  The faces for these are, respectively:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     - `icicle-search-main-regexp-current'</span>
<span class="linecomment">;;     - `icicle-search-main-regexp-others'</span>
<span class="linecomment">;;     - `icicle-search-highlight-input-matches-here' (everywhere, if</span>
<span class="linecomment">;;       `icicle-search-highlight-all-current-flag' is non-`nil')</span>
<span class="linecomment">;;     - `icicle-search-context-level-1' through</span>
<span class="linecomment">;;       `icicle-search-context-level-8'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-search-whole-word-flag' means that</span>
<span class="linecomment">;;    whole-word search is done.  All characters in your search string</span>
<span class="linecomment">;;    are searched for literally, and matches for the string must</span>
<span class="linecomment">;;    begin and end on a word boundary.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If user option `icicle-search-replace-whole-candidate-flag' is</span>
<span class="linecomment">;;    `nil', then whatever matches your current input is replaced,</span>
<span class="linecomment">;;    within the current search context, when you perform replacement</span>
<span class="linecomment">;;    during Icicles searching (e.g. `C-S-RET').  If the value is</span>
<span class="linecomment">;;    non-`nil' (the default value), then the entire search context is</span>
<span class="linecomment">;;    replaced, instead.  You can use `M-_' at any time during</span>
<span class="linecomment">;;    searching and replacing, to toggle the value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-replace-literally-flag' determines</span>
<span class="linecomment">;;    whether Icicles search-and-replace replaces text literally or</span>
<span class="linecomment">;;    interprets `\' specially in the replacement text, as in</span>
<span class="linecomment">;;    `query-replace-regexp'.  Non-`nil' means to treat replacement</span>
<span class="linecomment">;;    text literally.  The default value is `nil'.  You can use</span>
<span class="linecomment">;;    `C-M-`' to toggle this at any time during Icicles search.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-ignore-comments-flag' means that</span>
<span class="linecomment">;;    `icicle-search-thing' and related commands</span>
<span class="linecomment">;;    (e.g. `icicle-search-xml-element') ignore comments.  That is,</span>
<span class="linecomment">;;    they hide comments temporarily while they scan the region or</span>
<span class="linecomment">;;    buffer for things of the given type to serve as search contexts</span>
<span class="linecomment">;;    (completion candidates).  This prevents them, for example, from</span>
<span class="linecomment">;;    presenting as a candidate a sexp or a list that is commented</span>
<span class="linecomment">;;    out.  You can toggle this option anytime using `C-M-;' in the</span>
<span class="linecomment">;;    minibuffer, but to see the effect you might need to invoke the</span>
<span class="linecomment">;;    current command again.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-search-hook' is a list of functions to be</span>
<span class="linecomment">;;    run after searching and moving to an `icicle-search' match,</span>
<span class="linecomment">;;    whether you move there by `RET', `C-RET', `C-next', or</span>
<span class="linecomment">;;    `C-prior'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-recenter' is passed as argument to</span>
<span class="linecomment">;;    `recenter' whenever the current navigation destination would be</span>
<span class="linecomment">;;    off-screen, to make it visible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-bookmark-name-length-max' is the maximum</span>
<span class="linecomment">;;    number of characters to use when `icicle-bookmark-cmd' (`C-x r</span>
<span class="linecomment">;;    m') with a non-negative numeric prefix argument automatically</span>
<span class="linecomment">;;    names a bookmark.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-bookmark-refresh-cache-flag' determines</span>
<span class="linecomment">;;    whether commands such as `icicle-bookmark' and</span>
<span class="linecomment">;;    `icicle-search-bookmark' refresh the bookmark-list cache.  The</span>
<span class="linecomment">;;    default value of `t', meaning refresh, ensures that the set of</span>
<span class="linecomment">;;    bookmark candidates is always up-to-date, but you can improve</span>
<span class="linecomment">;;    performance for a large bookmark list if you customize it to</span>
<span class="linecomment">;;    `nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    In any case, a plain prefix argument (`C-u') for these commands</span>
<span class="linecomment">;;    overrides the default setting of the option for the duration of</span>
<span class="linecomment">;;    the command.  Thus if the customized value is `nil', you can use</span>
<span class="linecomment">;;    `C-u' occasionally to refresh the list on demand.  In addition,</span>
<span class="linecomment">;;    the cache is refreshed whenever you use `S-delete' to delete a</span>
<span class="linecomment">;;    candidate bookmark.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-show-multi-completion-flag' means</span>
<span class="linecomment">;;    that for some commands additional information is shown along</span>
<span class="linecomment">;;    with each completion candidate.  That is, a multi-completion is</span>
<span class="linecomment">;;    used.  You can match against any parts of the multi-completion.</span>
<span class="linecomment">;;    The default value is `t'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For example, for command `icicle-search', the name of the buffer</span>
<span class="linecomment">;;    associated with each completion candidate is added to the</span>
<span class="linecomment">;;    candidate and highlighted.  You can match against the buffer</span>
<span class="linecomment">;;    name, as well as the search hit within the buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note that even when the value of this option is `nil', you can</span>
<span class="linecomment">;;    often see the multi-completion information in the mode-line when</span>
<span class="linecomment">;;    you cycle candidates, and you can typically see it in the help</span>
<span class="linecomment">;;    that is displayed by `C-M-mouse-2' and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-buffer-match-regexp',</span>
<span class="linecomment">;;    `icicle-buffer-no-match-regexp', `icicle-buffer-predicate', and</span>
<span class="linecomment">;;    `icicle-buffer-extras' determine the behavior of Icicles buffer</span>
<span class="linecomment">;;    commands, such as `icicle-buffer' and `insert-buffer'.  They</span>
<span class="linecomment">;;    determine the set of buffer-name candidates available for</span>
<span class="linecomment">;;    completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The first three restrict this set to names that satisfy the</span>
<span class="linecomment">;;    properties they specify.  Option `icicle-buffer-extras' lets you</span>
<span class="linecomment">;;    add additional buffer names to the set of candidates, after</span>
<span class="linecomment">;;    restriction by the other options.  Extra buffer-name candidates</span>
<span class="linecomment">;;    are displayed in buffer `*Completions*' using face</span>
<span class="linecomment">;;    `icicle-extra-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note that if an extra candidate is already a candidate anyway</span>
<span class="linecomment">;;    then it will be present twice in the list of all candidates</span>
<span class="linecomment">;;    (that is, unless `icicle-transform-function' removes duplicate</span>
<span class="linecomment">;;    candidates).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note that `icicle-buffer-predicate' is applied after matching</span>
<span class="linecomment">;;    against user input.  It thus corresponds to</span>
<span class="linecomment">;;    `icicle-must-pass-after-match-predicate', not to</span>
<span class="linecomment">;;    `icicle-must-pass-predicate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Options `icicle-file-match-regexp',</span>
<span class="linecomment">;;    `icicle-file-no-match-regexp', `icicle-file-predicate', and</span>
<span class="linecomment">;;    `icicle-file-extras' act similarly for file-name completion.</span>
<span class="linecomment">;;    You could use `icicle-file-no-match-regexp' or</span>
<span class="linecomment">;;    `icicle-file-predicate', for instance, to exclude files that are</span>
<span class="linecomment">;;    in or under the directories in `vc-directory-exclusion-list':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (defun my-locate-non-vc-file ()</span>
<span class="linecomment">;;      "`icicle-locate-file', but excluding stuff in VC directories."</span>
<span class="linecomment">;;      (interactive)</span>
<span class="linecomment">;;      (let ((icicle-file-predicate  'not-excluded-vc-file-p))</span>
<span class="linecomment">;;        (icicle-locate-file)))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (defun not-excluded-vc-file-p (file)</span>
<span class="linecomment">;;      "nil if FILE is in a `vc-directory-exclusion-list' directory."</span>
<span class="linecomment">;;      (or (not (boundp 'vc-directory-exclusion-list))</span>
<span class="linecomment">;;          (not (consp vc-directory-exclusion-list))</span>
<span class="linecomment">;;          (not (let ((case-fold-search  completion-ignore-case))</span>
<span class="linecomment">;;                 (catch 'nevfp</span>
<span class="linecomment">;;                   (dolist (dir  vc-directory-exclusion-list)</span>
<span class="linecomment">;;                     (when (string-match</span>
<span class="linecomment">;;                            (concat ".*" dir "\\(/.*\\)?")</span>
<span class="linecomment">;;                            file)</span>
<span class="linecomment">;;                       (throw 'nevfp t)))</span>
<span class="linecomment">;;                   nil)))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-ignored-directories' is a list of directories</span>
<span class="linecomment">;;    that are ignored by commands `icicle-locate-file' and</span>
<span class="linecomment">;;    `icicle-locate-file-no-symlinks'.  By default, this is the value</span>
<span class="linecomment">;;    of `vc-directory-exclusion-list'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-buffer-sort' is a predicate used to sort</span>
<span class="linecomment">;;    buffer-name candidates in Icicles buffer commands such as</span>
<span class="linecomment">;;    `icicle-buffer' and `icicle-insert-buffer'.  Option</span>
<span class="linecomment">;;    `icicle-file-sort' acts similarly for file-name completion.  The</span>
<span class="linecomment">;;    default value of `icicle-buffer-sort' is</span>
<span class="linecomment">;;    `icicle-buffer-sort-*...*-last', which sorts names of buffers</span>
<span class="linecomment">;;    that begin with `*' after other buffer names.  These options</span>
<span class="linecomment">;;    affect only the initial sort order used for buffer and file</span>
<span class="linecomment">;;    names, respectively, that is, the order used first in an Emacs</span>
<span class="linecomment">;;    session.  The values are also put first in the list of possible</span>
<span class="linecomment">;;    sort orders for cycling.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-buffer-configs' is a list of named</span>
<span class="linecomment">;;    configurations of options `icicle-buffer-match-regexp',</span>
<span class="linecomment">;;    `icicle-buffer-no-match-regexp', `icicle-buffer-predicate',</span>
<span class="linecomment">;;    `icicle-buffer-extras', and `icicle-buffer-sort'.  You use</span>
<span class="linecomment">;;    command `icicle-buffer-config' to choose one of the</span>
<span class="linecomment">;;    configurations to be current.  You can use commands</span>
<span class="linecomment">;;    `icicle-add-buffer-config' and `icicle-remove-buffer-config' to</span>
<span class="linecomment">;;    add and remove configurations from the list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Example: A configuration such as the following, named "Files and</span>
<span class="linecomment">;;    Scratch", defines `icicle-buffer-predicate' to display only file</span>
<span class="linecomment">;;    buffers, and it defines `icicle-buffer-extras' to include the</span>
<span class="linecomment">;;    extra buffer `*scratch*':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     ("Files and Scratch" nil nil</span>
<span class="linecomment">;;      (lambda (bufname) (buffer-file-name (get-buffer bufname)))</span>
<span class="linecomment">;;      ("*scratch*") icicle-sort-comparer)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The idea of buffer-option configurations was borrowed from</span>
<span class="linecomment">;;    library `bs.el', by Olaf Sylvester &lt;olaf@geekware.de&gt;.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-dot-string' is the regexp string inserted by</span>
<span class="linecomment">;;    `icicle-insert-dot-command' (bound to `.' in the minibuffer</span>
<span class="linecomment">;;    during completion).  You can set it to a regexp that matches any</span>
<span class="linecomment">;;    character, including newline.  The default value instead matches</span>
<span class="linecomment">;;    any character except newline.  You can toggle between these two</span>
<span class="linecomment">;;    behaviors using command `icicle-toggle-dot', bound to `C-M-.'</span>
<span class="linecomment">;;    during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-dot-show-regexp-flag' means show the</span>
<span class="linecomment">;;    underlying regexp (value of constant `icicle-anychar-regexp')</span>
<span class="linecomment">;;    explicitly for a multi-line dot (`.').  A `nil' value works only</span>
<span class="linecomment">;;    for Emacs versions 21 and later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-list-join-string',</span>
<span class="linecomment">;;    `icicle-list-end-string', and</span>
<span class="linecomment">;;    `icicle-list-nth-parts-join-string' are described in sections</span>
<span class="linecomment">;;    (@&gt; "Multi-Completions") and</span>
<span class="linecomment">;;    (@&gt; "Programming Multi-Completions").  Option</span>
<span class="linecomment">;;    `icicle-list-join-string' is the separator string that joins</span>
<span class="linecomment">;;    together the parts of a multi-completion.  The end string is</span>
<span class="linecomment">;;    appended to each multi-completion candidate.  Option</span>
<span class="linecomment">;;    `icicle-list-nth-parts-join-string' specifies how the</span>
<span class="linecomment">;;    multi-completion extracted parts are joined back together when a</span>
<span class="linecomment">;;    user chooses a multi-completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The default value of `icicle-list-join-string' is `^G^J'.  With</span>
<span class="linecomment">;;    Emacs 22 and later, the `^G' part is hidden when it appears in</span>
<span class="linecomment">;;    `*Completions*', and you can hide it in the minibuffer also by</span>
<span class="linecomment">;;    using `C-M-j' instead of typing `C-q C-g C-j'.  See the doc</span>
<span class="linecomment">;;    string for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Face `icicle-candidate-part' highlights one or more parts of a</span>
<span class="linecomment">;;    candidate, in buffer `*Completions*'.  The candidate is</span>
<span class="linecomment">;;    typically a multi-completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Face `icicle-special-candidate' highlights candidates, in</span>
<span class="linecomment">;;    `*Completions*', that are considered "special".  Generally,</span>
<span class="linecomment">;;    these are candidates that match user option</span>
<span class="linecomment">;;    `icicle-special-candidate-regexp'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Similarly, face `icicle-proxy-candidate' highlights proxy</span>
<span class="linecomment">;;    candidates.  These are placeholders for real candidates.</span>
<span class="linecomment">;;    Non-`nil' user option `icicle-add-proxy-candidates-flag' means</span>
<span class="linecomment">;;    include proxy candidates whenever there are any.  You can toggle</span>
<span class="linecomment">;;    this option during completion using command</span>
<span class="linecomment">;;    `icicle-toggle-proxy-candidates', which is bound to `C-M-_' in</span>
<span class="linecomment">;;    the minibuffer.  For performance reasons, you will in some cases</span>
<span class="linecomment">;;    need to re-invoke the command to make the proxy candidates</span>
<span class="linecomment">;;    available.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Face `icicle-extra-candidate' highlights extra candidates, that</span>
<span class="linecomment">;;    is, members of `icicle-extra-candidates', `icicle-buffer-extras',</span>
<span class="linecomment">;;    or `icicle-file-extras'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-kmacro-ring-max' acts as `kmacro-ring-max'</span>
<span class="linecomment">;;    when you are in Icicle mode.  (When you exit Icicle mode,</span>
<span class="linecomment">;;    `kmacro-ring-max' is restored.)  In Icicles, you will typically</span>
<span class="linecomment">;;    want to use a much larger number than the default value in</span>
<span class="linecomment">;;    vanilla Emacs.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-regexp-search-ring-max' and</span>
<span class="linecomment">;;    `icicle-search-ring-max' act as `regexp-search-ring-max' and</span>
<span class="linecomment">;;    `search-ring-max', respectively, when you are in Icicle mode.</span>
<span class="linecomment">;;    (When you exit Icicle mode, `regexp-search-ring-max' and</span>
<span class="linecomment">;;    `search-ring-max' are restored.)  The reason for having these</span>
<span class="linecomment">;;    options is that with Icicles you will likely want to use a much</span>
<span class="linecomment">;;    longer search history.  By default, these are as large as</span>
<span class="linecomment">;;    possible (virtually unlimited).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Suggestion: If you use library `savehist.el' (recommended),</span>
<span class="linecomment">;;    customize `savehist-additional-variables' to include variables</span>
<span class="linecomment">;;    `search-ring' and `regexp-search-ring', so that your search</span>
<span class="linecomment">;;    histories will be saved between Emacs sessions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: You can clear (empty) a given search history with command</span>
<span class="linecomment">;;    `clear-option' (aka `icicle-reset-option-to-nil').  For example,</span>
<span class="linecomment">;;    to clear the regular-expression search history, do this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      `C-u M-x clear-option RET regexp-search-ring RET'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    (The `C-u' is needed because this variable is not a user</span>
<span class="linecomment">;;    option.)  If you use my library `misc-cmds.el', you can clear</span>
<span class="linecomment">;;    search histories easier, using commands `clear-search-history',</span>
<span class="linecomment">;;    `clear-regexp-search-history', and `clear-search-histories'.</span>
<span class="linecomment">;;    See (@file :file-name "icicles-doc1.el" :to "Isearch Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-completion-history-max-length' limits the</span>
<span class="linecomment">;;    number of completion inputs to save.  If you customize user</span>
<span class="linecomment">;;    option `icicle-C-l-uses-completion-flag' to non-`nil', then,</span>
<span class="linecomment">;;    instead of cycling, `C-l' lets you use Icicles completion to</span>
<span class="linecomment">;;    retrieve a past completion input.  (`C-L' does the same thing.)</span>
<span class="linecomment">;;    If you use library `savehist.el', then you can save the history</span>
<span class="linecomment">;;    of completion inputs persistently by customizing user option</span>
<span class="linecomment">;;    `savehist-additional-variables' to include the Icicles internal</span>
<span class="linecomment">;;    variables `icicle-previous-raw-file-name-inputs' and</span>
<span class="linecomment">;;    `icicle-previous-raw-non-file-name-inputs'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Faces `icicle-completion', `icicle-multi-command-completion',</span>
<span class="linecomment">;;    and `icicle-mustmatch-completion' indicate the status of</span>
<span class="linecomment">;;    minibuffer completion.  During completion, Icicles uses them for</span>
<span class="linecomment">;;    a minibuffer indicator and, if user option</span>
<span class="linecomment">;;    `icicle-highlight-lighter-flag' is non-`nil', for the `Icy'</span>
<span class="linecomment">;;    mode-line lighter as well.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option</span>
<span class="linecomment">;;    `icicle-highlight-input-initial-whitespace-flag' uses face</span>
<span class="linecomment">;;    `icicle-whitespace-highlight' to highlight any whitespace that</span>
<span class="linecomment">;;    starts your minibuffer input.  This is done to help you</span>
<span class="linecomment">;;    recognize accidentally typing such whitespace.  Otherwise, you</span>
<span class="linecomment">;;    might not understand the set of matching completion candidates</span>
<span class="linecomment">;;    (or lack thereof).  There is not necessarily anything wrong with</span>
<span class="linecomment">;;    input that starts with whitespace - it might be what you want,</span>
<span class="linecomment">;;    but without this highlighting it is easy to not notice the</span>
<span class="linecomment">;;    whitespace.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The part of your current input that does not complete can be</span>
<span class="linecomment">;;    highlighted automatically, and you can then remove that part</span>
<span class="linecomment">;;    using `C-M-l'.  This highlighting is controlled by options</span>
<span class="linecomment">;;    `icicle-incremental-completion-flag',</span>
<span class="linecomment">;;    `icicle-test-for-remote-files-flag',</span>
<span class="linecomment">;;    `icicle-highlight-input-completion-failure',</span>
<span class="linecomment">;;    `icicle-highlight-input-completion-failure-delay', and</span>
<span class="linecomment">;;    `icicle-highlight-input-completion-failure-threshold'.  The</span>
<span class="linecomment">;;    highlighting uses face `icicle-input-completion-fail' (for</span>
<span class="linecomment">;;    strict completion) or `icicle-input-completion-fail-lax' (for</span>
<span class="linecomment">;;    lax completion).  For details, see the option doc strings and</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Icicles Highlights the Input that Won't Complete").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-top-level-key-bindings' specifies top-level</span>
<span class="linecomment">;;    commands and their bindings for Icicle mode.  By default, this</span>
<span class="linecomment">;;    rebinds several standard Emacs keys (in Icicle mode only).  For</span>
<span class="linecomment">;;    example, it substitutes `icicle-kill-buffer' for `kill-buffer'</span>
<span class="linecomment">;;    (binding it to whatever `kill-buffer' is bound to globally).</span>
<span class="linecomment">;;    Top-level commands are commands that are not used only in the</span>
<span class="linecomment">;;    minibuffer.  To change these bindings, customize</span>
<span class="linecomment">;;    `icicle-top-level-key-bindings'.  If you do that, then you must</span>
<span class="linecomment">;;    exit and re-enter Icicle mode to ensure that the change takes</span>
<span class="linecomment">;;    effect.  This is really necessary only if your changes would</span>
<span class="linecomment">;;    undefine a key.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-define-alias-commands-flag' defines a</span>
<span class="linecomment">;;    few top-level Icicles commands whose names do not begin with</span>
<span class="linecomment">;;    `icicle-', for convenience when using `M-x'.  For example,</span>
<span class="linecomment">;;    command `toggle' is defined as an alias for command</span>
<span class="linecomment">;;    `icicle-toggle-option'.  In any case, no such command is ever</span>
<span class="linecomment">;;    defined by Icicles if a function with the same name is already</span>
<span class="linecomment">;;    defined.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-color-themes' is a list of color themes to</span>
<span class="linecomment">;;    cycle through when you use command `icicle-color-theme'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-saved-completion-sets' is a persistent list</span>
<span class="linecomment">;;    of named sets of completion candidates.  You can switch among</span>
<span class="linecomment">;;    such sets at any time.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Persistent Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-filesets-as-saved-completion-sets-flag'</span>
<span class="linecomment">;;    non-`nil' means you can use Emacs filesets to save completion</span>
<span class="linecomment">;;    candidates persistently.  This means that you can save file-name</span>
<span class="linecomment">;;    candidates in a persistent Icicles saved completion set (cache</span>
<span class="linecomment">;;    file) or in in an Emacs fileset.  It also means that an Icicles</span>
<span class="linecomment">;;    persistent completion set can contain filesets, in addition to</span>
<span class="linecomment">;;    file names: any number of filesets, and filesets of different</span>
<span class="linecomment">;;    type.  Available only for Emacs 22 and later, and you must load</span>
<span class="linecomment">;;    library `filesets.el' (and enable filesets using</span>
<span class="linecomment">;;    `(filesets-init)').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-key-descriptions-use-&lt;&gt;-flag' determines</span>
<span class="linecomment">;;    whether angle brackets (`&lt;', `&gt;') are used by Icicles for named</span>
<span class="linecomment">;;    keys, such as function keys (`&lt;f9&gt;' vs `f9') and pseudo keys</span>
<span class="linecomment">;;    (`&lt;mode-line&gt;' vs `mode-line').  Non-`nil' means to use angle</span>
<span class="linecomment">;;    brackets.  This option does not affect Emacs key descriptions</span>
<span class="linecomment">;;    outside of Icicles (e.g. `C-h k' or `C-h w'), and it has no</span>
<span class="linecomment">;;    effect for versions of Emacs prior to 21, because they never use</span>
<span class="linecomment">;;    angle brackets.  The default value is `nil', because I think</span>
<span class="linecomment">;;    angle brackets reduce readability.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-keymaps-for-key-completion' is a list of</span>
<span class="linecomment">;;    variables that are bound to keymaps in which you want to bind</span>
<span class="linecomment">;;    `S-TAB' (actually, each of the keys in the value of option</span>
<span class="linecomment">;;    `icicle-key-complete-keys') to `icicle-complete-keys'.  Each</span>
<span class="linecomment">;;    such keymap should have at least one prefix key.  `S-TAB' is</span>
<span class="linecomment">;;    bound in each keymap, so that you can use it to complete the</span>
<span class="linecomment">;;    prefix keys.  See also `icicle-complete-key-anyway-flag'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-complete-key-anyway-flag' means bind</span>
<span class="linecomment">;;    `S-TAB' (actually, each of the keys in the value of option</span>
<span class="linecomment">;;    `icicle-key-complete-keys') to `icicle-complete-keys' in each</span>
<span class="linecomment">;;    keymap of option `icicle-keymaps-for-key-completion', regardless</span>
<span class="linecomment">;;    of whether `S-TAB' already has a binding in that keymap.  A</span>
<span class="linecomment">;;    value of `nil' means bind `S-TAB' only if there is not already a</span>
<span class="linecomment">;;    binding.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-complete-keys-self-insert-flag' means</span>
<span class="linecomment">;;    that `icicle-complete-keys' includes self-inserting keys as</span>
<span class="linecomment">;;    completion candidates.  You will probably want to leave this</span>
<span class="linecomment">;;    `nil' and use command `icicle-insert-char', not</span>
<span class="linecomment">;;    `icicle-complete-keys', to insert special characters.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-yank-function' is a function to use to yank</span>
<span class="linecomment">;;    text.  By default, it is `yank'.  Command</span>
<span class="linecomment">;;    `icicle-yank-maybe-completing' calls this function, except when</span>
<span class="linecomment">;;    it is called from the minibuffer or called with a negative</span>
<span class="linecomment">;;    prefix argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-use-candidates-only-once-flag'</span>
<span class="linecomment">;;    means that acting on a candidate removes it from the set of</span>
<span class="linecomment">;;    available candidates, so that you do not see that it can be used</span>
<span class="linecomment">;;    again.  (`TAB' or `S-TAB' makes it available again.)  The</span>
<span class="linecomment">;;    default value is `nil', and you probably do not want to</span>
<span class="linecomment">;;    customize this.  However, if you write Emacs-Lisp code that uses</span>
<span class="linecomment">;;    completion, then you can bind this to non-`nil' in contexts</span>
<span class="linecomment">;;    where that makes sense.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-deletion-action-flag' means</span>
<span class="linecomment">;;    `S-delete' during completion deletes the current object.  More</span>
<span class="linecomment">;;    precisely, it deletes the object named by the current completion</span>
<span class="linecomment">;;    candidate, if a deletion action is defined for the current</span>
<span class="linecomment">;;    command.  If no deletion action is defined, then the value of</span>
<span class="linecomment">;;    this option has no effect for that command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-alternative-actions-alist' is an alist that</span>
<span class="linecomment">;;    associates Emacs commands and alternative action functions.  It</span>
<span class="linecomment">;;    overrides any alternative actions defined otherwise for the</span>
<span class="linecomment">;;    commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-type-actions-alist' is an alist that</span>
<span class="linecomment">;;    associates Emacs object types, such as buffer, file, and</span>
<span class="linecomment">;;    process, with functions that accept an object of the given type</span>
<span class="linecomment">;;    as their only required object.  This is used by some Emacs</span>
<span class="linecomment">;;    commands during completion to prompt for a function to apply to</span>
<span class="linecomment">;;    the current completion candidate.  Each function can be a symbol</span>
<span class="linecomment">;;    or a lambda expression.  At runtime, symbols that are not</span>
<span class="linecomment">;;    functions (`functionp') are ignored.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-type-actions-alist' is an alist of Emacs</span>
<span class="linecomment">;;    object types and associated actions (functions).  Each function</span>
<span class="linecomment">;;    must accept an object of the specified type as its only required</span>
<span class="linecomment">;;    argument.  A function here can be a symbol or a lambda</span>
<span class="linecomment">;;    expression.  Any symbols that do not have function definitions</span>
<span class="linecomment">;;    when this option is used are filtered out (not used).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-use-anything-candidates-flag'</span>
<span class="linecomment">;;    means Anything actions are used for candidate alternate actions</span>
<span class="linecomment">;;    in some Icicles commands, and Anything types and actions are</span>
<span class="linecomment">;;    used by command `icicle-object-action' (aka `what-which-how' and</span>
<span class="linecomment">;;    `a').  The default value is `t'.  This option has no effect if</span>
<span class="linecomment">;;    library `anything.el' cannot be loaded.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option</span>
<span class="linecomment">;;    `icicle-anything-transform-candidates-flag' means that Anything</span>
<span class="linecomment">;;    function `anything-transform-candidates' is applied to displayed</span>
<span class="linecomment">;;    Anything candidates in Icicles.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The advantage of a `nil' value is that command `icicle-anything'</span>
<span class="linecomment">;;    then acts as a multi-command: you can act on multiple</span>
<span class="linecomment">;;    candidates, or apply multiple actions for the same candidate,</span>
<span class="linecomment">;;    within a single invocation of `icicle-anything' (or related</span>
<span class="linecomment">;;    commands).  The advantage of a non-`nil' value is that some of</span>
<span class="linecomment">;;    the displayed Anything candidates might be more readable.  The</span>
<span class="linecomment">;;    default value is `nil'.  This option has no effect if library</span>
<span class="linecomment">;;    `anything.el' cannot be loaded.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-WYSIWYG-Completions-flag' controls how face</span>
<span class="linecomment">;;    and color names are displayed as candidates in `*Completions*'.</span>
<span class="linecomment">;;    If value is non-`nil', then a WYSIWYG (what you see is what you</span>
<span class="linecomment">;;    get) sample of the face or color is shown.  If the value is a</span>
<span class="linecomment">;;    string, then a face name is accompanied by a separate face</span>
<span class="linecomment">;;    swatch with that string text.  If the value is `t', then the</span>
<span class="linecomment">;;    face name itself is shown using the face it names.  You can use</span>
<span class="linecomment">;;    command `icicle-toggle-WYSIWYG-Completions' to toggle this</span>
<span class="linecomment">;;    option.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option</span>
<span class="linecomment">;;    `icicle-unpropertize-completion-result-flag' means that</span>
<span class="linecomment">;;    `completing-read' and (starting with Emacs 23) `read-file-name'</span>
<span class="linecomment">;;    will strip all text properties from the result they return.</span>
<span class="linecomment">;;    Regardless of the option value, Icicles strips text properties</span>
<span class="linecomment">;;    that it adds for its internal use.  See the doc string of</span>
<span class="linecomment">;;    function `icicle-unpropertize' for more information about this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    The default value of the option is `nil'.  It is not likely that</span>
<span class="linecomment">;;    you will need to change this, but you might if you use some</span>
<span class="linecomment">;;    other library that cannot accept a propertized string as the</span>
<span class="linecomment">;;    result of completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Note: This is the case if you use GNUS - it has a known bug in</span>
<span class="linecomment">;;    this regard (reported 2008-06-21).  It blindly prints the</span>
<span class="linecomment">;;    Emacs-Lisp string that is the result of completion into an MML</span>
<span class="linecomment">;;    attribute value: filename=#("~/.gnus/attach.el" 0 25 (face</span>
<span class="linecomment">;;    nil)).  GNUS should ensure that whatever it uses for an</span>
<span class="linecomment">;;    attribute value is valid for MML (has normal "..." string</span>
<span class="linecomment">;;    syntax, with acceptable characters).  But it simply calls a Lisp</span>
<span class="linecomment">;;    print function, which prints #("...").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User options `icicle-pp-eval-expression-print-length' and</span>
<span class="linecomment">;;    `icicle-pp-eval-expression-print-level' control the Lisp sexp</span>
<span class="linecomment">;;    print length and print level, respectively, for values printed</span>
<span class="linecomment">;;    by `M-:' (`icicle-pp-eval-expression').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-guess-commands-in-path' means that all</span>
<span class="linecomment">;;    executable files (or all files, if option</span>
<span class="linecomment">;;    `shell-completion-execonly' is `nil') in your search path are</span>
<span class="linecomment">;;    included among the completion candidates whenever a shell</span>
<span class="linecomment">;;    command is read.  The particular non-`nil' value determines when</span>
<span class="linecomment">;;    this list of commands is updated from your current search path.</span>
<span class="linecomment">;;    The default value is `nil'.</span>
<span class="linecomment">;;    See (@&gt; "Icicles Shell-Command Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' option `icicle-quote-shell-file-name-flag' means that</span>
<span class="linecomment">;;    `icicle-read-shell-command-completing' double-quotes the file</span>
<span class="linecomment">;;    name at the beginning of the shell command it reads.  This</span>
<span class="linecomment">;;    affects several Emacs commands, such as `M-!' that read a shell</span>
<span class="linecomment">;;    command and its arguments.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If this is `nil', then such commands will not quote a</span>
<span class="linecomment">;;    shell-command file name such as</span>
<span class="linecomment">;;    `c:/Program Files/My Dir/mycmd.exe'.  In that case, a shell such</span>
<span class="linecomment">;;    as `bash' fails for a shell command such as</span>
<span class="linecomment">;;    `c:/Program Files/My Dir/mycmd.exe arg1 arg2 &', because it</span>
<span class="linecomment">;;    interprets only `c:/Program' as the shell command.  That is, it</span>
<span class="linecomment">;;    interprets the space (`SPC') characters in the file name as</span>
<span class="linecomment">;;    separators.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If this is non-`nil' (the default value), then input such as</span>
<span class="linecomment">;;    `c:/Program Files/My Dir/mycmd.exe arg1 arg2 &' is passed to the</span>
<span class="linecomment">;;    shell as `"c:/Program Files/My Dir/mycmd.exe" arg1 arg2 &'</span>
<span class="linecomment">;;    (notice the double-quotes).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    See the doc string of `icicle-quote-file-name-part-of-cmd' for</span>
<span class="linecomment">;;    information about the characters that, like `SPC', lead to</span>
<span class="linecomment">;;    file-name quoting.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-inhibit-ding-flag' means Icicles</span>
<span class="linecomment">;;    never uses an audible bell (ding).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Option `icicle-option-type-prefix-arg-list' is a list of symbols</span>
<span class="linecomment">;;    that control prefix arguments for command</span>
<span class="linecomment">;;    `icicle-describe-option-of-type (bound to `C-h C-o' by</span>
<span class="linecomment">;;    default). A list of six symbols taken from this list:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `direct'            `inherit'            `inherit-or-value'</span>
<span class="linecomment">;;    `direct-or-value'   `inherit-or-regexp'  `direct-or-regexp'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Choose the order you like. The list members map, in order from</span>
<span class="linecomment">;;    left to right, to these prefix argument keys:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      1. `C-u C-u'</span>
<span class="linecomment">;;      2. `C-0'</span>
<span class="linecomment">;;      3. `C-u'</span>
<span class="linecomment">;;      4. `C-9' (positive)</span>
<span class="linecomment">;;      5. no prefix arg</span>
<span class="linecomment">;;      6. `C--' (negative)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    For the meanings of the symbols, see the doc string of</span>
<span class="linecomment">;;    `icicle-describe-option-of-type', which describes the default</span>
<span class="linecomment">;;    prefix-argument bindings for the command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option `icicle-customize-save-flag' means that</span>
<span class="linecomment">;;    Icicles will save the updated value of option</span>
<span class="linecomment">;;    `icicle-command-abbrev-alist' when you quit Emacs.  This is the</span>
<span class="linecomment">;;    normal behavior.  If you for some reason do not want your</span>
<span class="linecomment">;;    `custom-file' or init file updated in this way, then customize</span>
<span class="linecomment">;;    `icicle-customize-save-flag' to `nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-buffers-ido-like-flag' is `t' then `icicle-buffer'</span>
<span class="linecomment">;;    and similar commands act more Ido-like.  Specifically, those</span>
<span class="linecomment">;;    commands then bind these options to `t':</span>
<span class="linecomment">;;    `icicle-show-Completions-initially-flag',</span>
<span class="linecomment">;;    `icicle-top-level-when-sole-completion-flag', and</span>
<span class="linecomment">;;    `icicle-default-value'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If `icicle-files-ido-like-flag' is `t' then `icicle-file' and</span>
<span class="linecomment">;;    similar commands act more Ido-like.  Specifically, those</span>
<span class="linecomment">;;    commands then bind these options to `t':</span>
<span class="linecomment">;;    `icicle-show-Completions-initially-flag',</span>
<span class="linecomment">;;    `icicle-top-level-when-sole-completion-flag', and</span>
<span class="linecomment">;;    `icicle-default-value'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The value of option `icicle-customize-save-variable-function' is</span>
<span class="linecomment">;;    the function Icicles uses to automatically save user option</span>
<span class="linecomment">;;    changes made by some commands.  I recommend that you do *NOT*</span>
<span class="linecomment">;;    change this option value.  This is provided only for users who</span>
<span class="linecomment">;;    might want to disable such automatic saving of option changes,</span>
<span class="linecomment">;;    by setting this to `ignore', or users who might want to manage</span>
<span class="linecomment">;;    such option saving using their own function instead of the</span>
<span class="linecomment">;;    default value, `customize-save-variable'.</span>
 
<span class="linecomment">;;(@* "File-Name and Directory-Name Completion Tips")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  File-Name and Directory-Name Completion Tips</span>
<span class="linecomment">;;  --------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section contains some tips about completing file and</span>
<span class="linecomment">;;  directory names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Functions `icicle-file-type-less-p', `icicle-dirs-first-p', and</span>
<span class="linecomment">;;    `icicle-dirs-last-p' are provided as possible values for user</span>
<span class="linecomment">;;    option `icicle-sort-comparer'.  When choosing a sort order using</span>
<span class="linecomment">;;    `C-,' or `M-,', these are called `by file type', `by directories</span>
<span class="linecomment">;;    first', and `by directories last'.  They sort directory names</span>
<span class="linecomment">;;    (alphabetically) before non-directory names (after, for</span>
<span class="linecomment">;;    `icicle-dirs-last-p').  Function `icicle-file-type-less-p' sorts</span>
<span class="linecomment">;;    non-directories by file type (extension) alphabetically.  For</span>
<span class="linecomment">;;    non-file-name input these all act like</span>
<span class="linecomment">;;    `icicle-case-string-less-p'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-cycle-into-subdirs-flag' controls whether or</span>
<span class="linecomment">;;    not minibuffer-input cycling explores subdirectories.  By</span>
<span class="linecomment">;;    default, it is `nil', meaning that cycling does not descend into</span>
<span class="linecomment">;;    subdirectories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    non-`nil' - When this option is non-nil, you might want to use a</span>
<span class="linecomment">;;          function such as `icicle-dirs-last-p' for option</span>
<span class="linecomment">;;          `icicle-sort-comparer', to prevent cycling depth-first</span>
<span class="linecomment">;;          into the subdirectories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `nil' - When this option is `nil', you can still choose to cycle</span>
<span class="linecomment">;;          into a given directory (which is why `nil' is the default</span>
<span class="linecomment">;;          value).  When cycling reaches a candidate directory that</span>
<span class="linecomment">;;          you want to cycle through, just: 1) move the cursor</span>
<span class="linecomment">;;          (e.g. `C-e'), 2) hit `TAB' or `S-TAB' to "complete" the</span>
<span class="linecomment">;;          candidate, and then 3) use any of the cycle keys, such as</span>
<span class="linecomment">;;          `down', to cycle within the candidate directory.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;          Although the candidate directory was already completed by</span>
<span class="linecomment">;;          cycling, moving the cursor and explicitly "completing" it</span>
<span class="linecomment">;;          tells Icicles that you want to treat the candidate in the</span>
<span class="linecomment">;;          minibuffer as real input, just as if you had typed it, not</span>
<span class="linecomment">;;          merely as a cycling candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `..' during completion to access a parent directory,</span>
<span class="linecomment">;;    and you can use `/' and `~/' to shadow input to the left.  There</span>
<span class="linecomment">;;    is currently no special treatment of MS Windows drive letters</span>
<span class="linecomment">;;    (e.g. `C:') - I use Cygwin on Windows.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Non-`nil' user option</span>
<span class="linecomment">;;    `icicle-hide-common-match-in-Completions-flag' hides the common</span>
<span class="linecomment">;;    match for your current input from each candidate in</span>
<span class="linecomment">;;    `*Completions*'.  You can toggle this at any time during</span>
<span class="linecomment">;;    completion using `C-x .' (`icicle-toggle-hiding-common-match').</span>
<span class="linecomment">;;    This can be especially useful when reading an absolute file name</span>
<span class="linecomment">;;    (e.g. `C-u C-x C-f'), by removing any common directory</span>
<span class="linecomment">;;    component.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Standard Emacs user option `completion-ignored-extensions' is a</span>
<span class="linecomment">;;    list of file-name extensions.  File names that match any of</span>
<span class="linecomment">;;    these extensions are generally ignored for completion (but see</span>
<span class="linecomment">;;    the doc string for particulars).  In Icicles, however, the</span>
<span class="linecomment">;;    behavior is slightly different:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - In vanilla Emacs the option is itself ignored for display in</span>
<span class="linecomment">;;      buffer `*Completions*'.  That is, even file names that are</span>
<span class="linecomment">;;      ignored for completion are shown in `*Completions*' as</span>
<span class="linecomment">;;      available completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    - In Icicles this is not the case. When a file name is ignored</span>
<span class="linecomment">;;      it is ignored completely; it is not shown in `*Completions*'.</span>
<span class="linecomment">;;      But in Icicles you can toggle this ignoring off or on at any</span>
<span class="linecomment">;;      time during completion, using `C-.' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    In addition, if you load library `completion-ignored-build.el',</span>
<span class="linecomment">;;    by Kevin Ryde, then Icicles automatically takes advantage of</span>
<span class="linecomment">;;    that library's dynamic adjustment of ignored extensions.  (Just</span>
<span class="linecomment">;;    load the library - do not enable its minor mode or advice.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * User option `icicle-use-~-for-home-dir-flag' controls whether</span>
<span class="linecomment">;;    your home directory is written in the minibuffer using `~' or in</span>
<span class="linecomment">;;    expanded form, during completion.  The default value is `t',</span>
<span class="linecomment">;;    which means to use `~', saving minibuffer space.  You can toggle</span>
<span class="linecomment">;;    this option at any time using command</span>
<span class="linecomment">;;    `icicle-toggle-~-for-home-dir', bound to `M-~'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Remember that you can use a regular expression to</span>
<span class="linecomment">;;    apropos-complete file names.  This is a powerful feature.  Do</span>
<span class="linecomment">;;    not confuse its use with the ability to use shell wildcards</span>
<span class="linecomment">;;    (globbing) to access multiple files at once.  For example, if</span>
<span class="linecomment">;;    you use `C-x 4 f *.el RET', then all files with suffix `el' will</span>
<span class="linecomment">;;    be opened.  Regexp matching is used only for apropos (not</span>
<span class="linecomment">;;    prefix) completion and cycling.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What About Special-Character Conflicts?").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use `$' for both environment variables and as a regexp</span>
<span class="linecomment">;;    special character.  For example, you can use a pattern such as</span>
<span class="linecomment">;;    `$HOME.*t$' to match the files in your home directory (`$HOME')</span>
<span class="linecomment">;;    whose names end in `t'.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What About Special-Character Conflicts?").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Starting with Emacs 23, and if the current `TAB' completion</span>
<span class="linecomment">;;    method is `vanilla' (see (@* "Fuzzy Completion")), you can</span>
<span class="linecomment">;;    complete environment variables during file-name completion,</span>
<span class="linecomment">;;    using `TAB'.  So you can, for example, complete `$HO' to any of</span>
<span class="linecomment">;;    the candidates `HOME', `HOMEDRIVE', `HOMEPATH'.  This is in</span>
<span class="linecomment">;;    addition to the expansion of complete environment variables</span>
<span class="linecomment">;;    (e.g. `$HOME' to `/my/home/dir/') when you use `S-TAB' or `RET'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use the idiom `\W$' as input to match only directories,</span>
<span class="linecomment">;;    when a command asks for a file or directory name.  The `\W' says</span>
<span class="linecomment">;;    to match any non word-syntax character.  The `$' says to match</span>
<span class="linecomment">;;    this at the end of the name.  This works because directory names</span>
<span class="linecomment">;;    appear as completion candidates with a trailing slash (`/'), and</span>
<span class="linecomment">;;    slash (`/') is about the only non word-syntax character that is</span>
<span class="linecomment">;;    likely to appear in file-name completions.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "What About Special-Character Conflicts?").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * You can use library `ffap.el', if you like, with Icicles, to</span>
<span class="linecomment">;;    pick up the file, directory, or URL name under the cursor.  All</span>
<span class="linecomment">;;    Icicles features are available during file-name and URL</span>
<span class="linecomment">;;    completion.  If you like `ffap.el', you might also like to try</span>
<span class="linecomment">;;    my extension library `ffap-.el'.   See also</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "Inserting Text Found Near the Cursor").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Many Icicles commands that target file or directory names look</span>
<span class="linecomment">;;    only in the current directory (`default-directory').  This means</span>
<span class="linecomment">;;    that the directory part of the name is ignored for matching</span>
<span class="linecomment">;;    purposes.  You can thus use apropos completion to match a</span>
<span class="linecomment">;;    substring, without needing to prefix the substring with `.*'.</span>
<span class="linecomment">;;    For example, to match file `favorite-foo-file.bar' in directory</span>
<span class="linecomment">;;    `/some/path/to/my/', it is sufficient to use either `foo' or</span>
<span class="linecomment">;;    `/some/path/to/my/foo'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Some Icicles commands that target file names match your input</span>
<span class="linecomment">;;    against file names as ordinary strings, that is, with no notion</span>
<span class="linecomment">;;    that they are actually file names.  This is the case for</span>
<span class="linecomment">;;    `icicle-locate-file', `icicle-recent-file',</span>
<span class="linecomment">;;    `icicle-find-file-in-tags-table', and</span>
<span class="linecomment">;;    `icicle-find-file-absolute', as well as `icicle-file' with a</span>
<span class="linecomment">;;    prefix argument.  Such candidates are often absolute file names.</span>
<span class="linecomment">;;    In that case, you can regexp-match against any part of the</span>
<span class="linecomment">;;    absolute file name, including directory components.  See</span>
<span class="linecomment">;;    (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If you have symbolic links that might get in the way of</span>
<span class="linecomment">;;    exploring directories while locating files, you can use command</span>
<span class="linecomment">;;    `icicle-locate-file-no-symlinks' instead of</span>
<span class="linecomment">;;    icicle-ignored-directories' - it will not follow symbolic links.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    This also gives you a way to temporarily avoid descending into a</span>
<span class="linecomment">;;    subdirectory you are not interested in: put a symbolic link in</span>
<span class="linecomment">;;    its place temporarily.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Another, cleaner way to skip certain directories is to customize</span>
<span class="linecomment">;;    or `let'-bind option `icicle-ignored-directories'. By default</span>
<span class="linecomment">;;    this is the value of `vc-directory-exclusion-list', which means</span>
<span class="linecomment">;;    that it ignores version-control directories.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Customization and General Tips") for general tips about</span>
<span class="linecomment">;;    using Icicles.  Many of those tips apply also to file-name and</span>
<span class="linecomment">;;    directory-name completion.</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "File-Name Input and Locating Files Anywhere").</span>
 
<span class="linecomment">;;(@* "Key Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Key Bindings</span>
<span class="linecomment">;;  ------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can customize any of the key bindings that Icicles uses - see</span>
<span class="linecomment">;;  (@&gt; "Customizing Key Bindings").  I recommend that you first try</span>
<span class="linecomment">;;  using the default bindings, however.  There are many Icicles key</span>
<span class="linecomment">;;  bindings (in particular in the minibuffer), but they are grouped</span>
<span class="linecomment">;;  into a few natural sets, to help you remember them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Global Bindings")</span>
<span class="linecomment">;;  ** Global Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles does not change your global key bindings.  It changes some</span>
<span class="linecomment">;;  minibuffer bindings, and it adds some bindings for Icicle mode,</span>
<span class="linecomment">;;  but it does not change your global bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are two exceptions:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. In Icicle mode, various Icicles commands are added to menu-bar</span>
<span class="linecomment">;;  menus.  File commands are added to the File menu, and so on, under</span>
<span class="linecomment">;;  an Icicles submenu.  Those items that do not belong naturally to</span>
<span class="linecomment">;;  any existing menu-bar menu are added to a new top-level Icicles</span>
<span class="linecomment">;;  menu and to the existing Minibuf menu.  Whatever the menu they</span>
<span class="linecomment">;;  appear in, however, Icicles menu items are visible only when</span>
<span class="linecomment">;;  Icicle mode is active.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you do not want Icicles to add items to menus besides Minibuf</span>
<span class="linecomment">;;  and Icicles, then set option `icicle-touche-pas-aux-menus' to</span>
<span class="linecomment">;;  non-`nil'.  See (@&gt; "Customizing Key Bindings").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Icicles adds the key `S-TAB' (bound to `icicle-complete-keys')</span>
<span class="linecomment">;;  to each existing keymap.  This allows you to complete keys in any</span>
<span class="linecomment">;;  keymap.  For technical reasons, these bindings are not part of</span>
<span class="linecomment">;;  `icicle-mode-map'; other keymaps are enhanced to include this</span>
<span class="linecomment">;;  binding.  However, this Icicles binding of `S-TAB' never replaces</span>
<span class="linecomment">;;  any existing binding of `S-TAB'.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Key Completion") for more</span>
<span class="linecomment">;;  information about this use of `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs key</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option `icicle-key-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Icicle-Mode Bindings")</span>
<span class="linecomment">;;  ** Icicle-Mode Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most Icicle-mode bindings are in the Icicles menu-bar menu.  In</span>
<span class="linecomment">;;  addition, option `icicle-top-level-key-bindings' causes Icicles to</span>
<span class="linecomment">;;  bind some keyboard keys to some top-level Icicles commands.  Some</span>
<span class="linecomment">;;  of these take the place of similar, global bindings whenever you</span>
<span class="linecomment">;;  are in Icicle mode.  Typically, these top-level commands are</span>
<span class="linecomment">;;  Icicles multi-command versions of the vanilla Emacs commands.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc1.el" :to "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can customize option `icicle-top-level-key-bindings' to</span>
<span class="linecomment">;;  specify the top-level commands that you want to bind in Icicle</span>
<span class="linecomment">;;  mode, and the keys you want to bind them to.  With the default</span>
<span class="linecomment">;;  value of `icicle-top-level-key-bindings', Icicles makes the</span>
<span class="linecomment">;;  following Icicle-mode bindings:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `C-c ''          - `icicle-occur'</span>
<span class="linecomment">;;  * `C-c ='          - `icicle-imenu'</span>
<span class="linecomment">;;  * `C-c `'          - `icicle-search'</span>
<span class="linecomment">;;  * `C-c `'          - `icicle-compilation-search' (in *grep* etc.)</span>
<span class="linecomment">;;  * `C-c `'          - `icicle-comint-search' (in *shell* etc.)</span>
<span class="linecomment">;;  * `C-c TAB'        - `icicle-comint-command' (in *shell* etc.)</span>
<span class="linecomment">;;  * `C-c /'          - `icicle-complete-thesaurus-entry'</span>
<span class="linecomment">;;  * `C-h C-o'        - `icicle-describe-option-of-type'</span>
<span class="linecomment">;;  * `ESC M-x'        - `lacarte-execute-command'</span>
<span class="linecomment">;;  * `M-`', `f10'     - `lacarte-execute-menu-command'</span>
<span class="linecomment">;;  * `M-x'            - `icicle-execute-extended-command'</span>
<span class="linecomment">;;  * `C-x SPC'        - `icicle-command-abbrev'</span>
<span class="linecomment">;;  * `C-x M-e'        - `icicle-execute-named-keyboard-macro'</span>
<span class="linecomment">;;  * `S-f4'           - `icicle-kmacro'</span>
<span class="linecomment">;;  * `pause'          - `icicle-switch-to/from-minibuffer'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `S-TAB' is bound, in effect, to `icicle-complete-keys', which</span>
<span class="linecomment">;;  completes a key sequence.  Prefix keys followed by `S-TAB' are</span>
<span class="linecomment">;;  also bound to `icicle-complete-keys'.  (`S-TAB' is effectively</span>
<span class="linecomment">;;  bound to other commands in buffer `*Completions*' and in the</span>
<span class="linecomment">;;  minibuffer.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (The documentation always refers to the key that performs key</span>
<span class="linecomment">;;  completion as `S-TAB'.  Actually, it is `S-TAB' only by default.</span>
<span class="linecomment">;;  You can customize it, using option `icicle-key-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When `icicle-top-level-key-bindings' has its default value,</span>
<span class="linecomment">;;  Icicles also substitutes all of the key bindings for some standard</span>
<span class="linecomment">;;  Emacs commands.  For example, Icicles binds `icicle-buffer' to all</span>
<span class="linecomment">;;  keys that are globally bound outside Icicle mode to standard</span>
<span class="linecomment">;;  command `switch-to-buffer'.  By default, the following standard</span>
<span class="linecomment">;;  commands have their bindings co-opted this way by Icicles</span>
<span class="linecomment">;;  commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Standard Command                   Icicles Command</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `abort-recursive-edit'.............`icicle-abort-recursive-edit'</span>
<span class="linecomment">;;  `bookmark-jump'....................`icicle-bookmark'</span>
<span class="linecomment">;;  `bookmark-jump-other-window'.......`icicle-bookmark-other-window'</span>
<span class="linecomment">;;  `bookmark-set'.....................`icicle-bookmark-cmd'</span>
<span class="linecomment">;;  `dabbrev-completion'...............`icicle-dabbrev-completion'</span>
<span class="linecomment">;;  `delete-window'....................`icicle-delete-window'</span>
<span class="linecomment">;;  `dired'............................`icicle-dired'</span>
<span class="linecomment">;;  `dired-other-window'...............`icicle-dired-other-window'</span>
<span class="linecomment">;;  `eval-expression'..................`icicle-pp-eval-expression'</span>
<span class="linecomment">;;  `exchange-point-and-mark'.........`icicle-exchange-point-and-mark'</span>
<span class="linecomment">;;  `execute-extended-command'.......`icicle-execute-extended-command'</span>
<span class="linecomment">;;  `find-file'........................`icicle-file'</span>
<span class="linecomment">;;  `find-file-other-window'...........`icicle-file-other-window'</span>
<span class="linecomment">;;  `find-file-read-only'..............`icicle-find-file-read-only'</span>
<span class="linecomment">;;  `find-file-read-only-other-window'.`...read-only-other-window'</span>
<span class="linecomment">;;  `find-tag'.........................`icicle-find-tag'</span>
<span class="linecomment">;;  `find-tag-other-window'.......`icicle-find-first-tag-other-window'</span>
<span class="linecomment">;;  `Info-goto-node'...................`icicle-Info-goto-node'</span>
<span class="linecomment">;;  `Info-index'.......................`icicle-Info-index'</span>
<span class="linecomment">;;  `Info-menu'........................`icicle-Info-menu'</span>
<span class="linecomment">;;  `insert-buffer'....................`icicle-insert-buffer'</span>
<span class="linecomment">;;  `kill-buffer'......................`icicle-kill-buffer'</span>
<span class="linecomment">;;  `lisp-complete-symbol'.............`icicle-lisp-complete-symbol'</span>
<span class="linecomment">;;  `other-window'.....................`icicle-other-window-or-frame'</span>
<span class="linecomment">;;  `other-frame'......................`icicle-select-frame'</span>
<span class="linecomment">;;  `pop-global-mark'...`icicle-goto-global-marker-or-pop-global-mark'</span>
<span class="linecomment">;;  `pop-tag-mark'.....................`icicle-pop-tag-mark'</span>
<span class="linecomment">;;  `pp-eval-expression'...............`icicle-pp-eval-expression'</span>
<span class="linecomment">;;  `set-mark-command'........`icicle-goto-marker-or-set-mark-command'</span>
<span class="linecomment">;;  `switch-to-buffer'.................`icicle-buffer'</span>
<span class="linecomment">;;  `switch-to-buffer-other-window'....`icicle-buffer-other-window'</span>
<span class="linecomment">;;  `where-is'.........................`icicle-where-is'</span>
<span class="linecomment">;;  `yank'.............................`icicle-yank-maybe-completing'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Actually, by default, Icicles binds `icicle-yank-maybe-completing'</span>
<span class="linecomment">;;  to whatever the value of option `icicle-yank-function' is.  By</span>
<span class="linecomment">;;  default, this value is `yank'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Option `icicle-top-level-key-bindings' remaps not only these</span>
<span class="linecomment">;;  standard Emacs commands but also some commands provided by other</span>
<span class="linecomment">;;  libraries.  For example, if you use package Bookmark+, then</span>
<span class="linecomment">;;  type-specific bookmark jump commands such as</span>
<span class="linecomment">;;  `bmkp-dired-jump-other-window' are remapped to Icicles</span>
<span class="linecomment">;;  multi-command versions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some other Icicles commands that you might want to bind</span>
<span class="linecomment">;;  to keys in Icicle mode - they are not bound by Icicles (except to</span>
<span class="linecomment">;;  menu items):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `clear-option' (alias) - Set value of binary option to `nil'</span>
<span class="linecomment">;;  `icicle-add-buffer-candidate' -</span>
<span class="linecomment">;;                          Add buffer to those always shown</span>
<span class="linecomment">;;  `icicle-add-buffer-config' - Add to `icicle-buffer-configs'</span>
<span class="linecomment">;;  `icicle-add-entry-to-saved-completion-set' -</span>
<span class="linecomment">;;                          Add a completion candidate to a saved set</span>
<span class="linecomment">;;  `icicle-add/update-saved-completion-set' - Add a set to</span>
<span class="linecomment">;;                          `icicle-saved-completion-sets'</span>
<span class="linecomment">;;  `icicle-apply'        - Selectively apply function to alist items</span>
<span class="linecomment">;;  `icicle-apropos'      - `apropos', but shows matches</span>
<span class="linecomment">;;  `icicle-apropos-command' - Enhanced `apropos-command'</span>
<span class="linecomment">;;  `icicle-apropos-variable' - Enhanced `apropos-variable'</span>
<span class="linecomment">;;  `icicle-apropos-zippy' - Show matching Zippy quotes</span>
<span class="linecomment">;;  `icicle-bookmark-file-other-window' - Jump to file bookmarks</span>
<span class="linecomment">;;  `icicle-bookmark-dired-other-window'  - Jump to Dired bookmarks</span>
<span class="linecomment">;;  `icicle-bookmark-gnus-other-window' - Jump to Gnus bookmarks</span>
<span class="linecomment">;;  `icicle-bookmark-info-other-window' - Jump to Info bookmarks</span>
<span class="linecomment">;;  `icicle-bookmark-local-file-other-window' - Jump to local files</span>
<span class="linecomment">;;  `icicle-bookmark-non-file-other-window' - Jump to buffers</span>
<span class="linecomment">;;  `icicle-bookmark-region-other-window' - Jump to region bookmarks</span>
<span class="linecomment">;;  `icicle-bookmark-remote-file-other-window' - Jump to remote files</span>
<span class="linecomment">;;  `icicle-bookmark-url-other-window' - Jump to URL bookmarks</span>
<span class="linecomment">;;  `icicle-bookmark-w3m-other-window' - Jump to W3M bookmarks</span>
<span class="linecomment">;;  `icicle-buffer-config' - Pick options for Icicles buffer commands</span>
<span class="linecomment">;;  `icicle-buffer-list'  - Choose a list of buffer names</span>
<span class="linecomment">;;  `icicle-clear-history' - Clear minibuffer histories</span>
<span class="linecomment">;;  `icicle-color-theme'  - Change color theme</span>
<span class="linecomment">;;  `icicle-completing-yank' - Yank text using completion</span>
<span class="linecomment">;;  `icicle-customize-face' - Multi-command `customize-face'</span>
<span class="linecomment">;;  `icicle-customize-icicles-group' -</span>
<span class="linecomment">;;                          Customize Icicles options and faces</span>
<span class="linecomment">;;  `icicle-delete-file'  - Delete a file or directory</span>
<span class="linecomment">;;  `icicle-delete-windows' - Delete all windows for a buffer</span>
<span class="linecomment">;;  `icicle-doc'          - Display doc of function, variable, or face</span>
<span class="linecomment">;;  `icicle-doremi-increment-variable+' -</span>
<span class="linecomment">;;                          Increment a variable using Do Re Mi</span>
<span class="linecomment">;;  `icicle-face-list'    - Choose a list of face names</span>
<span class="linecomment">;;  `icicle-file-list'    - Choose a list of file names</span>
<span class="linecomment">;;  `icicle-font'         - Change the frame font</span>
<span class="linecomment">;;  `icicle-frame-bg'     - Change the frame background color</span>
<span class="linecomment">;;  `icicle-frame-fg'     - Change the frame foreground color</span>
<span class="linecomment">;;  `icicle-fundoc'       - Display the doc of a function</span>
<span class="linecomment">;;  `icicle-increment-option' - Increment numeric options (Do Re Mi)</span>
<span class="linecomment">;;  `icicle-increment-variable' - Increment variables (Do Re Mi)</span>
<span class="linecomment">;;  `icicle-Info-virtual-book' - Open Info on a virtual book</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry' -</span>
<span class="linecomment">;;                          Insert a thesaurus entry</span>
<span class="linecomment">;;  `icicle-keyword-list' - Choose a list of keywords (regexps)</span>
<span class="linecomment">;;  `icicle-locate-file'  - Open a file located anywhere</span>
<span class="linecomment">;;  `icicle-minibuffer-help' - Show Icicles minibuffer help</span>
<span class="linecomment">;;  `icicle-plist'        - Show symbols, property lists</span>
<span class="linecomment">;;  `icicle-recent-file'  - Open a recently used file</span>
<span class="linecomment">;;  `icicle-recompute-shell-command-candidates' - Update from PATH</span>
<span class="linecomment">;;  `icicle-remove-buffer-candidate' -</span>
<span class="linecomment">;;                          Remove buffer from those always shown</span>
<span class="linecomment">;;  `icicle-remove-buffer-config'- Remove from `icicle-buffer-configs'</span>
<span class="linecomment">;;  `icicle-remove-entry-from-saved-completion-set' -</span>
<span class="linecomment">;;                          Remove a candidate from a saved set</span>
<span class="linecomment">;;  `icicle-remove-file-from-recentf-list' - Remove from recent files</span>
<span class="linecomment">;;  `icicle-remove-saved-completion-set' - Remove a set from</span>
<span class="linecomment">;;                          `icicle-saved-completion-sets'</span>
<span class="linecomment">;;  `icicle-reset-option-to-nil' -</span>
<span class="linecomment">;;                          Set value of binary option to `nil'</span>
<span class="linecomment">;;  `icicle-save-string-to-variable' -</span>
<span class="linecomment">;;                          Save text for use with `C-='</span>
<span class="linecomment">;;  `icicle-search-all-tags-bookmark' - Search bookmarks that have all</span>
<span class="linecomment">;;                                      of a given set of tags</span>
<span class="linecomment">;;  `icicle-search-all-tags-regexp-bookmark' - Search bookmarks all of</span>
<span class="linecomment">;;                                     whose tags match a given regexp</span>
<span class="linecomment">;;  `icicle-search-autofile-bookmark' - Search autofile bookmars only</span>
<span class="linecomment">;;  `icicle-search-bookmark' - Search bookmarks</span>
<span class="linecomment">;;  `icicle-search-bookmark-list-bookmark' - bookmark-list bookmarks</span>
<span class="linecomment">;;  `icicle-search-bookmarks-together' - Search bookmarks together</span>
<span class="linecomment">;;  `icicle-search-buff-menu-marked' - Search marked buffers, in order</span>
<span class="linecomment">;;  `icicle-search-buffer' - Search multiple buffers</span>
<span class="linecomment">;;  `icicle-search-char-property' - Search for character properties</span>
<span class="linecomment">;;  `icicle-search-desktop-bookmark' -- Search desktop bookmarks</span>
<span class="linecomment">;;  `icicle-search-dired-bookmark' - Search Dired bookmarks</span>
<span class="linecomment">;;  `icicle-search-dired-marked' - Search the marked files in Dired</span>
<span class="linecomment">;;  `icicle-search-file'  - Search multiple files</span>
<span class="linecomment">;;  `icicle-search-file-bookmark' - Search file bookmarks</span>
<span class="linecomment">;;  `icicle-search-gnus-bookmark' - Search Gnus bookmarks</span>
<span class="linecomment">;;  `icicle-search-ibuffer-marked' - Search marked buffers in Ibuffer</span>
<span class="linecomment">;;  `icicle-search-info-bookmark' - Search Info bookmarks</span>
<span class="linecomment">;;  `icicle-search-local-file-bookmark' - Search local file bookmarks</span>
<span class="linecomment">;;  `icicle-search-man-bookmark' - Search `man'-page bookmarks</span>
<span class="linecomment">;;  `icicle-search-non-file-bookmark' - Search non-file bookmarks</span>
<span class="linecomment">;;  `icicle-search-overlay-property' - Search for overlay properties</span>
<span class="linecomment">;;  `icicle-search-pages' - Search Emacs pages (delimited by ^L chars)</span>
<span class="linecomment">;;  `icicle-search-paragraphs' - Search Emacs paragraphs</span>
<span class="linecomment">;;  `icicle-search-region-bookmark' - Search bookmarked regions</span>
<span class="linecomment">;;  `icicle-search-remote-file-bookmark' - Search remote files</span>
<span class="linecomment">;;  `icicle-search-sentences' - Search using sentences as contexts</span>
<span class="linecomment">;;  `icicle-search-some-tags-bookmark' - Search bookmarks that have</span>
<span class="linecomment">;;                                       some of a given set of tags</span>
<span class="linecomment">;;  `icicle-search-some-tags-regexp-bookmark' - Search bookmarks some</span>
<span class="linecomment">;;                                  of whose tags match a given regexp</span>
<span class="linecomment">;;  `icicle-search-specific-buffers-bookmark' - Search bookmarks for a</span>
<span class="linecomment">;;                                              given set of buffers</span>
<span class="linecomment">;;  `icicle-search-specific-files-bookmark' - Search bookmarks for a</span>
<span class="linecomment">;;                                            given set of files</span>
<span class="linecomment">;;  `icicle-search-thing' - Search thing-at-point-defined things</span>
<span class="linecomment">;;  `icicle-search-this-buffer-bookmark' - Search bookmarks in buffer</span>
<span class="linecomment">;;  `icicle-search-url-bookmark' - Search URL bookmarks</span>
<span class="linecomment">;;  `icicle-search-w3m-bookmark' - Search W3M bookmarks</span>
<span class="linecomment">;;  `icicle-search-xml-element' - Search the contents of XML elements</span>
<span class="linecomment">;;  `icicle-select-window' - Select a window by its buffer name</span>
<span class="linecomment">;;  `icicle-set-option-to-t' - Set value of binary option to `t'</span>
<span class="linecomment">;;  `icicle-toggle-option' - Toggle the value of a binary option</span>
<span class="linecomment">;;  `icicle-vardoc'       - Display the doc of a variable</span>
<span class="linecomment">;;  `toggle' (alias)      - Toggle the value of a binary option</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Minibuffer Bindings")</span>
<span class="linecomment">;;  ** Minibuffer Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are many key bindings available while input is read in the</span>
<span class="linecomment">;;  minibuffer.  Most of these keys are bound in the minibuffer</span>
<span class="linecomment">;;  completion keymaps, but some are bound in the `*Completions*'</span>
<span class="linecomment">;;  buffer keymap and some are bound when reading input without</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In addition, clicking `C-mouse-3' on a completion candidate in</span>
<span class="linecomment">;;  buffer `*Completions*' pops up a menu of available commands.  Some</span>
<span class="linecomment">;;  of these menu commands are applicable to the completion you click;</span>
<span class="linecomment">;;  others apply to the current state of completion or to the complete</span>
<span class="linecomment">;;  set of completion candidates.  The associated key bindings are</span>
<span class="linecomment">;;  indicated in the menu items, so this can be a good way to learn</span>
<span class="linecomment">;;  minibuffer and `*Completions*' bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following key is helpful during any minibuffer input.  It pops</span>
<span class="linecomment">;;  up the `*Help*' buffer with information about using the minibuffer</span>
<span class="linecomment">;;  in Icicle mode.  During completion, this includes information</span>
<span class="linecomment">;;  similar to what you are reading now.  It also lists toggle</span>
<span class="linecomment">;;  commands and the current toggle values.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-?' - `icicle-minibuffer-help'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following key bindings are made for the minibuffer completion</span>
<span class="linecomment">;;  keymaps.  They are in effect whenever you are using the minibuffer</span>
<span class="linecomment">;;  for input with completion (e.g. `completing-read',</span>
<span class="linecomment">;;  `read-file-name', `M-x').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `down', `wheel-down' - `icicle-next-candidate-per-mode' (modal)</span>
<span class="linecomment">;;    `up', `wheel-up' - `icicle-previous-candidate-per-mode' (modal)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `next', `prior'  - `icicle-next-apropos-candidate',</span>
<span class="linecomment">;;                       `icicle-previous-apropos-candidate', which</span>
<span class="linecomment">;;                       cycle candidate apropos completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `end', `home'    - `icicle-next-prefix-candidate',</span>
<span class="linecomment">;;                       `icicle-previous-prefix-candidate',</span>
<span class="linecomment">;;                       which cycle candidate prefix completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      Whether a modal cycling key is used for prefix or apropos</span>
<span class="linecomment">;;      completion at a given time depends on the current completion</span>
<span class="linecomment">;;      mode, which is determined by which of `TAB' and `S-TAB' was used</span>
<span class="linecomment">;;      last, or by option `icicle-default-cycling-mode' if neither was</span>
<span class="linecomment">;;      used.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;      (The mouse wheel bindings are only for Emacs 22 and later.</span>
<span class="linecomment">;;      The documentation refers to the keys that cycle completion</span>
<span class="linecomment">;;      candidates as `down', `up', `next', `prior', `end', and</span>
<span class="linecomment">;;      `home'.  Actually, these are the cycling keys only by default.</span>
<span class="linecomment">;;      You can customize them using options</span>
<span class="linecomment">;;      `icicle-modal-cycle-down-keys', `icicle-modal-cycle-up-keys',</span>
<span class="linecomment">;;      `icicle-apropos-cycle-next-keys',</span>
<span class="linecomment">;;      `icicle-apropos-cycle-previous-keys',</span>
<span class="linecomment">;;      `icicle-prefix-cycle-next-keys', and</span>
<span class="linecomment">;;      icicle-prefix-cycle-previous-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Keys bound globally to commands that perform simple text</span>
<span class="linecomment">;;    insertion, deletion, and transposition operations - commands</span>
<span class="linecomment">;;    such as `self-insert-command' - are bound to Icicles versions of</span>
<span class="linecomment">;;    those commands that do the same thing but also provide apropos</span>
<span class="linecomment">;;    icompletion.  This includes keys such as `C-d', `C-k', and `C-w'</span>
<span class="linecomment">;;    (and lots more).  See (@file :file-name "icicles-doc1.el" :to "Icompletion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `pause'  - `icicle-switch-to/from-minibuffer': Move cursor to</span>
<span class="linecomment">;;               the buffer from which the minibuffer was activated.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-insert' - `icicle-switch-to-Completions-buf': Move cursor to</span>
<span class="linecomment">;;               the current candidate in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-v'    - `icicle-scroll-Completions-forward': Scroll the</span>
<span class="linecomment">;;               `*Completions*' window forward</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-v'    - `icicle-scroll-Completions-backward': Scroll the</span>
<span class="linecomment">;;               `*Completions*' window backward</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-v'  - `icicle-scroll-forward': Scroll the current</span>
<span class="linecomment">;;               non-minibuffer window forward</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-V' (`C-M-S-v') - `icicle-scroll-backward': Scroll the</span>
<span class="linecomment">;;               current non-minibuffer window backward</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-*'    - `icicle-narrow-candidates': Narrow the set of</span>
<span class="linecomment">;;               completion candidates using another input regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-SPC'  - `icicle-prefix-word-complete': Complete current input</span>
<span class="linecomment">;;               in minibuffer, as a prefix, a single word at a time.</span>
<span class="linecomment">;;               This replaces `minibuffer-complete-word'.  In fact,</span>
<span class="linecomment">;;               it is the keys in `icicle-word-completion-keys' that</span>
<span class="linecomment">;;               are bound to this command; `M-SPC' is by default.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `S-SPC'  - `icicle-apropos-complete-and-narrow': Same as</span>
<span class="linecomment">;;               `S-TAB' followed by `M-*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `TAB' -    `icicle-prefix-complete': Complete current input in</span>
<span class="linecomment">;;               minibuffer, as a prefix.  If there is more than one</span>
<span class="linecomment">;;               prefix-completion candidate, display them in buffer</span>
<span class="linecomment">;;               `*Completions*', highlighting the common prefix.</span>
<span class="linecomment">;;               This replaces `minibuffer-complete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (The documentation always refers to the key that does</span>
<span class="linecomment">;;               this as `TAB'.  Actually, it is only `TAB' by</span>
<span class="linecomment">;;               default.  You can customize it, using option</span>
<span class="linecomment">;;               `icicle-prefix-complete-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `S-TAB'  - In the minibuffer: `icicle-apropos-complete' - like</span>
<span class="linecomment">;;               `TAB', but use apropos completion.  In buffer</span>
<span class="linecomment">;;               `*Completions*': `icicle-move-to-previous-completion'</span>
<span class="linecomment">;;               - move backwards among candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (The documentation always refers to the keys that do</span>
<span class="linecomment">;;               these things as `S-TAB'.  Actually, they are only</span>
<span class="linecomment">;;               `S-TAB' by default.  You can customize the keys,</span>
<span class="linecomment">;;               using options `icicle-apropos-complete-keys' and</span>
<span class="linecomment">;;               `icicle-previous-candidate-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-TAB' - `icicle-prefix-complete-no-display': Like `TAB', but</span>
<span class="linecomment">;;               does not display candidates in `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (The documentation always refers to the key that does</span>
<span class="linecomment">;;               this as `C-M-TAB'.  Actually, it is only `C-M-TAB' by</span>
<span class="linecomment">;;               default.  You can customize it, using option</span>
<span class="linecomment">;;               `icicle-prefix-complete-no-display-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-S-TAB' - `icicle-apropos-complete-no-display': Like</span>
<span class="linecomment">;;               `S-TAB', but does not display candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (The documentation always refers to the key that does</span>
<span class="linecomment">;;               this as `C-M-S-TAB'.  Actually, it is only</span>
<span class="linecomment">;;               `C-M-S-TAB' by default.  You can customize it, using</span>
<span class="linecomment">;;               option `icicle-apropos-complete-no-display-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-&'  - `icicle-save-predicate-to-variable': Save the current</span>
<span class="linecomment">;;               predicate used for completion to a variable.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `delete' - `icicle-remove-candidate': Remove the current</span>
<span class="linecomment">;;               candidate from consideration.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `S-mouse-2' - `icicle-mouse-remove-candidate': Same as `delete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-q'    - `icicle-insert-key-description': Insert the textual</span>
<span class="linecomment">;;               representation of a key sequence, during key</span>
<span class="linecomment">;;               completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-o'    - `icicle-insert-history-element': Invoke completion to</span>
<span class="linecomment">;;               insert a previously entered input in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-%'    - Regexp quote current input or its active region, then</span>
<span class="linecomment">;;               apropos-complete.  Use this to literally match all or</span>
<span class="linecomment">;;               some input in the context of regexp matching overall.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-F' (`C-M-S-f') - `icicle-read+insert-file-name': Invoke</span>
<span class="linecomment">;;               completion to insert a file name in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-C' (`C-M-S-c') - `icicle-completing-read+insert': Invoke</span>
<span class="linecomment">;;               completion to insert something other than a file name</span>
<span class="linecomment">;;               (not always available).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;               (`C-M-F' and `C-M-C' are the default values for</span>
<span class="linecomment">;;               the keys that invoke completion on demand.  You can</span>
<span class="linecomment">;;               customize the keys to use, using options</span>
<span class="linecomment">;;               `icicle-read+insert-file-name-keys' and</span>
<span class="linecomment">;;               `icicle-completing-read+insert-keys'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In Icicles, multi-line completion candidates are not uncommon.</span>
<span class="linecomment">;;  You can move up and down minibuffer lines with `C-p' and `C-n',</span>
<span class="linecomment">;;  and you can use the following keys to move among line beginnings</span>
<span class="linecomment">;;  and ends:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-a', `C-e' - `icicle-beginning-of-line+',</span>
<span class="linecomment">;;               `icicle-end-of-line+': Like normal `C-a', `C-e', but</span>
<span class="linecomment">;;               repeating goes to the previous or next line.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use libraries `fit-frame.el' and `oneonone.el' with a</span>
<span class="linecomment">;;  standalone minibuffer frame (non-`nil'</span>
<span class="linecomment">;;  `1on1-minibuffer-frame-flag'), and if option</span>
<span class="linecomment">;;  `1on1-fit-minibuffer-frame-flag' is non-`nil', then the minibuffer</span>
<span class="linecomment">;;  frame is automatically resized to fit its content as you edit that</span>
<span class="linecomment">;;  content.  (Options `1on1-fit-minibuffer-frame-max-height' and</span>
<span class="linecomment">;;  `1on1-fit-minibuffer-frame-max-height-percent' define the maximum</span>
<span class="linecomment">;;  height for this.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If, in addition, you bind `1on1-fit-minibuffer-frame' to a key,</span>
<span class="linecomment">;;  then you can use that key repeatedly to increase the height by one</span>
<span class="linecomment">;;  line, even beyond the maximum.  Library `setup-keys.el' binds this</span>
<span class="linecomment">;;  to `C-o'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (If you do not use a separate minibuffer frame, then you will</span>
<span class="linecomment">;;  likely want to set standard option `resize-mini-windows' to `t',</span>
<span class="linecomment">;;  not to `grow-only', at least while in Icicle mode.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-j' - `icicle-insert-list-join-string': Insert</span>
<span class="linecomment">;;              `icicle-list-join-string'. See also</span>
<span class="linecomment">;;              (@&gt; "Multi-Completions").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can insert a single Icicles multi-line dot using `C-u .', or</span>
<span class="linecomment">;;  by turning on this dot magic generally, using `C-M-.':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `.'     - `icicle-insert-dot-command'</span>
<span class="linecomment">;;    `C-M-.' - `icicle-toggle-dot'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In vanilla Emacs, the following keys have a special purpose during</span>
<span class="linecomment">;;  input completion, but in Icicles they simply insert the character</span>
<span class="linecomment">;;  typed - they are self-inserting.  This is because (1) there are</span>
<span class="linecomment">;;  better ways to do what vanilla Emacs uses these keys for and (2)</span>
<span class="linecomment">;;  it is useful to be able to insert these characters without first</span>
<span class="linecomment">;;  typing `C-q' to quote them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `?'   - see also</span>
<span class="linecomment">;;            (@file :file-name "icicles-doc1.el" :to "What About Special-Character Conflicts?")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `SPC' (space)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-j' (newline) - see also `C-o', above, and</span>
<span class="linecomment">;;                      (@&gt; "Multi-Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings are made to clear minibuffer</span>
<span class="linecomment">;;  input, making them handy for editing and removing completions</span>
<span class="linecomment">;;  (e.g. default or initial values) in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-k' - `icicle-erase-minibuffer-or-history-element'</span>
<span class="linecomment">;;    `M-S-backspace', `M-S-delete' - `icicle-erase-minibuffer'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `M-k' has an alternative behavior when you are cycling minibuffer</span>
<span class="linecomment">;;  history items: it deletes the current item from the history.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following key is bound during completion to control the</span>
<span class="linecomment">;;  display of thumbnail images in `*Completions*' for candidates that</span>
<span class="linecomment">;;  name image files.  It cycles the value of option</span>
<span class="linecomment">;;  `icicle-image-files-in-Completions' to show images and names (the</span>
<span class="linecomment">;;  default), show only names, or show only images.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x t'         - `icicle-cycle-image-file-thumbnail'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During (absolute or relative) file-name completion, the following</span>
<span class="linecomment">;;  minibuffer bindings are also in effect:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-backspace'   - `icicle-up-directory':</span>
<span class="linecomment">;;                      Navigate up the directory hierarchy.</span>
<span class="linecomment">;;    `C-c +'         - `icicle-make-directory': Create a directory.</span>
<span class="linecomment">;;    `C-x m'         - `icicle-bookmark-file-other-window':</span>
<span class="linecomment">;;                      Visit a file or directory (Dired) bookmark.</span>
<span class="linecomment">;;                      See also</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Accessing Saved Locations (Bookmarks) on the Fly").</span>
<span class="linecomment">;;                      (Available only if you use `bookmark+.el'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During absolute file-name completion, you can use `C-c C-d' to</span>
<span class="linecomment">;;  change the current directory on the fly (think UNIX command `cd').</span>
<span class="linecomment">;;  See also</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Absolute File Names and Different Directories").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  During buffer-name completion, the following minibuffer bindings</span>
<span class="linecomment">;;  are also in effect:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x m'         - `icicle-bookmark-non-file-other-window':</span>
<span class="linecomment">;;                      Visit a buffer (non-file) bookmark.  See also</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Accessing Saved Locations (Bookmarks) on the Fly").</span>
<span class="linecomment">;;                      (Available only if you use `bookmark+.el'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x M'         - `icicle-filter-buffer-cands-for-mode':</span>
<span class="linecomment">;;                      Filter the buffer candidate to keep only those</span>
<span class="linecomment">;;                      in a given major mode (you are prompted for</span>
<span class="linecomment">;;                      the mode).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer binding moves the cursor to the start of</span>
<span class="linecomment">;;  the part of your input, if any, that is highlighted because it</span>
<span class="linecomment">;;  does not match any completion candidate (see option</span>
<span class="linecomment">;;  `icicle-highlight-input-completion-failure').  Repeating this</span>
<span class="linecomment">;;  command kills the rest of the line, removing the highlighted</span>
<span class="linecomment">;;  mismatched input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-l'         - `icicle-goto/kill-failed-input'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The remaining input matches at least one candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings can be used to get rid of a</span>
<span class="linecomment">;;  completion inserted during cycling, and retrieve what you last</span>
<span class="linecomment">;;  typed during completion or any previous completion inputs:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-l'           - `icicle-retrieve-previous-input'</span>
<span class="linecomment">;;    `C-S-l' (`C-L') - `icicle-retrieve-next-input'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use these to cycle among and reuse inputs that you typed</span>
<span class="linecomment">;;  during completion but did not enter.  This completion input is not</span>
<span class="linecomment">;;  recorded in the standard input histories - they record only input</span>
<span class="linecomment">;;  that you have entered with `RET'.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, suppose that you used `C-h v hook' to examine various</span>
<span class="linecomment">;;  hook variables, and you did this using`C-next' to display their</span>
<span class="linecomment">;;  documentation.  If you finished the command by just typing `C-g',</span>
<span class="linecomment">;;  then your input (`hook') was never really entered, so it is not</span>
<span class="linecomment">;;  available via the minibuffer history (`M-p').  You can retrieve it</span>
<span class="linecomment">;;  with `C-l', to use it again, in your next command.  User option</span>
<span class="linecomment">;;  `icicle-C-l-uses-completion-flag' controls the behavior of `C-l'</span>
<span class="linecomment">;;  and `C-L'; if non-`nil', then, instead of cycling inputs, these</span>
<span class="linecomment">;;  commands let you access previous inputs using completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You of course have the standard access to the minibuffer history,</span>
<span class="linecomment">;;  via `M-p', `M-n', `M-r', and `M-s'.  In addition to these, the</span>
<span class="linecomment">;;  following minibuffer bindings let you use apropos completion on</span>
<span class="linecomment">;;  the current minibuffer history list.  For explanation, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "History Enhancements").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-h'     - `icicle-history'</span>
<span class="linecomment">;;    `M-pause' - `icicle-keep-only-past-inputs'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Minibuffer binding `C-M-pause' lets you use a different minibuffer</span>
<span class="linecomment">;;  history during the current input reading with completion.</span>
<span class="linecomment">;;  Normally, you are prompted for the history to use.  Starting with</span>
<span class="linecomment">;;  Emacs 23, if option `icicle-populate-interactive-history-flag' is</span>
<span class="linecomment">;;  non-`nil', then during command, abbrev, and keyboard-macro</span>
<span class="linecomment">;;  completion, `C-M-pause' completes your input against the history</span>
<span class="linecomment">;;  of all commands that were invoked interactively in any way,</span>
<span class="linecomment">;;  `icicle-interactive-history'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings let you act on candidate</span>
<span class="linecomment">;;  completions.  For explanation, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands"),</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "More about Multi-Commands"),</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Choose All Completion Candidates"),</span>
<span class="linecomment">;;  and (@&gt; "OO: Object-Action Interaction").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-RET'     - `icicle-candidate-action': current candidate</span>
<span class="linecomment">;;    `C-mouse-2' - `icicle-mouse-candidate-action': clicked candidate</span>
<span class="linecomment">;;    `C-down', `C-wheel-down'</span>
<span class="linecomment">;;                - `icicle-next-candidate-per-mode-action' (modal)</span>
<span class="linecomment">;;    `C-up', `C-wheel-up'</span>
<span class="linecomment">;;                - `icicle-previous-candidate-per-mode-action'(modal)</span>
<span class="linecomment">;;    `C-next'    - `icicle-next-apropos-candidate-action'</span>
<span class="linecomment">;;    `C-prior'   - `icicle-previous-apropos-candidate-action'</span>
<span class="linecomment">;;    `C-end'     - `icicle-next-prefix-candidate-action'</span>
<span class="linecomment">;;    `C-home'    - `icicle-previous-prefix-candidate-action'</span>
<span class="linecomment">;;    `C-!'       - `icicle-all-candidates-action': each candidate</span>
<span class="linecomment">;;    `M-!'       - `icicle-all-candidates-list-action': all, as list</span>
<span class="linecomment">;;    `M-RET'     - `icicle-candidate-read-fn-invoke': apply function</span>
<span class="linecomment">;;    `M-mouse-2' - `icicle-mouse-yank-secondary' (in minibuffer)</span>
<span class="linecomment">;;    `M-mouse-2' - `icicle-mouse-candidate-read-fn-invoke': apply fn</span>
<span class="linecomment">;;    `S-delete'  - `icicle-delete-candidate-object': delete object</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (Some of these are only default key bindings.  You can customize</span>
<span class="linecomment">;;  the keys to use for `previous' and `next' actions, for instance.</span>
<span class="linecomment">;;  The mouse-wheel bindings are only for Emacs 22 and later.  The</span>
<span class="linecomment">;;  notation used here for the wheel bindings is that for Emacs on</span>
<span class="linecomment">;;  Windows; on other platforms different key notations are used for</span>
<span class="linecomment">;;  the wheel.  This same note applies to corresponding keys used with</span>
<span class="linecomment">;;  modifiers `C-M-' and `C-S-' - see below.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Except as noted, the bindings for `icicle-mouse-*' are actually in</span>
<span class="linecomment">;;  the `*Completions*' buffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings provide help on candidate</span>
<span class="linecomment">;;  completions.  For explanation, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Get Help on Candidates")</span>
<span class="linecomment">;;  and (@file :file-name "icicles-doc1.el" :to "Multi-Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-M-RET'   - `icicle-help-on-candidate': current candidate</span>
<span class="linecomment">;;    `C-M-mouse-2' - `icicle-mouse-help-on-candidate': clicked</span>
<span class="linecomment">;;    `C-M-down', `C-M-wheel-down'</span>
<span class="linecomment">;;                - `icicle-next-candidate-per-mode-help' (modal)</span>
<span class="linecomment">;;    `C-M-up', `C-M-wheel-up'</span>
<span class="linecomment">;;                - `icicle-previous-candidate-per-mode-help' (modal)</span>
<span class="linecomment">;;    `C-M-next'  - `icicle-help-on-next-apropos-candidate'</span>
<span class="linecomment">;;    `C-M-prior' - `icicle-help-on-previous-apropos-candidate'</span>
<span class="linecomment">;;    `C-M-end'   - `icicle-help-on-next-prefix-candidate'</span>
<span class="linecomment">;;    `C-M-home'  - `icicle-help-on-previous-prefix-candidate'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings provide an alternative action</span>
<span class="linecomment">;;  for individual candidates.  The alternative action is specific to</span>
<span class="linecomment">;;  the given command.  Most commands define no alternative action.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-S-RET'     - `icicle-candidate-alt-action': current candidate</span>
<span class="linecomment">;;    `C-S-mouse-2' - `icicle-mouse-candidate-alt-action': clicked</span>
<span class="linecomment">;;    `C-S-down', `C-S-wheel-down'</span>
<span class="linecomment">;;                  - `icicle-next-candidate-per-mode-alt-action'</span>
<span class="linecomment">;;                    (modal)</span>
<span class="linecomment">;;    `C-S-up', `C-S-wheel-up'</span>
<span class="linecomment">;;                  - `icicle-previous-candidate-per-mode-alt-action'</span>
<span class="linecomment">;;                    (modal)</span>
<span class="linecomment">;;    `C-S-next'    - `icicle-next-apropos-candidate-alt-action'</span>
<span class="linecomment">;;    `C-S-prior'   - `icicle-previous-apropos-candidate-alt-action'</span>
<span class="linecomment">;;    `C-S-end'     - `icicle-next-prefix-candidate-alt-action'</span>
<span class="linecomment">;;    `C-S-home'    - `icicle-previous-prefix-candidate-alt-action'</span>
<span class="linecomment">;;    `C-|'         - `icicle-all-candidates-alt-action': each</span>
<span class="linecomment">;;    `M-|'         - `icicle-all-candidates-list-alt-action': list</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings let you perform set operations</span>
<span class="linecomment">;;  on sets of completion candidates.  For explanation, see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Sets of Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-~'     - `icicle-candidate-set-complement'</span>
<span class="linecomment">;;    `C--'     - `icicle-candidate-set-difference'</span>
<span class="linecomment">;;    `C-+'     - `icicle-candidate-set-union'</span>
<span class="linecomment">;;    `C-*'     - `icicle-candidate-set-intersection'</span>
<span class="linecomment">;;    `C-M-&lt;'   - `icicle-candidate-set-retrieve': retrieve saved set</span>
<span class="linecomment">;;    `C-M-&gt;'   - `icicle-candidate-set-save': save current set</span>
<span class="linecomment">;;    `C-M-)'   - `icicle-candidate-set-save-selected': save selected</span>
<span class="linecomment">;;    `C-&lt;'     - `icicle-candidate-set-retrieve-more': add from saved</span>
<span class="linecomment">;;    `C-&gt;'     - `icicle-candidate-set-save-more': add to saved set</span>
<span class="linecomment">;;    `C-)'     - `icicle-candidate-set-save-more-selected': selected</span>
<span class="linecomment">;;    `insert'  - `icicle-save/unsave-candidate': save current cand</span>
<span class="linecomment">;;    `C-%'     - `icicle-candidate-set-swap': swap saved and current</span>
<span class="linecomment">;;    `C-:'     - `icicle-candidate-set-define': define current (Lisp)</span>
<span class="linecomment">;;    `M-S-mouse-2' - `icicle-mouse-save/unsave-candidate': (un)save</span>
<span class="linecomment">;;    `M-S-mouse-3' - `icicle-mouse-candidate-set-save': save selected</span>
<span class="linecomment">;;    `M-mouse-3'   - `icicle-mouse-candidate-set-save-more'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings insert text in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-.'     - `icicle-insert-string-at-point'</span>
<span class="linecomment">;;    `C-='     - `icicle-insert-string-from-variable'</span>
<span class="linecomment">;;    `M-:'     - `icicle-pp-eval-expression-in-minibuffer'</span>
<span class="linecomment">;;                (with a prefix arg)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings let you toggle Icicles options</span>
<span class="linecomment">;;  or cycle among alternative Icicles behaviors.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-A' (that is, `C-S-a') - `icicle-toggle-case-sensitivity'</span>
<span class="linecomment">;;    `C-.'     - `icicle-toggle-ignored-extensions' (file completion)</span>
<span class="linecomment">;;    `C-.'     - `icicle-toggle-search-cleanup' (search)</span>
<span class="linecomment">;;    `C-M-.'   - `icicle-toggle-dot'</span>
<span class="linecomment">;;    `C-x .'   - `icicle-toggle-hiding-common-match'</span>
<span class="linecomment">;;    `C-;'     - `icicle-toggle-expand-to-common-match'</span>
<span class="linecomment">;;    `M-;'     - `icicle-toggle-search-replace-common-match'</span>
<span class="linecomment">;;    `C-M-;'   - `icicle-toggle-icicle-toggle-ignoring-comments'</span>
<span class="linecomment">;;    `C-,'     - `icicle-change-sort-order'</span>
<span class="linecomment">;;    `M-,'     - `icicle-change-alternative-sort-order'</span>
<span class="linecomment">;;    `C-M-,'   - `icicle-toggle-alternative-sorting'</span>
<span class="linecomment">;;    `C-^'     - `icicle-toggle-remote-file-testing'</span>
<span class="linecomment">;;    `C-^'     - `icicle-toggle-highlight-all-current' (search)</span>
<span class="linecomment">;;    `C-#'     - `icicle-toggle-incremental-completion'</span>
<span class="linecomment">;;    `C-('     - `icicle-next-TAB-completion-method'</span>
<span class="linecomment">;;    `C-`'     - `icicle-toggle-regexp-quote'</span>
<span class="linecomment">;;    `C-M-`'   - `icicle-toggle-literal-replacement' (search)</span>
<span class="linecomment">;;    `C-$'     - `icicle-toggle-transforming' (removal of duplicates)</span>
<span class="linecomment">;;    `C-pause' - `icicle-toggle-highlight-historical-candidates'</span>
<span class="linecomment">;;    `S-pause' - `icicle-toggle-highlight-saved-candidates'</span>
<span class="linecomment">;;    `M-g'     - `icicle-toggle-C-for-actions'</span>
<span class="linecomment">;;    `M-q'     - `icicle-toggle-search-whole-word' (search)</span>
<span class="linecomment">;;    `M-('     - `icicle-next-S-TAB-completion-method'</span>
<span class="linecomment">;;    `M-~'     - `icicle-toggle-~-for-home-dir'</span>
<span class="linecomment">;;    `M-_'     - `icicle-toggle-ignored-space-prefix'</span>
<span class="linecomment">;;    `M-_'     - `icicle-toggle-search-replace-whole' (search)</span>
<span class="linecomment">;;    `C-M-_'   - `icicle-toggle-proxy-candidates'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings let you incrementally change</span>
<span class="linecomment">;;  options that affect the `*Completions*' display columns and text</span>
<span class="linecomment">;;  size.  To take advantage of these, you must also use Do Re Mi</span>
<span class="linecomment">;;  (libraries `doremi.el' and `doremi-frm.el').  `C-x -' requires</span>
<span class="linecomment">;;  Emacs 23 or later.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x w'   - `icicle-doremi-candidate-width-factor+'</span>
<span class="linecomment">;;    `C-x |'   - `icicle-doremi-inter-candidates-min-spaces+'</span>
<span class="linecomment">;;    `C-x -'   - `icicle-doremi-zoom-Completions+'</span>
<span class="linecomment">;;    `C-x #'   - increment/decrement option `icicle-max-candidates'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When used in the minibuffer, the following Icicles global binding</span>
<span class="linecomment">;;  lets you remove the `*Completions*' window.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-x 0'   - `icicle-delete-window'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer bindings are in effect during Icicles</span>
<span class="linecomment">;;  search:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `C-.'     - `icicle-toggle-search-cleanup'</span>
<span class="linecomment">;;    `C-,'     - `icicle-change-sort-order'</span>
<span class="linecomment">;;    `M-_'     - `icicle-toggle-search-replace-whole'</span>
<span class="linecomment">;;    `M-,'     - `icicle-search-define-replacement'</span>
<span class="linecomment">;;    `M-;'     - `icicle-toggle-search-replace-common-match'</span>
<span class="linecomment">;;    `M-q'     - `icicle-toggle-search-whole-word'</span>
<span class="linecomment">;;    `C-^'     - `icicle-toggle-highlight-all-current'</span>
<span class="linecomment">;;    `C-M-`'   - `icicle-toggle-literal-replacement'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following minibuffer binding lets you evaluate an Emacs-Lisp</span>
<span class="linecomment">;;  sexp at any time, using a recursive minibuffer.  It displays the</span>
<span class="linecomment">;;  result of evaluation in the echo area or in a pop-up buffer, `*Pp</span>
<span class="linecomment">;;  Eval Output*'.  With a prefix arg (`C-u M-:'), it inserts the</span>
<span class="linecomment">;;  result into the minibuffer at point.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `M-:'     - `icicle-pp-eval-expression-in-minibuffer'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Some additional bindings are made available in the minibuffer for</span>
<span class="linecomment">;;  the duration of specific commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * During completion of names of some kinds of objects (files,</span>
<span class="linecomment">;;    buffers, directories, Info nodes), `C-x m' lets you complete</span>
<span class="linecomment">;;    against bookmarks that have the same type as those objects (file</span>
<span class="linecomment">;;    bookmarks, buffer bookmarks, Dired bookmarks, Info bookmarks).</span>
<span class="linecomment">;;    This feature requires use of package Bookmark+.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * During completion of file names, `C-backspace' is bound to</span>
<span class="linecomment">;;    `icicle-up-directory', which navigates to the parent directory</span>
<span class="linecomment">;;    and completes there instead.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * During completion of bookmark names, various keys with the</span>
<span class="linecomment">;;    prefix `C-M-' are bound to commands that narrow the available</span>
<span class="linecomment">;;    candidates to bookmarks of a specific type.  For example,</span>
<span class="linecomment">;;    `C-M-d' narrows the choices to Dired bookmarks.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following bindings are made for `completion-list-mode', that</span>
<span class="linecomment">;;  is, for buffer `*Completions*', which shows the list of candidate</span>
<span class="linecomment">;;  completions:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `left', `right' (`TAB')</span>
<span class="linecomment">;;                    - `icicle-move-to-previous-completion',</span>
<span class="linecomment">;;                      `icicle-move-to-next-completion': Navigate</span>
<span class="linecomment">;;                      backward & forward among candidates</span>
<span class="linecomment">;;    `up', `down'    - `icicle-previous-line', `icicle-next-line':</span>
<span class="linecomment">;;                      Navigate up & down among candidates</span>
<span class="linecomment">;;    `C-insert'      - `icicle-insert-completion': Move cursor to the</span>
<span class="linecomment">;;                      minibuffer, with the current `*Completions*'</span>
<span class="linecomment">;;                      candidate as input</span>
<span class="linecomment">;;    `C-a', `C-e'    - `icicle-beginning-of-line+',</span>
<span class="linecomment">;;                      `icicle-end-of-line+' (repeatable)</span>
<span class="linecomment">;;    `C-g', `q'      - `icicle-abort-recursive-edit'</span>
<span class="linecomment">;;    `mouse-2'       - `icicle-mouse-choose-completion'</span>
<span class="linecomment">;;    `C-mouse-2'     - `icicle-mouse-candidate-action'</span>
<span class="linecomment">;;    `M-mouse-2'     - `icicle-mouse-candidate-read-fn-invoke'</span>
<span class="linecomment">;;    `C-M-mouse-2'   - `icicle-mouse-help-on-candidate'</span>
<span class="linecomment">;;    `M-S-mouse-2'   - `icicle-mouse-save/unsave-candidate'</span>
<span class="linecomment">;;    `C-mouse-3'     - `icicle-Completions-mouse-3-menu'</span>
<span class="linecomment">;;    `M-mouse-3'     - `icicle-mouse-candidate-set-save-more'</span>
<span class="linecomment">;;    `M-S-mouse-3'   - `icicle-mouse-candidate-set-save'</span>
<span class="linecomment">;;    `wheel-down'    - `icicle-scroll-Completions-backward'</span>
<span class="linecomment">;;    `wheel-up'      - `icicle-scroll-Completions-forward'</span>
 
<span class="linecomment">;;(@* "Customizing Key Bindings")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Customizing Key Bindings</span>
<span class="linecomment">;;  ------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@&gt; "Key Bindings") for a description of the key bindings</span>
<span class="linecomment">;;  defined by Icicles.  The options mentioned here are also presented</span>
<span class="linecomment">;;  there, in context.  You can customize all of the key-binding user</span>
<span class="linecomment">;;  options with `M-x customize-group RET Icicles-Key-Bindings'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Key bindings are very personal choices, and reflect preferences</span>
<span class="linecomment">;;  and habits, as well as keyboard and other configurations.  You</span>
<span class="linecomment">;;  might want to change some of the bindings that Icicles creates.</span>
<span class="linecomment">;;  This section tells you how to do that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, before doing so, unless the default bindings present a</span>
<span class="linecomment">;;  hardware or OS configuration problem for you, please try using the</span>
<span class="linecomment">;;  default bindings for a while, before deciding that you want to</span>
<span class="linecomment">;;  change them.  Habit is a powerful persuader, but its advice is not</span>
<span class="linecomment">;;  always the best ;-).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The main user option for customizing key bindings is</span>
<span class="linecomment">;;  `icicle-top-level-key-bindings'.  You use it to change or remove</span>
<span class="linecomment">;;  any of the top-level bindings in Icicle mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are some other user options that make it easy to customize</span>
<span class="linecomment">;;  Icicles key bindings.  Most of these are minibuffer bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-modal-cycle-down-keys'            (`down', `wheel-down')</span>
<span class="linecomment">;;    Cycle to the next candidate (modal).</span>
<span class="linecomment">;;  * `icicle-modal-cycle-up-keys'                  (`up', `wheel-up')</span>
<span class="linecomment">;;    Cycle to the previous candidate (modal).</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-next-keys'                        (`next')</span>
<span class="linecomment">;;    Cycle to the next apropos-completion candidate.</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-previous-keys'                   (`prior')</span>
<span class="linecomment">;;    Cycle to the previous apropos-completion candidate.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-next-keys'                          (`end')</span>
<span class="linecomment">;;    Cycle to the next prefix-completion candidate.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-previous-keys'                     (`home')</span>
<span class="linecomment">;;    Cycle to the previous prefix-completion candidate.</span>
<span class="linecomment">;;  * `icicle-modal-cycle-down-action-keys'  (`C-down', `C-wheel-down)</span>
<span class="linecomment">;;    Cycle to next candidate and act on it (modal).</span>
<span class="linecomment">;;  * `icicle-modal-cycle-up-action-keys'        (`C-up', `C-wheel-up)</span>
<span class="linecomment">;;    Cycle to previous candidate and act on it (modal).</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-next-action-keys'               (`C-next')</span>
<span class="linecomment">;;    Cycle to next apropos-completion candidate and act on it.</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-previous-action-keys'          (`C-prior')</span>
<span class="linecomment">;;    Cycle to previous apropos-completion candidate and act on it.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-next-action-keys'                 (`C-end')</span>
<span class="linecomment">;;    Cycle to next prefix-completion candidate and act on it.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-previous-action-keys'            (`C-home')</span>
<span class="linecomment">;;    Cycle to previous prefix-completion candidate and act on it.</span>
<span class="linecomment">;;  * `icicle-modal-cycle-down-alt-action-keys'           (`C-S-down')</span>
<span class="linecomment">;;    Cycle to next candidate and alternative-act on it (modal).</span>
<span class="linecomment">;;  * `icicle-modal-cycle-up-alt-action-keys'               (`C-S-up')</span>
<span class="linecomment">;;    Cycle to previous candidate and alternative-act on it (modal).</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-next-alt-action-keys'         (`C-S-next')</span>
<span class="linecomment">;;    Cycle to next apropos-completion candidate and alternative-act</span>
<span class="linecomment">;;    on it.</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-previous-alt-action-keys'    (`C-S-prior')</span>
<span class="linecomment">;;    Cycle to previous apropos-completion candidate and</span>
<span class="linecomment">;;    alternative-act on it.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-next-alt-action-keys'           (`C-S-end')</span>
<span class="linecomment">;;    Cycle to next prefix-completion candidate and alternative-act</span>
<span class="linecomment">;;    on it.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-previous-alt-action-keys'      (`C-S-home')</span>
<span class="linecomment">;;    Cycle to previous prefix-completion candidate and</span>
<span class="linecomment">;;    alternative-act on it.</span>
<span class="linecomment">;;  * `icicle-modal-cycle-down-help-keys'                 (`C-M-down')</span>
<span class="linecomment">;;    Cycle to next candidate and show help for it (modal).</span>
<span class="linecomment">;;  * `icicle-modal-cycle-up-help-keys'                     (`C-M-up')</span>
<span class="linecomment">;;    Cycle to previous candidate and show help for it (modal).</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-next-help-keys'               (`C-M-next')</span>
<span class="linecomment">;;    Cycle to next apropos-completion candidate and show help for it.</span>
<span class="linecomment">;;  * `icicle-apropos-cycle-previous-help-keys'          (`C-M-prior')</span>
<span class="linecomment">;;    Cycle to previous apropos-completion candidate and show help.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-next-help-keys'                 (`C-M-end')</span>
<span class="linecomment">;;    Cycle to next prefix-completion candidate and show help for it.</span>
<span class="linecomment">;;  * `icicle-prefix-cycle-previous-help-keys'            (`C-M-home')</span>
<span class="linecomment">;;    Cycle to previous prefix-completion candidate and show help.</span>
<span class="linecomment">;;  * `icicle-prefix-complete-keys'                            (`TAB')</span>
<span class="linecomment">;;    Prefix-complete your input.</span>
<span class="linecomment">;;  * `icicle-apropos-complete-keys'                         (`S-TAB')</span>
<span class="linecomment">;;    Apropos-complete your input.</span>
<span class="linecomment">;;  * `icicle-prefix-complete-no-display-keys'             (`C-M-TAB')</span>
<span class="linecomment">;;    Prefix-complete without showing `*Completions*'.</span>
<span class="linecomment">;;  * `icicle-apropos-complete-no-display-keys'          (`C-M-S-TAB')</span>
<span class="linecomment">;;    Apropos-complete without showing `*Completions*'.</span>
<span class="linecomment">;;  * `icicle-word-completion-keys'                          (`M-SPC')</span>
<span class="linecomment">;;    Prefix-complete your input a word at a time.</span>
<span class="linecomment">;;  * `icicle-key-complete-keys'                             (`S-TAB')</span>
<span class="linecomment">;;    Complete key sequences.</span>
<span class="linecomment">;;  * `icicle-previous-candidate-keys'                       (`S-TAB')</span>
<span class="linecomment">;;    Move to the previous candidate in `*Completions*'.</span>
<span class="linecomment">;;  * `icicle-completing-read+insert-keys'                 (`C-M-S-c')</span>
<span class="linecomment">;;    Completion on demand.</span>
<span class="linecomment">;;  * `icicle-read+insert-file-name-keys'                  (`C-M-S-f')</span>
<span class="linecomment">;;    Completion on demand for file names.</span>
<span class="linecomment">;;  * `icicle-search-from-isearch-keys'                      (`S-TAB')</span>
<span class="linecomment">;;    Start `icicle-search' from Isearch.</span>
<span class="linecomment">;;  * `icicle-isearch-complete-keys'       (`M-TAB', `C-M-TAB', `M-o')</span>
<span class="linecomment">;;    Complete incremental search string using search ring.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These are the main kinds of Icicles key bindings:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Global bindings</span>
<span class="linecomment">;;    . Additions to menu-bar menus</span>
<span class="linecomment">;;    . Key completion keys (`S-TAB' by default)</span>
<span class="linecomment">;;  * Icicle mode bindings</span>
<span class="linecomment">;;  * Minibuffer bindings</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Customizing Global Bindings")</span>
<span class="linecomment">;;  ** Customizing Global Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles normally adds items to appropriate existing menu-bar</span>
<span class="linecomment">;;  menus, such as File and Options, as well as to menu-bar menus</span>
<span class="linecomment">;;  Minibuf and Icicles.  These items are placed in an Icicles submenu</span>
<span class="linecomment">;;  (e.g. Files &gt; Icicles).  If you do not want to add an Icicles</span>
<span class="linecomment">;;  submenu, then set option `icicle-touche-pas-aux-menus-flag' to</span>
<span class="linecomment">;;  non-`nil' before loading Icicles.  The menu items are then added</span>
<span class="linecomment">;;  to the Icicles menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles binds key completion (`icicle-complete-keys') to the keys</span>
<span class="linecomment">;;  defined in option `icicle-key-complete-keys'.  See</span>
<span class="linecomment">;;  (@&gt; "Key Bindings") for more information about this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Customizing Icicle Mode Bindings")</span>
<span class="linecomment">;;  ** Customizing Icicle Mode Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In the Icicle mode keymap, several top-level commands are bound by</span>
<span class="linecomment">;;  default.  You can use option `icicle-top-level-key-bindings' to</span>
<span class="linecomment">;;  customize the keys that are used for these commands, or to remove</span>
<span class="linecomment">;;  any such bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Customizing Minibuffer Bindings")</span>
<span class="linecomment">;;  ** Customizing Minibuffer Bindings **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are user options for most Icicles minibuffer bindings that</span>
<span class="linecomment">;;  you might want to change - see above for the list.  This section</span>
<span class="linecomment">;;  tells you how to change additional bindings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To understand how you can modify Icicles minibuffer bindings, it</span>
<span class="linecomment">;;  helps to know how Icicles creates the default bindings.  For that,</span>
<span class="linecomment">;;  the best advice is to consult the Emacs-Lisp code in library</span>
<span class="linecomment">;;  `icicle-mode.el'.  Even if you are not very familiar with</span>
<span class="linecomment">;;  Emacs-Lisp, however, you should be able to do what you want by</span>
<span class="linecomment">;;  adapting the example in this section.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Suppose that you want to bind `f11' and `f12' to traverse the</span>
<span class="linecomment">;;  input history up and down whenever you are in Icicle mode.  There</span>
<span class="linecomment">;;  are no user options for this, but you can do it by inserting this</span>
<span class="linecomment">;;  code into your init file (~/.emacs), before the code that requires</span>
<span class="linecomment">;;  (loads) library `icicles.el':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (add-hook 'icicle-mode-hook 'bind-my-icicles-keys)</span>
<span class="linecomment">;;  (defun bind-my-icicles-keys ()</span>
<span class="linecomment">;;    "Replace some default Icicles minibuffer bindings with others."</span>
<span class="linecomment">;;    (dolist</span>
<span class="linecomment">;;        (map</span>
<span class="linecomment">;;          (append</span>
<span class="linecomment">;;           (list minibuffer-local-completion-map</span>
<span class="linecomment">;;                 minibuffer-local-must-match-map)</span>
<span class="linecomment">;;           (and (fboundp</span>
<span class="linecomment">;;                 'minibuffer-local-filename-completion-map)</span>
<span class="linecomment">;;                (list minibuffer-local-filename-completion-map))))</span>
<span class="linecomment">;;      (when icicle-mode</span>
<span class="linecomment">;;        (define-key map [f11] 'previous-history-element)</span>
<span class="linecomment">;;        (define-key map [f12] 'next-history-element))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Key Bindings")</span>
<span class="linecomment">;;  * (@&gt; "Customization and General Tips") for information</span>
<span class="linecomment">;;    about other customizations, besides key bindings.</span>
 
<span class="linecomment">;;(@* "Icicles Redefines Some Standard Functions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles Redefines Some Standard Functions</span>
<span class="linecomment">;;  -----------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  User option `icicle-functions-to-redefine' is a list of functions</span>
<span class="linecomment">;;  (typically commands) that are automatically redefined in Icicle</span>
<span class="linecomment">;;  mode to enhance them for Icicles completion.  The original</span>
<span class="linecomment">;;  definitions are restored when you exit Icicle mode.  The default</span>
<span class="linecomment">;;  value of `icicle-functions-to-redefine' contains the following</span>
<span class="linecomment">;;  functions:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `bbdb-complete-name' (from BBDB), `comint-dynamic-complete',</span>
<span class="linecomment">;;    `comint-dynamic-complete-filename',</span>
<span class="linecomment">;;    `comint-replace-by-expanded-filename', `customize-apropos',</span>
<span class="linecomment">;;    `customize-apropos-faces', `customize-apropos-groups',</span>
<span class="linecomment">;;    `customize-apropos-options', `customize-apropos-options-of-type'</span>
<span class="linecomment">;;    (from `cus-edit+.el'), `customize-face',</span>
<span class="linecomment">;;    `customize-face-other-window', `dabbrev-completion',</span>
<span class="linecomment">;;    `dired-read-shell-command', `ess-complete-object-name' (from</span>
<span class="linecomment">;;    ESS), `gud-gdb-complete-command', `lisp-complete-symbol',</span>
<span class="linecomment">;;    `lisp-completion-at-point',</span>
<span class="linecomment">;;    `minibuffer-default-add-completions', `read-color',</span>
<span class="linecomment">;;    `read-from-minibuffer', `read-shell-command', `read-string',</span>
<span class="linecomment">;;    `recentf-make-menu-items', `repeat-complex-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles unconditionally redefines these standard Emacs functions</span>
<span class="linecomment">;;  while in Icicle mode:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `choose-completion', `choose-completion-string',</span>
<span class="linecomment">;;    `completing-read', `completing-read-multiple',</span>
<span class="linecomment">;;    `completion-setup-function', `dired-smart-shell-command',</span>
<span class="linecomment">;;    `display-completion-list', `exit-minibuffer',</span>
<span class="linecomment">;;    `face-valid-attribute-values', `minibuffer-complete-and-exit',</span>
<span class="linecomment">;;    `mouse-choose-completion', `next-history-element',</span>
<span class="linecomment">;;    `read-face-name', `read-file-name', `read-number',</span>
<span class="linecomment">;;    `shell-command', `shell-command-on-region', `sit-for',</span>
<span class="linecomment">;;    `switch-to-completions'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you exit Icicle mode, the standard definitions are restored.</span>
 
<span class="linecomment">;;(@* "Programming with Fancy Candidates")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Programming with Fancy Candidates</span>
<span class="linecomment">;;  ---------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles lets you program with several kinds of candidates that are</span>
<span class="linecomment">;;  not supported by vanilla Emacs.  For lack of a better word, I call</span>
<span class="linecomment">;;  them all "fancy candidates".  Multi-completions are fancy</span>
<span class="linecomment">;;  candidates.  So are ordinary string candidates that have text</span>
<span class="linecomment">;;  properties such as `face'.  And there are other kinds of fancy</span>
<span class="linecomment">;;  candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because they are not supported by vanilla Emacs, and because</span>
<span class="linecomment">;;  Icicles uses Emacs functions such as `all-completions' to perform</span>
<span class="linecomment">;;  the primitive completion operations, fancy candidates require some</span>
<span class="linecomment">;;  extra processing.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All fancy candidates must first be converted to a form that such</span>
<span class="linecomment">;;  primitives can understand.  During completion, fancy candidates</span>
<span class="linecomment">;;  must sometimes be displayed specially, for example using</span>
<span class="linecomment">;;  particular faces.  And after completion, the completion result</span>
<span class="linecomment">;;  must sometimes be converted back again to retrieve some or all of</span>
<span class="linecomment">;;  the original candidate information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This conversion (encoding and decoding) can be costly, especially</span>
<span class="linecomment">;;  when there are many candidates.  For this reason, it is turned</span>
<span class="linecomment">;;  off, by default, so it that does not represent overhead during</span>
<span class="linecomment">;;  completion of non-fancy candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In order to use `completing-read' with fancy candidates, you must</span>
<span class="linecomment">;;  do one of the following in your code:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Propertize at least the first character of the</span>
<span class="linecomment">;;     `completing-read' PROMPT argument string with a non-`nil' text</span>
<span class="linecomment">;;     property `icicle-fancy-candidates'.  This turns on processing</span>
<span class="linecomment">;;     of fancy candidates for the duration of the `completing-read'</span>
<span class="linecomment">;;     call.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Bind variable `icicle-fancy-candidates-p' to non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Bind variable `icicle-whole-candidate-as-text-prop-p' to</span>
<span class="linecomment">;;     non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You use method 1 or 2 to handle multi-completion candidates or</span>
<span class="linecomment">;;  candidates that have text properties or are otherwise to be</span>
<span class="linecomment">;;  displayed specially.  I recommend that you generally use text</span>
<span class="linecomment">;;  property `icicle-fancy-candidates', not variable</span>
<span class="linecomment">;;  `icicle-fancy-candidates-p'.  The variable is provided so that you</span>
<span class="linecomment">;;  can widen the scope of this feature beyond a given call to</span>
<span class="linecomment">;;  `completing-read'.  You will need to do that only rarely.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A use case for variable `icicle-fancy-candidates-p' would be, for</span>
<span class="linecomment">;;  instance, if your code calls other code that calls</span>
<span class="linecomment">;;  `completing-read', so you have no direct access to the</span>
<span class="linecomment">;;  `completing-read' PROMPT argument in order to propertize it.  If</span>
<span class="linecomment">;;  you nevertheless want to use some fancy candidates, then you can</span>
<span class="linecomment">;;  bind `icicle-fancy-candidates-p' with the scope you want.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You use method 3, `icicle-whole-candidate-as-text-prop-p', when</span>
<span class="linecomment">;;  you need to save and later retrieve all of the information</span>
<span class="linecomment">;;  contained in an alist COLLECTION entry.  Completion returns only a</span>
<span class="linecomment">;;  string.  If the COLLECTION alist has only one entry with a given</span>
<span class="linecomment">;;  string as its car, then you can simply use `assoc' to retrieve the</span>
<span class="linecomment">;;  whole entry.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But if you use an alist that allows entries with different cdrs</span>
<span class="linecomment">;;  for the same car, then you need some way to encode an entire alist</span>
<span class="linecomment">;;  entry in a display string.  When you have this need, set variable</span>
<span class="linecomment">;;  `icicle-candidates-alist' to the alist, and bind</span>
<span class="linecomment">;;  `icicle-whole-candidate-as-text-prop-p' to non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This has the effect of encoding, as a text property on the</span>
<span class="linecomment">;;  candidate display string, the entire corresponding original alist</span>
<span class="linecomment">;;  entry.  You can then use `icicle-get-alist-candidate' to recover</span>
<span class="linecomment">;;  that information.</span>
 
<span class="linecomment">;;(@* "Programming Multi-Completions")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Programming Multi-Completions</span>
<span class="linecomment">;;  -----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-completions are completion candidates that are composed of</span>
<span class="linecomment">;;  parts separated by `icicle-list-join-string' and terminated by</span>
<span class="linecomment">;;  `icicle-list-end-string'.  See (@&gt; "Multi-Completions") for</span>
<span class="linecomment">;;  information about how users interact with multi-completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Multi-completions are examples of fancy candidates.</span>
<span class="linecomment">;;  See (@&gt; "Programming with Fancy Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can define your own Icicles commands that use</span>
<span class="linecomment">;;  multi-completions.  You can bind `icicle-list-join-string' or</span>
<span class="linecomment">;;  `icicle-list-end-string' to any strings you like, depending on</span>
<span class="linecomment">;;  your needs.  See</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Key Completion") for an</span>
<span class="linecomment">;;  example where `icicle-list-join-string' is bound to "  =  " and</span>
<span class="linecomment">;;  `icicle-list-end-string' is "".  This section describes two</span>
<span class="linecomment">;;  additional variables that you can bind to affect the appearance</span>
<span class="linecomment">;;  and behavior of multi-completions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Variable icicle-list-use-nth-parts")</span>
<span class="linecomment">;;  ** Variable icicle-list-use-nth-parts **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-list-use-nth-parts' affects the minibuffer</span>
<span class="linecomment">;;  behavior of multi-completions.  If you bind this to a list of</span>
<span class="linecomment">;;  whole numbers, then multi-completion candidates are transformed</span>
<span class="linecomment">;;  using those numbers as indexes.  During completion and cycling,</span>
<span class="linecomment">;;  whenever a sole candidate matches the user input, if that</span>
<span class="linecomment">;;  candidate is a multi-completion, then it is transformed by</span>
<span class="linecomment">;;  extracting and possibly reordering its parts according to</span>
<span class="linecomment">;;  `icicle-list-use-nth-parts'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The actual candidate to match is still the original candidate; the</span>
<span class="linecomment">;;  transformation takes place after matching, for final insertion in</span>
<span class="linecomment">;;  the minibuffer.  This means that you must use this feature only</span>
<span class="linecomment">;;  with lax (permissive) completion, since strict completion requires</span>
<span class="linecomment">;;  an exact match against the original completion candidate, and the</span>
<span class="linecomment">;;  transformed candidate will normally not match the original.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-list-use-nth-parts' works as follows.  The</span>
<span class="linecomment">;;  matching candidate is split at each `icicle-list-join-string' into</span>
<span class="linecomment">;;  its component parts.  The indexes in `icicle-list-use-nth-parts'</span>
<span class="linecomment">;;  are then used to extract parts, in the same order as the indexes</span>
<span class="linecomment">;;  appear.  The extracted parts are joined back together in an order</span>
<span class="linecomment">;;  that you specify, separated by the value of user option</span>
<span class="linecomment">;;  `icicle-list-nth-parts-join-string'.  An index greater than the</span>
<span class="linecomment">;;  number of parts means to use the last part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example: If the value of `icicle-list-use-nth-parts' is (1),</span>
<span class="linecomment">;;  then only the first part of the multi-completion is used as the</span>
<span class="linecomment">;;  completion candidate.  If the value is (2 1), then the resulting</span>
<span class="linecomment">;;  candidate is the second part followed by the first part, the two</span>
<span class="linecomment">;;  parts being joined by `icicle-list-nth-parts-join-string'.  If the</span>
<span class="linecomment">;;  value is (1 99) and the multi-completion has fewer than 99 parts,</span>
<span class="linecomment">;;  then the first and last parts are used.  If the value is (2 1 2),</span>
<span class="linecomment">;;  then the resulting candidate is composed of the second part</span>
<span class="linecomment">;;  followed by the first part followed by the second part again.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Thus, you can use a given part any number of times.  You can also</span>
<span class="linecomment">;;  mix multi-completions and single-string completions, and you can</span>
<span class="linecomment">;;  mix multi-completions composed of different numbers of strings.</span>
<span class="linecomment">;;  For example, a set of completions might be:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  ((("cmd1" "description of cmd1"))</span>
<span class="linecomment">;;   (("cmd2" "description of cmd" "more"))</span>
<span class="linecomment">;;   (("cmd3")))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use multi-completions with `icicle-list-use-nth-parts' in</span>
<span class="linecomment">;;  your own commands, please make sure that their doc strings let</span>
<span class="linecomment">;;  users know what to expect, and remind them of the behavior of</span>
<span class="linecomment">;;  option `icicle-list-nth-parts-join-string'.  Let them know, in</span>
<span class="linecomment">;;  particular, that:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can match any part of a candidate as it is displayed in</span>
<span class="linecomment">;;    buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The candidate choice they make will in fact have the form that</span>
<span class="linecomment">;;    you define in your command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can control how the parts are joined, using option</span>
<span class="linecomment">;;    `icicle-list-nth-parts-join-string'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Variable icicle-candidate-properties-alist")</span>
<span class="linecomment">;;  ** Variable icicle-candidate-properties-alist **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Whereas variable `icicle-list-nth-parts-join-string' affects the</span>
<span class="linecomment">;;  appearance of multi-completions in the minibuffer, variable</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist' affects their appearance in</span>
<span class="linecomment">;;  buffer `*Completions*'.  You use it to apply text properties to</span>
<span class="linecomment">;;  individual parts of a multi-completion, where the parts are</span>
<span class="linecomment">;;  defined in the same way as for `icicle-list-use-nth-parts'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This feature affects all candidates the same way.  See also</span>
<span class="linecomment">;;  (@&gt; "Candidates with Text Properties") for ways to apply text</span>
<span class="linecomment">;;  properties to individual candidates (which need not be</span>
<span class="linecomment">;;  multi-completions).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The value of `icicle-candidate-properties-alist' is an alist whose</span>
<span class="linecomment">;;  entries have either of these forms:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (NTH PROPERTIES) or (NTH PROPERTIES JOIN-TOO)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  NTH is the number of the target multi-completion part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  PROPERTIES is a list of text properties to apply to the NTH part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  JOIN-TOO is optional.  If it is present and non-`nil', then the</span>
<span class="linecomment">;;  text properties are also applied to the join string that follows</span>
<span class="linecomment">;;  the target part.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use any text properties, including `invisible', `keymap',</span>
<span class="linecomment">;;  `display', and properties that you define yourself and that have</span>
<span class="linecomment">;;  meaning to only your code.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of its use, commands `icicle-fundoc',</span>
<span class="linecomment">;;  `icicle-vardoc', `icicle-doc', and `icicle-plist' bind</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist' to</span>
<span class="linecomment">;;  ((1 (face 'icicle-candidate-part))), so that the first part of</span>
<span class="linecomment">;;  each multi-completion candidate is highlighted using face</span>
<span class="linecomment">;;  `icicle-candidate-part'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here is another example value of</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  ((3 (face 'underline))</span>
<span class="linecomment">;;   (2 (invisible t) t))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first entry underlines the third multi-completion part.  The</span>
<span class="linecomment">;;  second entry makes both the second part and the join string that</span>
<span class="linecomment">;;  follows it invisible.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One use of making a completion part invisible is so that you can</span>
<span class="linecomment">;;  sort candidates using it, and let users match input against it,</span>
<span class="linecomment">;;  but not have it appear explicitly.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Recall that `completing-read' displays only the car of each</span>
<span class="linecomment">;;  element present in its COLLECTION (alist) argument.  For example,</span>
<span class="linecomment">;;  if you pass `completing-read' an alist such as (("foo" . 2) ("bar"</span>
<span class="linecomment">;;  . 3)), then only `foo' and `bar' are displayed as candidates.</span>
<span class="linecomment">;;  However, the PREDICATE argument to `completing-read' applies to</span>
<span class="linecomment">;;  the entire alist element, and your command that calls</span>
<span class="linecomment">;;  `completing-read' might well use the chosen candidate (e.g. `foo')</span>
<span class="linecomment">;;  to look up the entire element (e.g. ("foo" . 2)) for further</span>
<span class="linecomment">;;  processing.  Several Icicles commands, including `icicle-search',</span>
<span class="linecomment">;;  do that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, sometimes you might want the user to be able to match</span>
<span class="linecomment">;;  against the additional information (e.g. 2 and 3), and you might</span>
<span class="linecomment">;;  want to use it to sort candidates.  In that case, you can use the</span>
<span class="linecomment">;;  alist (("foo 2") ("bar 3")).  In cases where the additional</span>
<span class="linecomment">;;  information can be distracting, you can use multi-completion with</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist' to hide it: Pass the alist</span>
<span class="linecomment">;;  ((("foo "2")) (("bar" 3"))) and use ((2 (invisible t))) for</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Keep in mind that hiding completion parts can be confusing to</span>
<span class="linecomment">;;  users.  Do so with care, and let your users know what to expect.</span>
<span class="linecomment">;;  Inform them that there are invisible parts that are nevertheless</span>
<span class="linecomment">;;  taken into account for input matching and candidate sorting.  When</span>
<span class="linecomment">;;  you hide parts, you will often want to omit them from the</span>
<span class="linecomment">;;  minibuffer as well, using `icicle-list-use-nth-parts', to avoid</span>
<span class="linecomment">;;  confusion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Consider also the position of a hidden part: In some cases you</span>
<span class="linecomment">;;  might want to place it first among the multi-completion parts, but</span>
<span class="linecomment">;;  in many cases you will want to place it last, to minimize</span>
<span class="linecomment">;;  interference with prefix-completion matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similar considerations apply to other text properties, such as</span>
<span class="linecomment">;;  `display' and `keymap', that change the appearance or behavior of</span>
<span class="linecomment">;;  a completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "What You See Is Not What You Get")</span>
<span class="linecomment">;;  ** What You See Is Not What You Get **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  While on the subject of confusing users, let me point out a</span>
<span class="linecomment">;;  general drawback that is common to both</span>
<span class="linecomment">;;  `icicle-list-use-nth-parts' and</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist': *not* WYSIWYG.  Keep this in</span>
<span class="linecomment">;;  mind if you decide to take advantage of these variables.  Users</span>
<span class="linecomment">;;  see one thing, choose it, and they get something different as a</span>
<span class="linecomment">;;  result.  That promotes confusion that you will need to weigh</span>
<span class="linecomment">;;  against the possible benefits.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Users are confused, because what they choose is not exactly what</span>
<span class="linecomment">;;  they get.  What's more, a user's completion choice is not</span>
<span class="linecomment">;;  reflected in the input history, leading to further confusion.  For</span>
<span class="linecomment">;;  example, Icicles highlighting of previously used inputs in buffer</span>
<span class="linecomment">;;  `*Completions*' does not apply to such a candidate, even though it</span>
<span class="linecomment">;;  was previously entered using `RET'.  It is the transformed</span>
<span class="linecomment">;;  candidate that was entered, not the candidate as it was proposed</span>
<span class="linecomment">;;  for choosing, so when that candidate is proposed again, it is not</span>
<span class="linecomment">;;  recognized as having been previously chosen.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The bottom line here is this: variables</span>
<span class="linecomment">;;  `icicle-list-use-nth-parts' and</span>
<span class="linecomment">;;  `icicle-candidate-properties-alist' are useful in certain</span>
<span class="linecomment">;;  contexts, but be aware of the downside: confusing your users.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Multi-Completions")</span>
<span class="linecomment">;;  * (@&gt; "Programming with Fancy Candidates")</span>
<span class="linecomment">;;  * (@&gt; "Candidates with Text Properties")</span>
 
<span class="linecomment">;;(@* "Candidates with Text Properties")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Candidates with Text Properties</span>
<span class="linecomment">;;  -------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Section (@&gt; "Programming Multi-Completions") explains how to apply</span>
<span class="linecomment">;;  text properties to specific parts of all multi-completion</span>
<span class="linecomment">;;  candidates in buffer `*Completions*' at the same time.  This</span>
<span class="linecomment">;;  section tells you how to apply text properties to specific</span>
<span class="linecomment">;;  candidates in `*Completions*'.  The candidates need not be</span>
<span class="linecomment">;;  multi-completions, but in some cases they can be.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use candidates with text properties such as `face' that</span>
<span class="linecomment">;;  are visible, the display candidates in `*Completions*' show those</span>
<span class="linecomment">;;  properties.  In addition, the candidate string that the user</span>
<span class="linecomment">;;  finally chooses can also be propertized.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are four different methods for providing candidates with</span>
<span class="linecomment">;;  text properties, in addition to the way presented in section</span>
<span class="linecomment">;;  (@&gt; "Programming Multi-Completions"):</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Apply face `icicle-special-candidate' to all candidates that</span>
<span class="linecomment">;;     match a given regexp.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Use a set of text properties as the `icicle-special-candidate'</span>
<span class="linecomment">;;     property of the symbol that represents the candidate.  The text</span>
<span class="linecomment">;;     properties are transferred to the string candidate that is</span>
<span class="linecomment">;;     displayed (and returned).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Use a propertized string as the `icicle-display-string'</span>
<span class="linecomment">;;     property of the symbol that represents the candidate.  That</span>
<span class="linecomment">;;     string replaces the candidate that would otherwise have been</span>
<span class="linecomment">;;     displayed, completed against, and returned.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Start with a propertized string in the COLLECTION argument</span>
<span class="linecomment">;;     that you pass to `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  All four methods use fancy candidates, in the sense that they go</span>
<span class="linecomment">;;  beyond what vanilla Emacs offers.  For methods 1-3, you must turn</span>
<span class="linecomment">;;  on fancy-candidate handling.  See</span>
<span class="linecomment">;;  (@&gt; "Programming with Fancy Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But method 4 does not require any costly fancy-candidate encoding</span>
<span class="linecomment">;;  or decoding, because the Icicles implementation of</span>
<span class="linecomment">;;  `completing-read' handles propertized string candidates, and they</span>
<span class="linecomment">;;  are transparent to the Emacs primitive completion operations.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following sections explain methods 1-4 individually.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Regexp `icicle-special-candidate-regexp'")</span>
<span class="linecomment">;;  ** Using Regexp `icicle-special-candidate-regexp' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you just want several candidates to have face</span>
<span class="linecomment">;;  `icicle-special-candidate' in `*Completions', you can simply</span>
<span class="linecomment">;;  define (e.g. bind) option `icicle-special-candidate-regexp' to a</span>
<span class="linecomment">;;  regexp that matches those candidates.  The original candidates can</span>
<span class="linecomment">;;  be strings or symbols.  Unlike the other methods described here,</span>
<span class="linecomment">;;  this one affects only the display in `*Completions'; the</span>
<span class="linecomment">;;  completion return string does not have face</span>
<span class="linecomment">;;  `icicle-special-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The highlighting applies only to the part of a candidate that</span>
<span class="linecomment">;;  matches the regexp.  This selectivity is particularly useful when</span>
<span class="linecomment">;;  dealing with multi-completions.  Function `icicle-read-file-name'</span>
<span class="linecomment">;;  provides an example: file names that match ".+/$", that is,</span>
<span class="linecomment">;;  directory names, are highlighted as special candidates.  Function</span>
<span class="linecomment">;;  `icicle-read-color' provides another example (using the similar,</span>
<span class="linecomment">;;  but internal, variable `icicle-proxy-candidate-regexp'): proxy</span>
<span class="linecomment">;;  color-name candidates such as `*point foreground*' and</span>
<span class="linecomment">;;  `'icicle-region-background'' are highlighted, but not their color</span>
<span class="linecomment">;;  swatches.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Property icicle-special-candidate")</span>
<span class="linecomment">;;  ** Using Property icicle-special-candidate **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In this approach, you use the desired list of text properties as</span>
<span class="linecomment">;;  the value of property `icicle-special-candidate' for the symbol</span>
<span class="linecomment">;;  that represents the candidate.  This method affects the candidates</span>
<span class="linecomment">;;  that are used during completion, as well as the completion return</span>
<span class="linecomment">;;  value.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the candidate is a string, not a symbol, then `intern' it and</span>
<span class="linecomment">;;  put the property on the resulting symbol.  If you want the effect</span>
<span class="linecomment">;;  to be temporary, then set property `icicle-special-candidate' for</span>
<span class="linecomment">;;  the candidate to `nil' when completion is finished.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a shortcut, if you use the value `t' instead of a property list</span>
<span class="linecomment">;;  for property `icicle-special-candidate', then face</span>
<span class="linecomment">;;  `icicle-special-candidate' will be used as the `face' property of</span>
<span class="linecomment">;;  the candidate.  Using a value of `t' is thus equivalent to using a</span>
<span class="linecomment">;;  value of (face icicle-special-candidate).  This approach is used,</span>
<span class="linecomment">;;  for instance, in the definition of command `icicle-complete-keys'</span>
<span class="linecomment">;;  (`S-TAB').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using Property `icicle-display-string'")</span>
<span class="linecomment">;;  ** Using Property `icicle-display-string' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This method is similar to that of using property</span>
<span class="linecomment">;;  `icicle-special-candidate'.  The use case for both is</span>
<span class="linecomment">;;  propertizing, in a general way, candidates that are symbols.  Both</span>
<span class="linecomment">;;  can be useful when you have an obarray as the COLLECTION argument</span>
<span class="linecomment">;;  for `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In this method the symbol name is not used at all; the candidate</span>
<span class="linecomment">;;  is entirely replaced by another string, which is typically</span>
<span class="linecomment">;;  propertized.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You use a propertized string as the value of property</span>
<span class="linecomment">;;  `icicle-display-string' for the candidate symbol.  The propertized</span>
<span class="linecomment">;;  string is displayed in `*Completions*' and returned as the final</span>
<span class="linecomment">;;  completion choice.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that multi-completion is not available when you use an</span>
<span class="linecomment">;;  obarray.  Using property `icicle-special-candidate' or</span>
<span class="linecomment">;;  `icicle-display-string' you can propertize candidates and parts of</span>
<span class="linecomment">;;  candidates, but you cannot manipulate multi-completion parts and</span>
<span class="linecomment">;;  there are no join or end strings.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Applying Text Properties to a Candidate String")</span>
<span class="linecomment">;;  ** Applying Text Properties to a Candidate String **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is the most flexible approach, and it is explained in a bit</span>
<span class="linecomment">;;  more detail.  It can be used with multi-completions, and it</span>
<span class="linecomment">;;  affects the `*Completions*' display and the completion return</span>
<span class="linecomment">;;  value.  However, it is limited to using an alist or list of</span>
<span class="linecomment">;;  strings, not an obarray, as the COLLECTION argument to</span>
<span class="linecomment">;;  `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In this approach, you simply apply the text properties to the</span>
<span class="linecomment">;;  string(s) that represent the candidate, which you then pass to</span>
<span class="linecomment">;;  `completing-read' in its COLLECTION parameter.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As with the other methods, you can use any text properties you</span>
<span class="linecomment">;;  like, including these:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `face' - to make some completion candidates stand out in</span>
<span class="linecomment">;;    particular ways</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-mode-line-help' - candidate help shown in the mode-line</span>
<span class="linecomment">;;    when the candidate is current, provided option</span>
<span class="linecomment">;;    `icicle-help-in-mode-line-delay' is greater than zero (only the</span>
<span class="linecomment">;;    first character of a candidate string is tested for this text</span>
<span class="linecomment">;;    property)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `help-echo' - candidate help shown in a mouseover tooltip,</span>
<span class="linecomment">;;    provided `tooltip-mode' is on</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `keymap' and `pointer' - for individualized mouse treatment of</span>
<span class="linecomment">;;    candidates</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `display' - to include images in candidates</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `invisible' - to hide part or all of particular candidates</span>
<span class="linecomment">;;    (which are nevertheless available for completion)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As a convenience, you can use function</span>
<span class="linecomment">;;  `icicle-candidate-short-help' to apply both</span>
<span class="linecomment">;;  `icicle-mode-line-help' and `help-echo' text properties to a</span>
<span class="linecomment">;;  candidate string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  How does this work?  Icicles redefines the standard Emacs function</span>
<span class="linecomment">;;  `display-completion-list' so that it retains text properties.</span>
<span class="linecomment">;;  Emacs should do the same, but it does not (yet).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles command `icicle-read-color' presents an illustration,</span>
<span class="linecomment">;;  using the `face' property.  (It also uses properties</span>
<span class="linecomment">;;  `icicle-mode-line-help' and `help-echo', to provide RGB and HSV</span>
<span class="linecomment">;;  information in the mode-line and via tooltip.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In `icicle-read-color', a multi-completion candidate is used,</span>
<span class="linecomment">;;  composed of an unpropertized string that names a color and a</span>
<span class="linecomment">;;  propertized string that names its RGB (red, green, blue) value.</span>
<span class="linecomment">;;  The RGB string, by default, has a background of the same color -</span>
<span class="linecomment">;;  each completion candidate is thus accompanied by its own color</span>
<span class="linecomment">;;  swatch.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The code that does this is function `icicle-make-color-candidate',</span>
<span class="linecomment">;;  which is used by `icicle-read-color' and other Icicles commands</span>
<span class="linecomment">;;  that read colors.  Here is a simplified definition:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (defun icicle-make-color-candidate (color-name)</span>
<span class="linecomment">;;     "Return candidate of COLOR-NAME and its hex RGB string.</span>
<span class="linecomment">;;   If `icicle-WYSIWYG-Completions-flag' is non-nil, then the hex RGB</span>
<span class="linecomment">;;   string has the color as its background text property."</span>
<span class="linecomment">;;     (let ((rgb-string  (hexrgb-color-name-to-hex color-name)))</span>
<span class="linecomment">;;       (when icicle-WYSIWYG-Completions-flag</span>
<span class="linecomment">;;         (put-text-property</span>
<span class="linecomment">;;           0 (length rgb-string) 'face</span>
<span class="linecomment">;;           (cons 'background-color rgb-string) rgb-string))</span>
<span class="linecomment">;;       (list (list color-name rgb-string))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You'll notice that the face property is added only when option</span>
<span class="linecomment">;;  `icicle-WYSIWYG-Completions-flag' is non-`nil'.  You can toggle</span>
<span class="linecomment">;;  this option at any time during completion to change the behavior.</span>
<span class="linecomment">;;  (The new value takes effect for the next act of completion.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can match any part of the multi-completion: color name or RGB</span>
<span class="linecomment">;;  value.  Command `icicle-read-color' defines a set of sort orders</span>
<span class="linecomment">;;  that are pertinent to the color candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can use `C-,' to sort by color name, amount of red, blue,</span>
<span class="linecomment">;;  green, all RGB components (in order), RGB distance from a base</span>
<span class="linecomment">;;  color, hue, saturation, value, all HSV components (in order), or</span>
<span class="linecomment">;;  HSV distance from a base color.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If option `icicle-add-proxy-candidates-flag' is non-`nil', then</span>
<span class="linecomment">;;  command `icicle-read-color' includes proxy completion candidates</span>
<span class="linecomment">;;  that are not color-name-and-RGB pairs.  As always, you can toggle</span>
<span class="linecomment">;;  the use of proxy candidates using `C-M-_' in the minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The proxy candidates for colors include the single-quoted names of</span>
<span class="linecomment">;;  user options (variables) whose custom type is `color'.  So, for</span>
<span class="linecomment">;;  example, option `icicle-region-background' appears as proxy color</span>
<span class="linecomment">;;  candidate `'icicle-region-background''. Color proxies also include</span>
<span class="linecomment">;;  the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `*copied foreground*'  - last copied foreground, if available</span>
<span class="linecomment">;;  * `*copied background*'  - last copied background, if available</span>
<span class="linecomment">;;  * `*mouse-2 foreground*' - foreground where you click `mouse-2'</span>
<span class="linecomment">;;  * `*mouse-2 background*' - background where you click `mouse-2'</span>
<span class="linecomment">;;  * `*point foreground*'   - foreground under the text cursor</span>
<span class="linecomment">;;  * `*point background*'   - background under the text cursor</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you choose a proxy color candidates, the color referred to is</span>
<span class="linecomment">;;  used.  For example, `*point foreground*' means to use the</span>
<span class="linecomment">;;  foreground color at the cursor position (point), whatever it might</span>
<span class="linecomment">;;  be.  Choosing a `mouse-2' candidate lets you then click `mouse-2'</span>
<span class="linecomment">;;  to pick up a color somewhere.  If you use library `palette.el' or</span>
<span class="linecomment">;;  `eyedropper.el', and you have already copied a color, then you can</span>
<span class="linecomment">;;  choose `*copied foreground*' (or background) to use that color.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles treats reading face names similarly to reading colors, by</span>
<span class="linecomment">;;  redefining standard function `read-face-name' when you are in</span>
<span class="linecomment">;;  Icicle mode.  In this case, multi-completions are not used.  The</span>
<span class="linecomment">;;  pertinent function is `icicle-make-face-candidate', which provides</span>
<span class="linecomment">;;  a WYSIWYG face sample whenever `icicle-WYSIWYG-Completions-flag'</span>
<span class="linecomment">;;  is non-`nil'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A string value for `icicle-WYSIWYG-Completions-flag' presents the</span>
<span class="linecomment">;;  face name accompanied by that string as a separate sample swatch.</span>
<span class="linecomment">;;  A value of `t' presents the face name itself in the face it names.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (defun icicle-make-face-candidate (face)</span>
<span class="linecomment">;;     "Return a completion candidate for FACE.</span>
<span class="linecomment">;;   The value of option `icicle-WYSIWYG-Completions-flag' determines</span>
<span class="linecomment">;;   the kind of candidate to use.</span>
<span class="linecomment">;;    If nil, then the face name is used (a string).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If a string, then a multi-completion candidate is used, with the</span>
<span class="linecomment">;;    face name followed by a sample swatch using FACE on the string's</span>
<span class="linecomment">;;    text.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    If `t', then the candidate is the face name itself, propertized</span>
<span class="linecomment">;;    with FACE."</span>
<span class="linecomment">;;     (if (stringp icicle-WYSIWYG-Completions-flag)</span>
<span class="linecomment">;;         (let ((swatch  (copy-sequence</span>
<span class="linecomment">;;                         icicle-WYSIWYG-Completions-flag)))</span>
<span class="linecomment">;;           (put-text-property</span>
<span class="linecomment">;;            0 (length icicle-WYSIWYG-Completions-flag)</span>
<span class="linecomment">;;            'face face swatch)</span>
<span class="linecomment">;;           (list (list (symbol-name face) swatch)))</span>
<span class="linecomment">;;       (let ((face-name  (copy-sequence (symbol-name face))))</span>
<span class="linecomment">;;         (when icicle-WYSIWYG-Completions-flag</span>
<span class="linecomment">;;           (put-text-property 0 (length face-name)</span>
<span class="linecomment">;;                              'face face face-name))</span>
<span class="linecomment">;;         (list face-name))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Programming with Fancy Candidates")</span>
<span class="linecomment">;;  * (@&gt; "Programming Multi-Completions")</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Sorting Candidates and Removing Duplicates")</span>
<span class="linecomment">;;    for information about changing sort orders.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "*Completions* Display") for</span>
<span class="linecomment">;;    more about proxy candidates.</span>
 
<span class="linecomment">;;(@* "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Icicles Commands (Including Multi-Commands)</span>
<span class="linecomment">;;  ----------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Nothing To It!")</span>
<span class="linecomment">;;  ** Nothing To It! **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining a command that uses Icicles completion and cycling is</span>
<span class="linecomment">;;  simple: just call `completing-read' or `read-file-name' to read</span>
<span class="linecomment">;;  input, then act on that input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Nothing could be simpler - just use `completing-read'or</span>
<span class="linecomment">;;  `read-file-name'!  Icicles does the rest.  This is the most</span>
<span class="linecomment">;;  important thing to learn about defining Icicles commands: you do</span>
<span class="linecomment">;;  not need to do anything except call `completing-read' or</span>
<span class="linecomment">;;  `read-file-name' as you would normally anyway.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Or at least as I HOPE you would normally.  I fear that many</span>
<span class="linecomment">;;  Emacs-Lisp programmers do not take sufficient advantage of</span>
<span class="linecomment">;;  `completing-read' when they could, using instead a function such</span>
<span class="linecomment">;;  as (quel horreur !)  `read-string' to read user input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Multi-Commands Are Easy To Define Too")</span>
<span class="linecomment">;;  ** Multi-Commands Are Easy To Define Too **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If defining an Icicles command is trivial, so is defining an</span>
<span class="linecomment">;;  Icicles multi-command.  For the same effort it takes to define a</span>
<span class="linecomment">;;  command that acts on a single input choice, you can have a command</span>
<span class="linecomment">;;  that acts on any number of input choices.  A multi-command takes</span>
<span class="linecomment">;;  advantage of one or more action functions when cycling candidates,</span>
<span class="linecomment">;;  as described in sections</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands"),</span>
<span class="linecomment">;;  (@&gt; "More about Multi-Commands"), and</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Choose All Completion Candidates").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In fact, there is no reason NOT to define your commands as</span>
<span class="linecomment">;;  multi-commands - you lose nothing, and you gain a lot.  Whenever</span>
<span class="linecomment">;;  it is appropriate for a user to possibly want to act on multiple</span>
<span class="linecomment">;;  objects, define a multi-command that does that.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  An anecdote, to make the point.  An Icicles user sent me an email</span>
<span class="linecomment">;;  saying how much he appreciated Icicles multi-commands, and asking</span>
<span class="linecomment">;;  if I would add a multi-command version of `insert-buffer'.  I did</span>
<span class="linecomment">;;  so, but I replied to him that the definition is trivial: it is</span>
<span class="linecomment">;;  identical to the definition of `icicle-buffer', except that the</span>
<span class="linecomment">;;  action function is `insert-buffer' instead of `switch-to-buffer'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The point is to not be afraid of defining multi-commands yourself.</span>
<span class="linecomment">;;  You do not really need to have me add a multi-command to Icicles</span>
<span class="linecomment">;;  in most cases; you can easily define it yourself.  Here is a</span>
<span class="linecomment">;;  simple definition of `icicle-insert-buffer'.  You will understand</span>
<span class="linecomment">;;  it in detail after reading the next section.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (icicle-define-command icicle-insert-buffer</span>
<span class="linecomment">;;     "Multi-command version of `insert-buffer'." ; Doc string</span>
<span class="linecomment">;;     insert-buffer                               ;  Action function</span>
<span class="linecomment">;;     "Buffer: "                            ; `completing-read' args</span>
<span class="linecomment">;;     (mapcar #'(lambda (buf) (list (buffer-name buf))) (buffer-list))</span>
<span class="linecomment">;;     nil t nil 'buffer-name-history (icicle-default-buffer-names) nil)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Macros `icicle-define-command' and `icicle-define-file-command'</span>
<span class="linecomment">;;  make it easy to define a multi-command.  Without them, it is</span>
<span class="linecomment">;;  sometimes not so easy, depending on the complexity of your action</span>
<span class="linecomment">;;  functions.  See (@&gt; "Defining Multi-Commands the Hard Way") for a</span>
<span class="linecomment">;;  taste of what is involved.  If you read that section first, make</span>
<span class="linecomment">;;  sure you come back here to see how easy things can be.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here is how you might define a multi-command to delete one or more</span>
<span class="linecomment">;;  files or directories:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Define the multi-command, `my-delete-file':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (icicle-define-file-command</span>
<span class="linecomment">;;   my-delete-file                  ; Command name</span>
<span class="linecomment">;;   "Delete a file or directory."   ; Doc string</span>
<span class="linecomment">;;   my-delete-file-or-directory     ; Function to perform the action</span>
<span class="linecomment">;;   "Delete file or directory: "    ; `read-file-name' arguments...</span>
<span class="linecomment">;;   default-directory nil t)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Define the action function that deletes a single file:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun my-delete-file-or-directory (file)</span>
<span class="linecomment">;;    "Delete file (or directory) FILE."</span>
<span class="linecomment">;;    (condition-case i-delete-file</span>
<span class="linecomment">;;        (if (eq t (car (file-attributes file)))</span>
<span class="linecomment">;;            (delete-directory file)</span>
<span class="linecomment">;;          (delete-file file))</span>
<span class="linecomment">;;      (error (message (error-message-string i-delete-file))</span>
<span class="linecomment">;;             (error (error-message-string i-delete-file)))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are two parts to the definition of `my-delete-file':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. The definition of the command itself, using</span>
<span class="linecomment">;;     `icicle-define-file-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. The definition of an action function,</span>
<span class="linecomment">;;     `my-delete-file-or-directory', which deletes a single file (or</span>
<span class="linecomment">;;     directory), given its name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It is #1 that is of interest here, because that is essentially</span>
<span class="linecomment">;;  what you do to define any multi-command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The details of #2 are less interesting, even if more complex in</span>
<span class="linecomment">;;  this case: `my-delete-file-or-directory' checks whether its</span>
<span class="linecomment">;;  argument is a file or directory, and then tries to delete it.  If</span>
<span class="linecomment">;;  an error occurs, it prints the error message and then returns the</span>
<span class="linecomment">;;  message, so that the calling command can report on all deletion</span>
<span class="linecomment">;;  errors.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In #1, the arguments to `icicle-define-file-command' are</span>
<span class="linecomment">;;  straightforward:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The name of the command being defined `my-delete-file'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Its doc string.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The function that actually performs the action on the input file</span>
<span class="linecomment">;;    name - `my-delete-file-or-directory'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * The arguments that you would supply anyway to `read-file-name'</span>
<span class="linecomment">;;    to read a single file name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These are the SAME things you would need if you were defining a</span>
<span class="linecomment">;;  simple command to delete a SINGLE file or directory.  The only</span>
<span class="linecomment">;;  differences here are that you:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Use `icicle-define-file-command' instead of `defun' with an</span>
<span class="linecomment">;;    `interactive' spec.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Separate the action code into a separate function (here,</span>
<span class="linecomment">;;    `my-delete-file-or-directory') that acts on a single object</span>
<span class="linecomment">;;    (here, a file).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you use `icicle-define-file-command', the action function is</span>
<span class="linecomment">;;  called on the result of `read-file-name', and it is also bound to</span>
<span class="linecomment">;;  `icicle-candidate-action-fn', so that it will be applied to the</span>
<span class="linecomment">;;  current candidate via `C-RET' or `C-mouse-2'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command `icicle-all-candidates-action' (`C-!' -- see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Choose All Completion Candidates"))</span>
<span class="linecomment">;;  can report in buffer `*Help*' on the objects that it did not act</span>
<span class="linecomment">;;  upon successfully.  For this reporting to work, the function bound</span>
<span class="linecomment">;;  to `icicle-candidate-action-fn'</span>
<span class="linecomment">;;  (e.g. `my-delete-file-or-directory', above) should return `nil'</span>
<span class="linecomment">;;  for "success" and non-`nil' (for example, an error message) for</span>
<span class="linecomment">;;  "failure", whatever "success" and "failure" might mean in the</span>
<span class="linecomment">;;  particular context of use.  This is not a requirement, except if</span>
<span class="linecomment">;;  you want to take advantage of such reporting.  For a command that</span>
<span class="linecomment">;;  deletes files, it is important to let the user know which</span>
<span class="linecomment">;;  deletions failed when s?he tries to delete all matching candidates</span>
<span class="linecomment">;;  at once.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If the command you want to define acts on objects other than</span>
<span class="linecomment">;;  files, then use `icicle-define-command' instead of</span>
<span class="linecomment">;;  `icicle-define-file-command' - the only difference is that you</span>
<span class="linecomment">;;  then supply the arguments for `completing-read' instead of those</span>
<span class="linecomment">;;  for `read-file-name'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To let users know that a command is a multi-command, and how to</span>
<span class="linecomment">;;  use it as such, `icicle-define-command' and</span>
<span class="linecomment">;;  `icicle-define-file-command' automatically add this explanation to</span>
<span class="linecomment">;;  the doc string you provide for the multi-command:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  ---</span>
<span class="linecomment">;;  Read input, then call `&lt;your action function name&gt;' to act on it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Input-candidate completion and cycling are available.  While</span>
<span class="linecomment">;;  cycling, these keys with prefix `C-' are active:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `C-mouse-2', `C-RET' - Act on current completion candidate only</span>
<span class="linecomment">;;  `C-down', `C-wheel-down' - Move to next completion candidate and act</span>
<span class="linecomment">;;  `C-up', `C-wheel-up' - Move to previous completion candidate and act</span>
<span class="linecomment">;;  `C-next'  - Move to next apropos-completion candidate and act</span>
<span class="linecomment">;;  `C-prior' - Move to previous apropos-completion candidate and act</span>
<span class="linecomment">;;  `C-end'   - Move to next prefix-completion candidate and act</span>
<span class="linecomment">;;  `C-home'  - Move to previous prefix-completion candidate and act</span>
<span class="linecomment">;;  `C-!'    - Act on *all* candidates, successively (careful!)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When candidate action and cycling are combined (e.g. `C-next'), user</span>
<span class="linecomment">;;  option `icicle-act-before-cycle-flag' determines which occurs first.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  With prefix `C-M-' instead of `C-', the same keys (`C-M-mouse-2',</span>
<span class="linecomment">;;  `C-M-RET', `C-M-down', and so on) provide help about candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Use `mouse-2', `RET' or `S-RET' to finally choose a candidate, or</span>
<span class="linecomment">;;  `C-g' to quit.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This is an Icicles command - see `icicle-mode'.</span>
<span class="linecomment">;;  ---</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Notice that the doc string of your new multi-command references</span>
<span class="linecomment">;;  your action function (e.g. `my-delete-file-or-directory').  The</span>
<span class="linecomment">;;  doc string you provide for the multi-command can thus be a little</span>
<span class="linecomment">;;  more abstract, leaving any detailed explanation of the action to</span>
<span class="linecomment">;;  the doc string of your action function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To provide more flexibility, `icicle-define-command' and</span>
<span class="linecomment">;;  `icicle-define-file-command' provide some predefined key bindings</span>
<span class="linecomment">;;  and allow for additional arguments.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here is a definition of a multi-command, `change-font', that reads</span>
<span class="linecomment">;;  a font name and changes the selected frame to use that font.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1  (icicle-define-command</span>
<span class="linecomment">;;  2   change-font "Change font of current frame."</span>
<span class="linecomment">;;  3   (lambda (font)</span>
<span class="linecomment">;;  4     (modify-frame-parameters orig-frame</span>
<span class="linecomment">;;  5                              (list (cons 'font font))))</span>
<span class="linecomment">;;  6   "Font: " (mapcar #'list (x-list-fonts "*"))</span>
<span class="linecomment">;;  7   nil t nil nil nil nil</span>
<span class="linecomment">;;  8   ((orig-frame  (selected-frame))</span>
<span class="linecomment">;;  9    (orig-font   (frame-parameter nil 'font)))</span>
<span class="linecomment">;;  10  nil</span>
<span class="linecomment">;;  11  (modify-frame-parameters orig-frame</span>
<span class="linecomment">;;  12                           (list (cons 'font orig-font)))</span>
<span class="linecomment">;;  13  nil)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The arguments to `icicle-define-command' here are as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Command name    (line 2)</span>
<span class="linecomment">;;  Doc string      (line 2)</span>
<span class="linecomment">;;  Action function (lines 3-5)</span>
<span class="linecomment">;;  Args passed to `completing-read' (lines 6-7)</span>
<span class="linecomment">;;  Additional bindings (lines 8-9)</span>
<span class="linecomment">;;  Additional initialization code (line 10)</span>
<span class="linecomment">;;  "Undo" code to run in case of error or user quit (lines 11-12)</span>
<span class="linecomment">;;  Additional code to run at the end (line 13)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The following bindings are predefined - you can refer to them in</span>
<span class="linecomment">;;  the command body:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   `icicle-orig-buff'   is bound to (current-buffer)</span>
<span class="linecomment">;;   `icicle-orig-window' is bound to (selected-window)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Before running any "undo" code that you supply, the original</span>
<span class="linecomment">;;  buffer is restored, in case of error or user quit (`C-g').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Most of the arguments to `icicle-define-command' are optional.  In</span>
<span class="linecomment">;;  this case, optional arguments were provided to save (lines 8-9)</span>
<span class="linecomment">;;  and then restore (lines 11-12) the original font and frame.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Several top-level Icicles commands have been defined using</span>
<span class="linecomment">;;  `icicle-define-command' and `icicle-define-file-command'.  You can</span>
<span class="linecomment">;;  use their definitions as models for your own multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `clear-option' (alias) - Set value of binary option to `nil'</span>
<span class="linecomment">;;  `icicle-add-buffer-candidate' - Add buffer to those always shown</span>
<span class="linecomment">;;  `icicle-add-buffer-config' - Add to `icicle-buffer-configs'</span>
<span class="linecomment">;;  `icicle-bookmark'     - Jump to a bookmark</span>
<span class="linecomment">;;  `icicle-bookmark-bookmark-list-*' - Jump: bookmark-list bookmark</span>
<span class="linecomment">;;  `icicle-bookmark-desktop-*' - Jump: bookmarked desktop</span>
<span class="linecomment">;;  `icicle-bookmark-dired-*' - Jump: bookmarked Dired state</span>
<span class="linecomment">;;  `icicle-bookmark-file-*' - Jump: bookmarked file</span>
<span class="linecomment">;;  `icicle-bookmark-gnus-*' - Jump: bookmarked Gnus message</span>
<span class="linecomment">;;  `icicle-bookmark-info-*' - Jump: bookmarked Info node</span>
<span class="linecomment">;;  `icicle-bookmark-list' - Choose a list of bookmark names</span>
<span class="linecomment">;;  `icicle-bookmark-local-file-*' - Jump: bookmarked local file</span>
<span class="linecomment">;;  `icicle-bookmark-man-*' - Jump: bookmarked `man' page</span>
<span class="linecomment">;;  `icicle-bookmark-non-file-*' - Jump: bookmarked buffer</span>
<span class="linecomment">;;  `icicle-bookmark-region-*' - Jump: bookmarked region</span>
<span class="linecomment">;;  `icicle-bookmark-remote-file-*' - Jump: bookmarked remote file</span>
<span class="linecomment">;;  `icicle-bookmark-url-*' - Jump: bookmarked URL</span>
<span class="linecomment">;;  `icicle-buffer'       - Switch to another buffer</span>
<span class="linecomment">;;  `icicle-buffer-config' - Choose a config for buffer commands</span>
<span class="linecomment">;;  `icicle-buffer-list'  - Choose a list of buffer names</span>
<span class="linecomment">;;  `icicle-clear-history' - Clear entries from minibuffer histories</span>
<span class="linecomment">;;  `icicle-clear-current-history' - Clear current history entries</span>
<span class="linecomment">;;  `icicle-color-theme'  - Change color theme</span>
<span class="linecomment">;;  `icicle-comint-command' - Reuse a previous command in comint mode</span>
<span class="linecomment">;;  `icicle-command-abbrev' - Execute command or command abbreviation</span>
<span class="linecomment">;;  `icicle-command-abbrev-command' - Execute command from abbrev</span>
<span class="linecomment">;;  `icicle-completing-yank' - Yank text using completion</span>
<span class="linecomment">;;  `icicle-delete-file'  - Delete a file or directory</span>
<span class="linecomment">;;  `icicle-delete-windows' - Delete windows showing a buffer anywhere</span>
<span class="linecomment">;;  `icicle-describe-option-of-type' - Describe option of a given type</span>
<span class="linecomment">;;  `icicle-directory-list' - Choose a list of directory names</span>
<span class="linecomment">;;  `icicle-dired'        - Visit a directory in Dired mode</span>
<span class="linecomment">;;  `icicle-doc'          - Display doc of function, variable, or face</span>
<span class="linecomment">;;  `icicle-execute-extended-command' -</span>
<span class="linecomment">;;                          A multi-command version of `M-x'</span>
<span class="linecomment">;;  `icicle-execute-named-keyboard-macro' - Execute named kbd macro</span>
<span class="linecomment">;;  `icicle-face-list'    - Choose a list of face names</span>
<span class="linecomment">;;  `icicle-file-list'    - Choose a list of file names</span>
<span class="linecomment">;;  `icicle-file'         - Visit a file or directory</span>
<span class="linecomment">;;  `icicle-find-file'    - Visit a file or directory (relative)</span>
<span class="linecomment">;;  `icicle-find-file-absolute' - Visit a file (absolute)</span>
<span class="linecomment">;;  `icicle-find-file-in-tags-table' - Visit a file in a tags table</span>
<span class="linecomment">;;  `icicle-find-file-read-only' - Visit a file in read-only mode</span>
<span class="linecomment">;;  `icicle-find-first-tag' - Visit source-code definition with tag</span>
<span class="linecomment">;;  `icicle-font'         - Change the frame font</span>
<span class="linecomment">;;  `icicle-frame-bg'     - Change the frame background color</span>
<span class="linecomment">;;  `icicle-frame-fg'     - Change the frame foreground color</span>
<span class="linecomment">;;  `icicle-fundoc'       - Display the doc of a function</span>
<span class="linecomment">;;  `icicle-Info-menu'    - Go to an Info menu node</span>
<span class="linecomment">;;  `icicle-increment-option' - Increment option value using arrows</span>
<span class="linecomment">;;  `icicle-increment-variable' - Increment variable value</span>
<span class="linecomment">;;  `icicle-insert-buffer'- Insert a buffer</span>
<span class="linecomment">;;  `icicle-insert-thesaurus-entry' - Insert thesaurus entry</span>
<span class="linecomment">;;  `icicle-keyword-list' - Choose a list of keywords (regexps)</span>
<span class="linecomment">;;  `icicle-kill-buffer'  - Kill a buffer</span>
<span class="linecomment">;;  `icicle-kmacro'       - Execute a keyboard macro (Emacs 22+)</span>
<span class="linecomment">;;  `icicle-locate-file'  - Open a file located anywhere</span>
<span class="linecomment">;;  `icicle-plist'        - Choose a symbol and its property list</span>
<span class="linecomment">;;  `icicle-recent-file'  - Open a recently used file</span>
<span class="linecomment">;;  `icicle-remove-buffer-candidate' -</span>
<span class="linecomment">;;                          Remove buffer from those always shown</span>
<span class="linecomment">;;  `icicle-remove-buffer-config' -</span>
<span class="linecomment">;;                          Remove from `icicle-buffer-configs'</span>
<span class="linecomment">;;  `icicle-remove-file-from-recentf-list' - Remove from recent files</span>
<span class="linecomment">;;  `icicle-remove-saved-completion-set' - Remove a set from</span>
<span class="linecomment">;;                          `icicle-saved-completion-sets'</span>
<span class="linecomment">;;  `icicle-reset-option-to-nil' -</span>
<span class="linecomment">;;                          Set value of binary option to `nil'</span>
<span class="linecomment">;;  `icicle-search-bookmark' - Search a bookmark</span>
<span class="linecomment">;;  `icicle-search-bookmark-list-bookmark' - Bookmark-list bookmark</span>
<span class="linecomment">;;  `icicle-search-dired-bookmark' - Search a Dired bookmark</span>
<span class="linecomment">;;  `icicle-search-file-bookmark' - Search a bookmarked file</span>
<span class="linecomment">;;  `icicle-search-gnus-bookmark' - Search a bookmarked Gnus message</span>
<span class="linecomment">;;  `icicle-search-info-bookmark' - Search a bookmarked Info node</span>
<span class="linecomment">;;  `icicle-search-local-file-bookmark' - Search a local-file bookmark</span>
<span class="linecomment">;;  `icicle-search-man-bookmark' - Search a bookmarked `man' page</span>
<span class="linecomment">;;  `icicle-search-non-file-bookmark' - Search a bookmarked buffer</span>
<span class="linecomment">;;  `icicle-search-region-bookmark' - Search a bookmarked region</span>
<span class="linecomment">;;  `icicle-search-remote-file-bookmark' - Search a remote bookmark</span>
<span class="linecomment">;;  `icicle-search-url-bookmark' - Search a bookmarked URL</span>
<span class="linecomment">;;  `icicle-select-frame' - Select frame by name and raise it</span>
<span class="linecomment">;;  `icicle-select-window' - Select window by its buffer name</span>
<span class="linecomment">;;  `icicle-set-option-to-t' - Set the value of a binary option to `t'</span>
<span class="linecomment">;;  `icicle-toggle-option' - Toggle the value of a binary option</span>
<span class="linecomment">;;  `icicle-vardoc'       - Display the doc of a variable</span>
<span class="linecomment">;;  `icicle-where-is'     - Show key sequences that invoke a command</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For simplicity, the descriptions of these commands are singular</span>
<span class="linecomment">;;  actions (e.g. "kill a buffer"), but each of them can be used to</span>
<span class="linecomment">;;  act on any number of items any number of times (e.g. kill one or</span>
<span class="linecomment">;;  more buffers).  I recommend that you follow a similar naming</span>
<span class="linecomment">;;  convention - remember that the doc string will let users know that</span>
<span class="linecomment">;;  the command can be used on multiple objects.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Macros `icicle-define-command' and `icicle-define-file-command'</span>
<span class="linecomment">;;  define a multi-command in a simple way.  Sometimes you will need a</span>
<span class="linecomment">;;  little more flexibility.  In that case, you can use higher-order</span>
<span class="linecomment">;;  functions `icicle-explore' and `icicle-apply' to define a</span>
<span class="linecomment">;;  multi-command.  See (@&gt; "Defining Icicles Tripping Commands").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Are Users Dependent on Icicles To Use Multi-Commands?")</span>
<span class="linecomment">;;  ** Are Users Dependent on Icicles To Use Multi-Commands? **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For users to be able to take advantage of the Icicles features</span>
<span class="linecomment">;;  that your multi-command provides, they must load Icicles.  You can</span>
<span class="linecomment">;;  do this for them, by adding (require 'icicles nil t) to your code.</span>
<span class="linecomment">;;  The last two arguments mean that no error will be raised if for</span>
<span class="linecomment">;;  some reason Icicles cannot be found or successfully loaded.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  But that brings up another question: What happens to your</span>
<span class="linecomment">;;  multi-command if Icicles is not available for a user, or s?he does</span>
<span class="linecomment">;;  not want to load it?  No problem - your multi-command then</span>
<span class="linecomment">;;  automatically turns into a normal, single-choice command -</span>
<span class="linecomment">;;  graceful degradation.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similarly, users can always turn off `icicle-mode' at any time, to</span>
<span class="linecomment">;;  return to the standard Emacs behavior.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Users will, in any case, need to load Icicles at compile time, in</span>
<span class="linecomment">;;  order to byte-compile your library that calls macro</span>
<span class="linecomment">;;  `icicle-define-command' or `icicle-define-file-command' - either</span>
<span class="linecomment">;;  that, or you can duplicate the definition of the macro in your</span>
<span class="linecomment">;;  library.  To let users load Icicles at (only) compile time, add</span>
<span class="linecomment">;;  this to your library that defines multi-commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (eval-when-compile '(require icicles))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Icicles Tripping Commands") for how to use</span>
<span class="linecomment">;;    `icicle-apply' and `icicle-explore' to define browsing commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Multiple-Choice Menus").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Note to Programmers") for further programming guidelines.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `synonyms.el', which uses `icicle-define-command' to</span>
<span class="linecomment">;;    define command `synonyms'.  This command lets you use Icicles</span>
<span class="linecomment">;;    completion on input regexps when you search a thesaurus.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `palette.el', which uses `icicle-define-command' to</span>
<span class="linecomment">;;    define command `palette-pick-color-by-name-multi'.  This command</span>
<span class="linecomment">;;    lets you use Icicles completion on input regexps when you choose</span>
<span class="linecomment">;;    a palette color by name.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * Library `highlight.el', which uses `icicle-define-command' to</span>
<span class="linecomment">;;    defined commands `hlt-choose-faces', `hlt-choose-visible-faces',</span>
<span class="linecomment">;;    and `hlt-choose-invisible-faces'.  These commands let you choose</span>
<span class="linecomment">;;    a set of faces.</span>
 
<span class="linecomment">;;(@* "Defining Icicles Tripping Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Icicles Tripping Commands</span>
<span class="linecomment">;;  ----------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Section (@file :file-name "icicles-doc1.el" :to "Icicles Tripping")</span>
<span class="linecomment">;;  describes the use of Icicles tripping (aka navigation or browsing)</span>
<span class="linecomment">;;  multi-commands.  This section tells you how to define your own</span>
<span class="linecomment">;;  such commands for custom trips - it is thus for Emacs-Lisp</span>
<span class="linecomment">;;  programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The best way to learn how to do this is to look at how the</span>
<span class="linecomment">;;  existing tripping commands are defined.  Some of them use macro</span>
<span class="linecomment">;;  `icicle-define-command'; others do not.  Some use the</span>
<span class="linecomment">;;  building-block functions `icicle-explore' or `icicle-apply';</span>
<span class="linecomment">;;  others do not.  Several use `icicle-search' as a building block.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using `icicle-define-command'")</span>
<span class="linecomment">;;  ** Using `icicle-define-command' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Those that use `icicle-define-command' take advantage of some</span>
<span class="linecomment">;;  extraneous way to obtain trip location information from a display</span>
<span class="linecomment">;;  candidate, which is just a string.  For example, `icicle-bookmark'</span>
<span class="linecomment">;;  ultimately uses the display string to look up location information</span>
<span class="linecomment">;;  in a bookmarks file.  Those that use `icicle-explore' or</span>
<span class="linecomment">;;  `icicle-apply' make use of location information stored in the</span>
<span class="linecomment">;;  alist COLLECTION argument to `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can also use `icicle-define-command', `icicle-explore', and</span>
<span class="linecomment">;;  `icicle-apply' to define multi-commands other than browsing</span>
<span class="linecomment">;;  commands - the action function can do anything you like.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using `icicle-explore'")</span>
<span class="linecomment">;;  ** Using `icicle-explore' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-explore' is a higher-order function that takes as</span>
<span class="linecomment">;;  arguments the following functions, in addition to accepting</span>
<span class="linecomment">;;  the optional `completing-read' arguments.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function to build a candidates alist (COLLECTION) for</span>
<span class="linecomment">;;    completion.  It fills `icicle-candidates-alist' with the</span>
<span class="linecomment">;;    candidates, each of which is a cons with a display candidate</span>
<span class="linecomment">;;    string as car and (typically) location information as cdr.  For</span>
<span class="linecomment">;;    example, `icicle-find-tag' uses the tag text as display</span>
<span class="linecomment">;;    candidate and the standard tag-locating information as the cdr:</span>
<span class="linecomment">;;    tag info, file path, and goto function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function that acts on the candidate finally chosen (`RET'),</span>
<span class="linecomment">;;    when completion is finished.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function to call if the user hits `C-g' during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function to call if an error is raised during completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * A function to call after completion is finished, to clean things</span>
<span class="linecomment">;;    up.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you also bind `icicle-candidate-action-fn' to a function that</span>
<span class="linecomment">;;  takes a display candidate (string) as argument and navigates to</span>
<span class="linecomment">;;  the corresponding location, then `icicle-explore' does everything</span>
<span class="linecomment">;;  you need for an Icicles trip.  You can use function</span>
<span class="linecomment">;;  `icicle-get-alist-candidate' to get the location information for a</span>
<span class="linecomment">;;  given display candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using `icicle-apply'")</span>
<span class="linecomment">;;  ** Using `icicle-apply' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-apply' binds `icicle-candidate-action-fn' appropriately</span>
<span class="linecomment">;;  and calls `icicle-explore'.  It applies its function argument to</span>
<span class="linecomment">;;  completion candidates the user acts on (using `C-RET' etc.).  It</span>
<span class="linecomment">;;  applies the function to the full alist entry, that is, the display</span>
<span class="linecomment">;;  candidate car plus any additional information in the cdr.  For a</span>
<span class="linecomment">;;  tripping command, the additional information provides a location</span>
<span class="linecomment">;;  and the function applied takes you there.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This use of an alist that stores location information in the cdrs</span>
<span class="linecomment">;;  is what makes `icicle-apply' and `icicle-explore' particularly</span>
<span class="linecomment">;;  suitable for defining navigation multi-commands.  The Icicles</span>
<span class="linecomment">;;  macros `icicle-define-command' and `icicle-define-file-command'</span>
<span class="linecomment">;;  make no such provision, but with suitable arguments you can use</span>
<span class="linecomment">;;  them too to define tripping commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Using `icicle-search'")</span>
<span class="linecomment">;;  ** Using `icicle-search' **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  `icicle-search' is another high-level function for defining</span>
<span class="linecomment">;;  tripping commands.  Like `icicle-apply', it calls</span>
<span class="linecomment">;;  `icicle-explore', but it also provides features for searching</span>
<span class="linecomment">;;  bookmarks, buffers, and files.  It takes as arguments the search</span>
<span class="linecomment">;;  limits (region), if any, and either a regexp or a function that</span>
<span class="linecomment">;;  determines the unfiltered search hits.  It does everything else</span>
<span class="linecomment">;;  needed to define a trip command that uses search hits as</span>
<span class="linecomment">;;  completion candidates.  Several predefined Icicles tripping</span>
<span class="linecomment">;;  commands were defined using `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "Tripping on Foot")</span>
<span class="linecomment">;;  ** Tripping on Foot **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You should be able to define any tripping commands you need using</span>
<span class="linecomment">;;  `icicle-explore', `icicle-apply', or `icicle-search'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If, however, for some reason you decide to define one at a lower,</span>
<span class="linecomment">;;  pedestrian level (that is, without using any of those building</span>
<span class="linecomment">;;  blocks), then bind `icicle-whole-candidate-as-text-prop-p' to `t'</span>
<span class="linecomment">;;  around the call to `completing-read'.  You can then use</span>
<span class="linecomment">;;  `icicle-get-alist-candidate' to retrieve the candidate cdr</span>
<span class="linecomment">;;  (e.g. location) information from the completion result.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  However, if the action or alternate action function that you need</span>
<span class="linecomment">;;  modifies the existing set of completion candidates on the fly, as</span>
<span class="linecomment">;;  a side effect, then bind `icicle-whole-candidate-as-text-prop-p'</span>
<span class="linecomment">;;  to `nil' in the action function.  Then modify both</span>
<span class="linecomment">;;  `minibuffer-completion-table' and `icicle-candidates-alist' as</span>
<span class="linecomment">;;  needed to perform the side effect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles search-and-replace provides an example of this.  When you</span>
<span class="linecomment">;;  replace text, the original domain of search-hit candidates (with</span>
<span class="linecomment">;;  their associated location information) is altered, so that you can</span>
<span class="linecomment">;;  continue replacing coherently.  (See the code for</span>
<span class="linecomment">;;  `icicle-search-action' and</span>
<span class="linecomment">;;  `icicle-search-highlight-and-maybe-replace'.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Because such side effects can change the meaning of cycling state</span>
<span class="linecomment">;;  information such as the current candidate number, Icicles does not</span>
<span class="linecomment">;;  automatically save such state information before a candidate</span>
<span class="linecomment">;;  action and then restore it afterward.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, search-and-replace removes a search-hit candidate, as</span>
<span class="linecomment">;;  a side effect, if the replacement text no longer matches your</span>
<span class="linecomment">;;  input.  In that case, a current candidate number recorded before</span>
<span class="linecomment">;;  the action would no longer correspond to the same candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For this reason, if your action function does not perform any such</span>
<span class="linecomment">;;  side effects on the candidates, and you want to restore the</span>
<span class="linecomment">;;  cycling state as it was before a candidate action, then you might</span>
<span class="linecomment">;;  want your action function to save and then restore the values of</span>
<span class="linecomment">;;  Icicles variables such as `icicle-candidate-nb',</span>
<span class="linecomment">;;  `icicle-last-completion-candidate', and</span>
<span class="linecomment">;;  `icicle-completion-candidates'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Icicles Tripping")</span>
<span class="linecomment">;;    for information about using Icicles Trip commands</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;    for general information about defining multi-commands</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Programming with Fancy Candidates") for information about</span>
<span class="linecomment">;;    `icicle-whole-candidate-as-text-prop-p'</span>
 
<span class="linecomment">;;(@* "Defining Multiple-Choice Menus")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Multiple-Choice Menus</span>
<span class="linecomment">;;  ------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles multi-commands (see</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Multi-Commands")) can be</span>
<span class="linecomment">;;  used provide users with multiple-choice menus.  While the possible</span>
<span class="linecomment">;;  choices can be accessed by minibuffer completion or cycling, a</span>
<span class="linecomment">;;  user can also display them in buffer `*Completions*' using `TAB'</span>
<span class="linecomment">;;  or `S-TAB', and click them there to choose them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That is, buffer `*Completions*' can act as a multiple-choice menu.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Simple use case: Suppose that you use special characters (Greek</span>
<span class="linecomment">;;  letters, math symbols, accented letters in another language...),</span>
<span class="linecomment">;;  but only occasionally - you do not want to take the trouble to</span>
<span class="linecomment">;;  learn a special input method for them or flip to a different soft</span>
<span class="linecomment">;;  keyboard.  One simple way to handle this is to create a menu of</span>
<span class="linecomment">;;  such special characters - Greek letters, for instance.  You only</span>
<span class="linecomment">;;  need to create the menu once, providing the necessary completions</span>
<span class="linecomment">;;  as, say, Unicode characters.  When you need to input such a</span>
<span class="linecomment">;;  character, just use your command that pops up buffer</span>
<span class="linecomment">;;  `*Completions*' with the available special characters.  Even if</span>
<span class="linecomment">;;  you do not know how to type them on your keyboard, you can cycle</span>
<span class="linecomment">;;  through them or use `mouse-2' to choose them.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's a simple example of defining a command that uses a</span>
<span class="linecomment">;;  multiple-choice menu.  (Other examples given above, such as</span>
<span class="linecomment">;;  `my-delete-file-or-directory' are also examples, but this one uses</span>
<span class="linecomment">;;  menu items that look more like menu items.)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (icicle-define-command my-menu-command</span>
<span class="linecomment">;;      "Display menu and act on choice(s)."</span>
<span class="linecomment">;;      my-menu-action</span>
<span class="linecomment">;;      "`TAB' for menu.  `C-mouse-2' to choose. "</span>
<span class="linecomment">;;      my-menu-items nil t)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defvar my-menu-items</span>
<span class="linecomment">;;    '(("Foobar" . foobar-fn) ("Toto" . toto-fn) ("Titi" . titi-fn))</span>
<span class="linecomment">;;    "Alist of menu items and their associated commands.")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun my-menu-action (item)</span>
<span class="linecomment">;;    "Call function associated with menu-item ITEM."</span>
<span class="linecomment">;;    (funcall (cdr (assoc item my-menu-items))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun foobar-fn () (message "Foobar chosen"))</span>
<span class="linecomment">;;  (defun toto-fn () (message "Toto chosen"))</span>
<span class="linecomment">;;  (defun titi-fn () (message "Titi chosen"))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A user does `M-x my-menu-command' and hits `TAB' to display this</span>
<span class="linecomment">;;  menu in the `*Completions*' buffer:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Click mouse-2 on a completion to select it.  (C-h: help)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Possible completions are:</span>
<span class="linecomment">;;  Foobar          Titi</span>
<span class="linecomment">;;  Toto</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The user presses and holds the Control key.  S?he clicks `Foobar'</span>
<span class="linecomment">;;  - message "Foobar chosen" appears.  S?he clicks `Toto - message</span>
<span class="linecomment">;;  "Toto chosen" appears.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And so on - all while holding Control pressed.  Any number of menu</span>
<span class="linecomment">;;  items can be chosen, any number of times.  The command is finally</span>
<span class="linecomment">;;  exited with `RET' or `C-g'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The COLLECTION argument passed to `completing-read' here is</span>
<span class="linecomment">;;  `my-menu-items', an alist of key-value pairs, where the key is a</span>
<span class="linecomment">;;  menu-item name and the value is the function that implements the</span>
<span class="linecomment">;;  menu item.  For example, menu item `Foobar' is implemented by</span>
<span class="linecomment">;;  function `foobar-fn', and the alist element is therefore ("Foobar"</span>
<span class="linecomment">;;  . foobar-fn).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Function `my-menu-action' is executed when a user clicks</span>
<span class="linecomment">;;  `C-mouse-2' on a menu item.  It just looks up the menu item's</span>
<span class="linecomment">;;  function in alist `my-menu-items', and then calls that function.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  What?  You think it's odd that the user must hit `TAB' to display</span>
<span class="linecomment">;;  the menu?  Then just use this code instead:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (icicle-define-command</span>
<span class="linecomment">;;   my-menu-command</span>
<span class="linecomment">;;   "Display menu and act on choice(s)."</span>
<span class="linecomment">;;   my-menu-action</span>
<span class="linecomment">;;   "`C-mouse-2' or `C-RET' to choose menu items"</span>
<span class="linecomment">;;   my-menu-items nil t nil nil nil nil</span>
<span class="linecomment">;;   ((icicle-show-Completions-initially-flag t)))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This just adds a binding for</span>
<span class="linecomment">;;  `icicle-show-Completions-initially-flag', so that `*Completions*'</span>
<span class="linecomment">;;  is displayed initially.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Granted, the `*Completions*' display does not exactly look like</span>
<span class="linecomment">;;  your average menu.  And the header line does not mention the</span>
<span class="linecomment">;;  multiple-choice possibility (holding Control while clicking).  But</span>
<span class="linecomment">;;  the header does say to use `C-h' for help, and that help does</span>
<span class="linecomment">;;  mention `C-mouse-2' (as does the prompt).  And the menu does act</span>
<span class="linecomment">;;  like a menu.  And the doc string of `my-menu-command' can provide</span>
<span class="linecomment">;;  more help, as needed.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are also some freebie advantages of using such menus,</span>
<span class="linecomment">;;  besides the feature of multiple-choice.  These include choosing</span>
<span class="linecomment">;;  menu items from the keyboard, with completion, and cycling among</span>
<span class="linecomment">;;  menu items.  The additional features are all explained when the</span>
<span class="linecomment">;;  user hits `C-?'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  One common use of a multiple-choice menu is letting the user</span>
<span class="linecomment">;;  select a list of items from a larger list of candidates.  The list</span>
<span class="linecomment">;;  is returned, with the items in the order selected.  Examples of</span>
<span class="linecomment">;;  this include these multi-commands:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-bookmark-list' - bookmark names</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-buffer-list' - buffer names, selected from `buffer-list'</span>
<span class="linecomment">;;    (possibly after filtering)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-directory-list' - directory names, selected from</span>
<span class="linecomment">;;    subdirectories in the current directory and any directories you</span>
<span class="linecomment">;;    navigate to</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-face-list' - face names, selected from `face-list'</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-file-list' - file names, selected from files in the</span>
<span class="linecomment">;;    current directory and any directories you navigate to</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `icicle-keyword-list' - keywords (regexps), selected from those</span>
<span class="linecomment">;;    you have previously entered</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `hlt-choose-faces', `hlt-choose-visible-faces',</span>
<span class="linecomment">;;    `hlt-choose-invisible-faces' - face names, selected from the</span>
<span class="linecomment">;;    (visible/invisible) highlighting faces in the buffer</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Such commands can be used on their own, or they can be used in the</span>
<span class="linecomment">;;  `interactive' specs of other commands that act on an entire list</span>
<span class="linecomment">;;  of selected items.  And do not forget that the set of "menu items"</span>
<span class="linecomment">;;  (completion candidates) is susceptible to sorting in various ways,</span>
<span class="linecomment">;;  as well as filtering in the usual ways: progressive completion,</span>
<span class="linecomment">;;  chipping away the non-elephant, and so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here as an example definition is `icicle-file-list':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (icicle-define-command icicle-file-list</span>
<span class="linecomment">;;     "Choose a list of file names.</span>
<span class="linecomment">;;   The list of names (strings) is returned."</span>
<span class="linecomment">;;     (lambda (name) (push name file-names))</span>
<span class="linecomment">;;     "Choose file (`RET' when done): "</span>
<span class="linecomment">;;     (mapcar #'list (directory-files default-directory nil</span>
<span class="linecomment">;;                                     icicle-re-no-dot))</span>
<span class="linecomment">;;     nil nil nil 'file-name-history nil nil</span>
<span class="linecomment">;;     ((file-names  ()))                    ; Additional bindings</span>
<span class="linecomment">;;     nil nil</span>
<span class="linecomment">;;     (prog1 (setq file-names (delete "" file-names)) ; Return list</span>
<span class="linecomment">;;       (when (interactive-p) (message "Files: %S" file-names))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc1.el" :to "Nutshell View of Icicles")</span>
<span class="linecomment">;;  for information about progressive completion and chipping away.</span>
 
<span class="linecomment">;;(@* "Defining Icicles Multi `M-x'")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Icicles Multi `M-x'</span>
<span class="linecomment">;;  ----------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.  It explains how the</span>
<span class="linecomment">;;  Icicles Multi `M-x' feature is implemented, providing an advanced</span>
<span class="linecomment">;;  illustration of using macro `icicle-define-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;(@* "How Multi `M-x' is Defined")</span>
<span class="linecomment">;;  ** How Multi `M-x' is Defined **</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The definition of `icicle-execute-extended-command' provides an</span>
<span class="linecomment">;;  interesting illustration of using `icicle-define-command'.  The</span>
<span class="linecomment">;;  candidate action function itself binds a candidate action</span>
<span class="linecomment">;;  function, in case the candidate is a command that reads input with</span>
<span class="linecomment">;;  completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (icicle-define-command</span>
<span class="linecomment">;;    icicle-execute-extended-command   ; `M-x' in Icicle mode.</span>
<span class="linecomment">;;    "Read command name, then read its arguments and call it."</span>
<span class="linecomment">;;    icicle-execute-extended-command-1 ; Action function</span>
<span class="linecomment">;;    (format "Execute command%s: "     ; `completing-read' args</span>
<span class="linecomment">;;            (if current-prefix-arg</span>
<span class="linecomment">;;                (format " (prefix %d)"</span>
<span class="linecomment">;;                        (prefix-numeric-value current-prefix-arg))</span>
<span class="linecomment">;;               ""))</span>
<span class="linecomment">;;    obarray 'commandp t nil 'extended-command-history nil nil</span>
<span class="linecomment">;;    ((last-cmd last-command))        ; Save the last command.</span>
<span class="linecomment">;;    nil (setq last-command last-cmd) ; Undo: restore last command.</span>
<span class="linecomment">;;    (setq last-command last-cmd))    ; Last: restore last command.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun icicle-execute-extended-command-1 (cmd-name)</span>
<span class="linecomment">;;    "Action function for `icicle-execute-extended-command'."</span>
<span class="linecomment">;;     (set-buffer icicle-orig-buff) ; bound by `icicle-define-command'.</span>
<span class="linecomment">;;     (select-window icicle-orig-window)</span>
<span class="linecomment">;;     (let ((icicle-candidate-action-fn</span>
<span class="linecomment">;;            (lambda (x) (funcall (intern cmd-name) x))))</span>
<span class="linecomment">;;       (run-hooks 'post-command-hook)</span>
<span class="linecomment">;;       (setq this-command cmd)</span>
<span class="linecomment">;;       (run-hooks 'pre-command-hook)</span>
<span class="linecomment">;;       (let ((enable-recursive-minibuffers  t))</span>
<span class="linecomment">;;         (call-interactively (intern cmd-name) 'record-it))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The last seven lines of this action function rebind</span>
<span class="linecomment">;;  `icicle-candidate-action-fn' to a function that calls the</span>
<span class="linecomment">;;  candidate `cmd-name' on a single argument that it reads.  This is</span>
<span class="linecomment">;;  useful if `cmd-name' is a command that, itself, reads an input</span>
<span class="linecomment">;;  argument with completion.  When that is the case, you can use</span>
<span class="linecomment">;;  completion on that input, and if you do that, you can use `C-RET'</span>
<span class="linecomment">;;  to use command `cmd-name' as a multi-command.  In other words,</span>
<span class="linecomment">;;  this binding allows for two levels of multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  There are a few things wrong with this definition, however.  In</span>
<span class="linecomment">;;  the action function, the candidate command is applied to a</span>
<span class="linecomment">;;  candidate that is a string.  What if it is a command, such as</span>
<span class="linecomment">;;  `describe-variable', that expects a symbol argument?  Or a number</span>
<span class="linecomment">;;  argument?  There is no way to know what kind of command will be</span>
<span class="linecomment">;;  used, and what kind of argument it will need.  The solution is to</span>
<span class="linecomment">;;  first try a string candidate argument, then convert the string to</span>
<span class="linecomment">;;  a symbol or number.  That is, bind this to</span>
<span class="linecomment">;;  `icicle-candidate-action-fn':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (lambda (x)</span>
<span class="linecomment">;;    (condition-case nil</span>
<span class="linecomment">;;        (funcall cmd x)    ; Try to use a string candidate.  If that</span>
<span class="linecomment">;;      (wrong-type-argument ; did not work, use a symbol or number.</span>
<span class="linecomment">;;       (funcall cmd (car (read-from-string x))))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  A similar problem occurs if the action function called does not</span>
<span class="linecomment">;;  accept a (single) argument.  The best thing to do in this case is</span>
<span class="linecomment">;;  punt - call `icicle-help-on-candidate' to display help on the</span>
<span class="linecomment">;;  candidate. To the code above, we add another error handler:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (wrong-number-of-arguments (funcall #'icicle-help-on-candidate))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  And what if the command `cmd' does something that changes the</span>
<span class="linecomment">;;  focus away from the minibuffer's frame?  That's the case for</span>
<span class="linecomment">;;  `describe-variable', for instance: it selects buffer `*Help*'.  To</span>
<span class="linecomment">;;  fix this potential problem, the action function needs to reset the</span>
<span class="linecomment">;;  focus back to the minibuffer frame:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (lambda (x)</span>
<span class="linecomment">;;    (condition-case nil</span>
<span class="linecomment">;;        (funcall cmd x)</span>
<span class="linecomment">;;      (wrong-type-argument (funcall cmd (car (read-from-string x))))</span>
<span class="linecomment">;;      (wrong-number-of-arguments</span>
<span class="linecomment">;;       (funcall #'icicle-help-on-candidate)))</span>
<span class="linecomment">;;    (select-frame-set-input-focus</span>
<span class="linecomment">;;      (window-frame (minibuffer-window))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The actual definitions of the action function and the main command</span>
<span class="linecomment">;;  are even more complex.  They need to take into account various</span>
<span class="linecomment">;;  subtleties, including those associated with recursive minibuffers</span>
<span class="linecomment">;;  and multiple invocations of `completing-read'.  Evaluate, for</span>
<span class="linecomment">;;  example, (symbol-function 'icicle-execute-extended-command) to see</span>
<span class="linecomment">;;  the real definition.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (@file :file-name "icicles-doc1.el" :to "Icicles Multi `M-x'").</span>
 
<span class="linecomment">;;(@* "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Multi-Commands the Hard Way</span>
<span class="linecomment">;;  ------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.  It gives you a taste</span>
<span class="linecomment">;;  of what is involved behind the scene when you effortlessly use</span>
<span class="linecomment">;;  `icicle-define-command' or `icicle-define-file-command' to define</span>
<span class="linecomment">;;  a multi-command.</span>
<span class="linecomment">;;  See (@&gt; "Defining Icicles Commands (Including Multi-Commands)").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  It can be good to know this, if only for the case where you need</span>
<span class="linecomment">;;  to define a multi-command that has special behavior not provided</span>
<span class="linecomment">;;  by `icicle-define(-file)-command' out of the box.  For example, if</span>
<span class="linecomment">;;  you want the normal, single-choice `RET' behavior to be different</span>
<span class="linecomment">;;  from the multiple-choice `C-RET' behavior, then you might want to</span>
<span class="linecomment">;;  roll your own.  Likewise, if you want to define your own help on</span>
<span class="linecomment">;;  individual candidates, to be invoked when users use `C-M-RET' and</span>
<span class="linecomment">;;  so on.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  To write your own multi-command, you must make the command do</span>
<span class="linecomment">;;  this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Call `completing-read' or `read-file-name', and perform some</span>
<span class="linecomment">;;     action on the completed input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Bind one or more of these variables to action functions, which</span>
<span class="linecomment">;;     each take a completion candidate as argument:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     a. `icicle-candidate-action-fn' - a function that performs an</span>
<span class="linecomment">;;        action on a completion candidate - often the same action as</span>
<span class="linecomment">;;        #1.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     b. `icicle-candidates-list-action-fn' - a function that</span>
<span class="linecomment">;;        performs an action on the list of all completion candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     c. `icicle-candidate-alt-action-fn' - a function that performs</span>
<span class="linecomment">;;        an alternative action on a completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     d. `icicle-candidates-list-alt-action-fn' - a function that</span>
<span class="linecomment">;;        performs an alternative action on the list of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     e. `icicle-candidate-help-fn' - a function that displays</span>
<span class="linecomment">;;        specialized help for a completion candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;        (You can also provide mode-line help and tooltip help for</span>
<span class="linecomment">;;        individual candidates.</span>
<span class="linecomment">;;        See "Candidates with Text Properties".)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     f. `icicle-delete-candidate-object' - a function that deletes</span>
<span class="linecomment">;;        an object associated with (e.g. named by) a completion</span>
<span class="linecomment">;;        candidate.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  #1 just lets people use the command normally, to perform the #1</span>
<span class="linecomment">;;  action on a completion candidate entered with `RET'.  Because of</span>
<span class="linecomment">;;  #2, people can perform the #2 action(s) on any completion</span>
<span class="linecomment">;;  candidates, while still continuing to cycle or complete</span>
<span class="linecomment">;;  candidates.  `icicle-candidate-action-fn' is often the same as the</span>
<span class="linecomment">;;  action for #1, but nothing prevents you from using different</span>
<span class="linecomment">;;  actions.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When internal variable `icicle-candidate-action-fn' is not bound,</span>
<span class="linecomment">;;  the default action is performed: display help on the current</span>
<span class="linecomment">;;  completion candidate.  When `icicle-candidate-help-fn' is not</span>
<span class="linecomment">;;  bound, the default help display is used.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Instead of binding `icicle-delete-candidate-object' to a deletion</span>
<span class="linecomment">;;  action function, you can bind it to a symbol (variable) whose</span>
<span class="linecomment">;;  value is a list of completion-candidate objects.</span>
<span class="linecomment">;;  See (@&gt; "More about Multi-Commands") for more information.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here is a definition of a simple (not multi-) command that reads a</span>
<span class="linecomment">;;  font name and then changes the selected frame to use that font.</span>
<span class="linecomment">;;  By virtue of calling `completing-read', Icicles completion and</span>
<span class="linecomment">;;  cycling are available, using all available font names as the pool</span>
<span class="linecomment">;;  of candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun change-font ()</span>
<span class="linecomment">;;    "Change font of selected frame."</span>
<span class="linecomment">;;    (modify-frame-parameters</span>
<span class="linecomment">;;     (selected-frame)</span>
<span class="linecomment">;;     (list (cons 'font (completing-read</span>
<span class="linecomment">;;                        "Font: " (mapcar #'list (x-list-fonts "*"))</span>
<span class="linecomment">;;                        nil t)))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's a definition of a multi-command `change-font' that takes</span>
<span class="linecomment">;;  advantage of an action function when cycling candidates:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1  (defun change-font ()</span>
<span class="linecomment">;;  2    "Change font of current frame."</span>
<span class="linecomment">;;  3    (interactive)</span>
<span class="linecomment">;;  4   (let* ((orig-frame  (selected-frame))</span>
<span class="linecomment">;;  5          (orig-font   (frame-parameter nil 'font))</span>
<span class="linecomment">;;  6          (icicle-candidate-action-fn</span>
<span class="linecomment">;;  7           ;; Perform the action on a candidate, without leaving</span>
<span class="linecomment">;;  8           ;; `completing-read'.  You can do this over and over.</span>
<span class="linecomment">;;  9           (lambda (font)</span>
<span class="linecomment">;;  10             (modify-frame-parameters orig-frame</span>
<span class="linecomment">;;  11                                      (list (cons 'font font))))))</span>
<span class="linecomment">;;  12     (condition-case nil</span>
<span class="linecomment">;;  13         (modify-frame-parameters</span>
<span class="linecomment">;;  14          orig-frame</span>
<span class="linecomment">;;  15          (list</span>
<span class="linecomment">;;  16           (cons 'font</span>
<span class="linecomment">;;  17                 ;; Perform the action on your final choice.</span>
<span class="linecomment">;;  18                 (completing-read</span>
<span class="linecomment">;;  19                  "Font: "</span>
<span class="linecomment">;;  20                  (mapcar #'list (x-list-fonts "*")) nil t))))</span>
<span class="linecomment">;;  21       ((quit error)</span>
<span class="linecomment">;;  22        (modify-frame-parameters</span>
<span class="linecomment">;;  23         orig-frame</span>
<span class="linecomment">;;  24         (list (cons 'font orig-font)))))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As you can see, there is a lot more going on here than in the</span>
<span class="linecomment">;;  simple-command version.  These are the points to keep in mind,</span>
<span class="linecomment">;;  when defining a multi-command by hand:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Save anything you need to restore, so you can, in effect, undo</span>
<span class="linecomment">;;     the action in case of `C-g' (lines 4-5).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Bind `icicle-candidate-action-fn' to the action to perform</span>
<span class="linecomment">;;     (lines 6-11).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Perform the action, using `completing-read' to provide the</span>
<span class="linecomment">;;     target candidate (lines 13-20).  Do this in the body of a</span>
<span class="linecomment">;;     `condition-case' (lines 12-24).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. Restore the original context in the error-handling part of the</span>
<span class="linecomment">;;     `condition-case' (lines 22-24).  Include `quit' in the</span>
<span class="linecomment">;;     error-type list.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The above definition is not quite complete, in fact.  To let</span>
<span class="linecomment">;;  `icicle-all-candidates' be able to report on failures, the</span>
<span class="linecomment">;;  `icicle-candidate-action-fn' code should also trap errors and</span>
<span class="linecomment">;;  return `nil' as a success indicator.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In fact, things can get even hairier (much hairier) still, if the</span>
<span class="linecomment">;;  function at the core of your command does things like create a new</span>
<span class="linecomment">;;  frame - especially on MS Windows, with its click-to-focus window</span>
<span class="linecomment">;;  manager.  The action of `change-font' does not do that, but if it</span>
<span class="linecomment">;;  did, you would need to redirect the focus back to the minibuffer</span>
<span class="linecomment">;;  frame, using `select-frame-set-input-focus'.  As an illustration</span>
<span class="linecomment">;;  of what's involved, here's a definition that would deal with such</span>
<span class="linecomment">;;  problems.  It also traps `icicle-candidate-action-fn' errors,</span>
<span class="linecomment">;;  returning `nil' to report success and the error message to report</span>
<span class="linecomment">;;  failure.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun change-font ()</span>
<span class="linecomment">;;    "Change font of current frame."</span>
<span class="linecomment">;;    (interactive)</span>
<span class="linecomment">;;    (let* ((icicle-orig-buff    (current-buffer))</span>
<span class="linecomment">;;           (icicle-orig-window  (selected-window))</span>
<span class="linecomment">;;           (orig-frame          (selected-frame))</span>
<span class="linecomment">;;           (orig-font           (frame-parameter nil 'font))</span>
<span class="linecomment">;;           (icicle-candidate-action-fn</span>
<span class="linecomment">;;            (lambda (candidate)</span>
<span class="linecomment">;;              (condition-case action-fn-return</span>
<span class="linecomment">;;                  (progn</span>
<span class="linecomment">;;                    (modify-frame-parameters</span>
<span class="linecomment">;;                     orig-frame (list (cons 'font candidate)))</span>
<span class="linecomment">;;                    (select-frame-set-input-focus</span>
<span class="linecomment">;;                     (window-frame (minibuffer-window)))</span>
<span class="linecomment">;;                    nil) ; Return nil to report success.</span>
<span class="linecomment">;;                ;; Return error message to report error.</span>
<span class="linecomment">;;                (error (error-message-string action-fn-return))))))</span>
<span class="linecomment">;;      (condition-case act-on-choice</span>
<span class="linecomment">;;          (modify-frame-parameters</span>
<span class="linecomment">;;           orig-frame</span>
<span class="linecomment">;;           (list (cons 'font</span>
<span class="linecomment">;;                       (completing-read</span>
<span class="linecomment">;;                        "Font: " (mapcar #'list (x-list-fonts "*"))</span>
<span class="linecomment">;;                        nil t nil nil nil nil))))</span>
<span class="linecomment">;;        (quit (switch-to-buffer icicle-orig-buff)</span>
<span class="linecomment">;;              (modify-frame-parameters</span>
<span class="linecomment">;;               orig-frame</span>
<span class="linecomment">;;               (list (cons 'font orig-font))))</span>
<span class="linecomment">;;        (error (switch-to-buffer icicle-orig-buff)</span>
<span class="linecomment">;;               (modify-frame-parameters</span>
<span class="linecomment">;;                orig-frame (list (cons 'font orig-font)))</span>
<span class="linecomment">;;               (error (error-message-string act-on-choice))))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  That's a lot of (error-prone) work!  You obviously do not want to</span>
<span class="linecomment">;;  be doing that a lot.  Whenever you can, you should use macro</span>
<span class="linecomment">;;  `icicle-define-command' or `icicle-define-file-command' to define</span>
<span class="linecomment">;;  your multi-commands.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@&gt; "Defining Icicles Commands (Including Multi-Commands)") for</span>
<span class="linecomment">;;    the easy way to define `change-font'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Icicles Tripping")</span>
<span class="linecomment">;;    for information about defining action functions that perform</span>
<span class="linecomment">;;    side effects on candidates.</span>
 
<span class="linecomment">;;(@* "Global Filters")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Global Filters</span>
<span class="linecomment">;;  --------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Which completion candidates get displayed?  To review:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. The domain of discourse, that is, all possible candidates, is</span>
<span class="linecomment">;;     determined by the arguments to `completing-read',</span>
<span class="linecomment">;;     `read-file-name', or `M-x'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. A user types something in the minibuffer.  This narrows the</span>
<span class="linecomment">;;     possible candidates to those that match the input.  Matching</span>
<span class="linecomment">;;     can be prefix-matching or apropos-matching.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Wouldn't it sometimes be useful to filter #1 in a global way,</span>
<span class="linecomment">;;  before filtering it with the user input (#2)?  Functions</span>
<span class="linecomment">;;  `completing-read' and `read-file-name' take a predicate argument,</span>
<span class="linecomment">;;  so that can be used for global filtering.  However, those</span>
<span class="linecomment">;;  functions are usually called from some command, and it would also</span>
<span class="linecomment">;;  be useful to give end users, not just programmers, some way to</span>
<span class="linecomment">;;  globally filter candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For example, if you have a command, such as `icicle-buffer', that</span>
<span class="linecomment">;;  reads a buffer name and displays the buffer, some users might</span>
<span class="linecomment">;;  always be interested only in buffers that are associated with</span>
<span class="linecomment">;;  files.  They do not want to see possible candidates such as</span>
<span class="linecomment">;;  `*scratch*' and `*Messages*'.  What they need is a way to apply a</span>
<span class="linecomment">;;  global predicate that limits candidates to file-buffer names - but</span>
<span class="linecomment">;;  they do not have access to the call to `completing-read' that is</span>
<span class="linecomment">;;  inside the command definition.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For this reason, some global filtering variables are provided by</span>
<span class="linecomment">;;  Icicles:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicle-must-match-regexp', `icicle-must-not-match-regexp',</span>
<span class="linecomment">;;    `icicle-must-pass-predicate',</span>
<span class="linecomment">;;    `icicle-must-pass-after-match-predicate',</span>
<span class="linecomment">;;    `icicle-extra-candidates'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The first and second of these are regexps that candidates must</span>
<span class="linecomment">;;  match and must not match, respectively, in order for them to be</span>
<span class="linecomment">;;  displayed.  The third and fourth are predicates that candidates</span>
<span class="linecomment">;;  must satisfy.  The fifth is a list of extra candidates to display.</span>
<span class="linecomment">;;  Any of the filters can be `nil', in which case it has no effect.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Each of these except `icicle-extra-candidates' filters not only</span>
<span class="linecomment">;;  completion candidates but also the default values passed to</span>
<span class="linecomment">;;  `completing-read' and `read-file-name'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-must-match-regexp' is similar to the standard</span>
<span class="linecomment">;;  variable `completion-regexp-list', except:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * `completion-regexp-list' is a list of regexps, not just one.</span>
<span class="linecomment">;;  * `icicle-must-match-regexp' is used after filtering using option</span>
<span class="linecomment">;;    `icicle-transform-function'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variables `icicle-must-pass-predicate' and</span>
<span class="linecomment">;;  `icicle-must-pass-after-match-predicate' act the same: they filter</span>
<span class="linecomment">;;  display candidates.  The former filters before the current user</span>
<span class="linecomment">;;  input is matched.  The latter filters after matching - it is</span>
<span class="linecomment">;;  applied only to candidates that match.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Neither is like the PREDICATE argument to `completing-read' in</span>
<span class="linecomment">;;  that they do not act on full candidates (e.g. alist entries) -</span>
<span class="linecomment">;;  they apply only to display candidates (strings).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For apropos completion, the `completing-read' PREDICATE is applied</span>
<span class="linecomment">;;  to all COLLECTION entries before matching those entries that</span>
<span class="linecomment">;;  satisfy it against the user input.  If the PREDICATE argument uses</span>
<span class="linecomment">;;  only the candidate name (it does not make any use of the full</span>
<span class="linecomment">;;  candidate) then it can sometimes be more efficient to pass `nil'</span>
<span class="linecomment">;;  as the PREDICATE and use `icicle-must-pass-after-match-predicate'</span>
<span class="linecomment">;;  instead.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here's a gotcha to keep in mind if you use</span>
<span class="linecomment">;;  `icicle-must-pass-predicate' or</span>
<span class="linecomment">;;  `icicle-must-pass-after-match-predicate' with (non-absolute)</span>
<span class="linecomment">;;  file-name candidates: Since the candidate file names have no</span>
<span class="linecomment">;;  directory part, in many cases you will want to test the candidate</span>
<span class="linecomment">;;  expanded relative to the directory shown in the minibuffer.  One</span>
<span class="linecomment">;;  way to do this is as follows:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (setq file  (expand-file-name file</span>
<span class="linecomment">;;               (icicle-file-name-directory-w-default</span>
<span class="linecomment">;;                 (icicle-input-from-minibuffer))))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This gotcha is nothing new - the same applies for standard Emacs</span>
<span class="linecomment">;;  function `read-file-name', but it is still worth pointing out.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Variable `icicle-extra-candidates' is not really a "filter".  It</span>
<span class="linecomment">;;  does not restrict the set of possible candidates - rather, it</span>
<span class="linecomment">;;  extends that set.  The other filters do not act on the candidates</span>
<span class="linecomment">;;  in `icicle-extra-candidates' - they are always added.  Extra</span>
<span class="linecomment">;;  candidates are displayed in buffer `*Completions*' using face</span>
<span class="linecomment">;;  `icicle-extra-candidate'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that an extra candidate need not have anything in common with</span>
<span class="linecomment">;;  the normal (non-extra) candidates.  In particular, because it is</span>
<span class="linecomment">;;  provided explicitly, it does not follow the restrictions implied</span>
<span class="linecomment">;;  by the current candidate-generation method.  </span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In this, extra candidates are similar to proxy candidates.  For</span>
<span class="linecomment">;;  example, when option `icicle-guess-commands-in-path' is non-`nil',</span>
<span class="linecomment">;;  the proxy shell-command candidates provided have no connection</span>
<span class="linecomment">;;  with the file-name completion that is used to generate the other</span>
<span class="linecomment">;;  candidates (see (@* "Icicles Shell-Command Enhancements")).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note too that if an extra candidate is already a candidate anyway</span>
<span class="linecomment">;;  then it will be present twice in the list of all candidates (that</span>
<span class="linecomment">;;  is, unless `icicle-transform-function' removes duplicate</span>
<span class="linecomment">;;  candidates).</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  These global variables are internal variables, even though they</span>
<span class="linecomment">;;  are defined as user options - they are not really meant to be</span>
<span class="linecomment">;;  customized.  If you are not an Emacs-Lisp programmer, you will not</span>
<span class="linecomment">;;  use these variables, but some commands that you use might provide</span>
<span class="linecomment">;;  corresponding global-filter user options.  Icicles provides</span>
<span class="linecomment">;;  customizable user options for Icicles buffer commands, such as</span>
<span class="linecomment">;;  `icicle-buffer'.  For example:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicle-buffer-match-regexp'    - Regexp buffer names must match</span>
<span class="linecomment">;;    `icicle-buffer-no-match-regexp' - Regexp buffers must not match</span>
<span class="linecomment">;;    `icicle-buffer-predicate'       - Predicate buffers must satisfy</span>
<span class="linecomment">;;    `icicle-buffer-extras'          - Extra buffer names to display</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You might, for instance, customize `icicle-buffer-no-match-regexp'</span>
<span class="linecomment">;;  to not display file-buffers whose names end in `.elc', and</span>
<span class="linecomment">;;  customize `icicle-buffer-predicate' to show only buffers that are</span>
<span class="linecomment">;;  associated with files.  The former would use a value of "\\.elc$",</span>
<span class="linecomment">;;  and the latter would use a value such as this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     (lambda (bufname) (buffer-file-name (get-buffer bufname)))</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Similarly, Icicles provides user options for filtering and sorting</span>
<span class="linecomment">;;  file names during completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    `icicle-file-match-regexp'    - Regexp file names must match</span>
<span class="linecomment">;;    `icicle-file-no-match-regexp' - Regexp file names must not match</span>
<span class="linecomment">;;    `icicle-file-predicate'       - Predicate files must satisfy</span>
<span class="linecomment">;;    `icicle-file-extras'          - Extra file names to display</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note that `icicle-buffer-predicate' and `icicle-file-predicate'</span>
<span class="linecomment">;;  correspond to `icicle-must-pass-after-match-predicate', not to</span>
<span class="linecomment">;;  `icicle-must-pass-predicate'.  They are applied after your current</span>
<span class="linecomment">;;  input filters the candidates.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you as a programmer write a command, and you want to expose</span>
<span class="linecomment">;;  global filters to users of the command, you should:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Create corresponding user options that can be customized.</span>
<span class="linecomment">;;  2. Bind the user options to the corresponding filtering variables.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `icicle-define-command' or `icicle-define-file-command'</span>
<span class="linecomment">;;  to define a command (recommended), then you can simply pass the</span>
<span class="linecomment">;;  filter-variable bindings as part of the BINDINGS argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  For convenience you can use macros `icicle-buffer-bindings' and</span>
<span class="linecomment">;;  `icicle-file-bindings' to provide bindings that are appropriate</span>
<span class="linecomment">;;  for buffer-name and file-name completion, respectively.  For</span>
<span class="linecomment">;;  example, macro `icicle-buffer-bindings' expands to include these</span>
<span class="linecomment">;;  bindings, among others:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (icicle-must-match-regexp             icicle-buffer-match-regexp)</span>
<span class="linecomment">;;   (icicle-must-not-match-regexp      icicle-buffer-no-match-regexp)</span>
<span class="linecomment">;;   (icicle-must-pass-after-match-predicate  icicle-buffer-predicate)</span>
<span class="linecomment">;;   (icicle-require-match-flag      icicle-buffer-require-match-flag)</span>
<span class="linecomment">;;   (icicle-extra-candidates                    icicle-buffer-extras)</span>
<span class="linecomment">;;   (icicle-ignore-space-prefix-flag</span>
<span class="linecomment">;;                             icicle-buffer-ignore-space-prefix-flag)</span>
<span class="linecomment">;;   (icicle-delete-candidate-object            'icicle-kill-a-buffer)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  As an example of using this macro, here is the core definition of</span>
<span class="linecomment">;;  `icicle-buffer':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;   (icicle-define-command</span>
<span class="linecomment">;;    icicle-buffer                          ; Command name</span>
<span class="linecomment">;;    "Switch to a different buffer."        ; Doc string</span>
<span class="linecomment">;;    switch-to-buffer                       ; Action function</span>
<span class="linecomment">;;    "Switch to buffer: "                   ; `completing-read' args</span>
<span class="linecomment">;;    (mapcar (lambda (buf) (list (buffer-name buf))) (buffer-list))</span>
<span class="linecomment">;;    nil nil nil 'buffer-name-history</span>
<span class="linecomment">;;    (icicle-default-buffer-names) nil</span>
<span class="linecomment">;;    ;; Filter bindings</span>
<span class="linecomment">;;    (icicle-buffer-bindings))       ; Macro provides buffer bindings</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you define a command that uses completion, but you do not use</span>
<span class="linecomment">;;  `icicle-define-command' or `icicle-define-file-command', then you</span>
<span class="linecomment">;;  can just bind appropriate variables individually around a call to</span>
<span class="linecomment">;;  `completing-read' or `read-file-name'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Another way that users can apply predicates to completion</span>
<span class="linecomment">;;  candidates is to use `M-&' while completing.  These predicates</span>
<span class="linecomment">;;  apply to the full alist-entry candidates that are supplied to</span>
<span class="linecomment">;;  `completing-read' or `read-file-name', not just to the textual</span>
<span class="linecomment">;;  candidates that are displayed in buffer `*Completions*'.</span>
<span class="linecomment">;;  See (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
 
<span class="linecomment">;;(@* "Specifying Match Functions for Commands")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Commands that Use Specific Match Functions</span>
<span class="linecomment">;;  ---------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  By default, Icicles lets users use basic prefix completion (with</span>
<span class="linecomment">;;  `TAB') or apropos completion (with `S-TAB'). They can</span>
<span class="linecomment">;;  alternatively use other completion methods with `TAB' and `S-TAB':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can use `C-(' during completion to cycle among `TAB'</span>
<span class="linecomment">;;    completion methods.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can use `M-(' to cycle among `S-TAB' completion</span>
<span class="linecomment">;;    methods.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * They can customize options `icicle-TAB-completion-methods-alist'</span>
<span class="linecomment">;;    and `icicle-S-TAB-completion-methods-alist', to define the</span>
<span class="linecomment">;;    completion methods among which they can cycle.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  When you define an Icicles command, you can specify which</span>
<span class="linecomment">;;  string-matching functions the command uses during completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If you want the command to use fuzzy completion for `TAB' by</span>
<span class="linecomment">;;    default, then bind `icicle-fuzzy-completion-flag' to</span>
<span class="linecomment">;;    non-`nil'. Users can still use `C-(' to toggle fuzzy completion</span>
<span class="linecomment">;;    off.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * If you want the command to use a particular string-matching</span>
<span class="linecomment">;;    function for `S-TAB' completion by default, then bind variable</span>
<span class="linecomment">;;    `icicle-apropos-complete-match-fn' to that function. Users can</span>
<span class="linecomment">;;    still use `M-(' to cycle among the other matching functions for</span>
<span class="linecomment">;;    `S-TAB'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  You can bind `icicle-apropos-complete-match-fn' to any function</span>
<span class="linecomment">;;  that matches strings.  You will probably also want to ensure that</span>
<span class="linecomment">;;  it is available for `M-(' cycling, by adding it to</span>
<span class="linecomment">;;  `icicle-S-TAB-completion-methods-alist' in a `let' binding.  For</span>
<span class="linecomment">;;  example, to use matching function `my-match' in `my-cmd', you</span>
<span class="linecomment">;;  might do this:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  (defun my-cmd ()</span>
<span class="linecomment">;;    "..."</span>
<span class="linecomment">;;    (interactive)</span>
<span class="linecomment">;;    (let ((icicle-apropos-complete-match-fn  'my-match)</span>
<span class="linecomment">;;          (icicle-S-TAB-completion-methods-alist</span>
<span class="linecomment">;;           (cons (cons "mine" 'my-match)</span>
<span class="linecomment">;;                 icicle-S-TAB-completion-methods-alist)))</span>
<span class="linecomment">;;        (do-something (completing-read "Choose: " ...) ...)))</span>
 
<span class="linecomment">;;(@* "Defining Buffer-Text Completion for Comint Modes")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Defining Buffer-Text Completion for Comint Modes</span>
<span class="linecomment">;;  ------------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This section is for Emacs-Lisp programmers.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Out of the box, Icicles provides completion for buffer text in</span>
<span class="linecomment">;;  some contexts.  This includes Shell mode, for example.  Whenever</span>
<span class="linecomment">;;  there are two or more candidate completions, you can use Icicles</span>
<span class="linecomment">;;  completion, with all of its features (cycling, progressive</span>
<span class="linecomment">;;  completion, apropos completion, and so on).</span>
<span class="linecomment">;;  See (@&gt; "Completion in Comint Modes").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Shell mode is an example of a mode that inherits from Comint mode.</span>
<span class="linecomment">;;  Other libraries sometimes define modes that also extend Comint</span>
<span class="linecomment">;;  mode in different ways.  Library ESS does so, for example.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In such modes, the top-level completion command used is typically</span>
<span class="linecomment">;;  `comint-dynamic-complete', and it is typically bound to `TAB'.  In</span>
<span class="linecomment">;;  Icicle mode, `TAB' in such a buffer is instead bound to the</span>
<span class="linecomment">;;  Icicles version of this command, `icicle-comint-dynamic-complete'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles provides the infrastructure for you to take advantage of</span>
<span class="linecomment">;;  Icicles completion with your own modes that inherit from Comint</span>
<span class="linecomment">;;  mode.  For that, just do the following:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Define replacement functions for the functions that perform the</span>
<span class="linecomment">;;     completion.  The functions to be replaced themselves typically</span>
<span class="linecomment">;;     call a Comint completion function, such as</span>
<span class="linecomment">;;     `comint-dynamic-complete-filename'.  You can typically use the</span>
<span class="linecomment">;;     same definitions as the original functions, except replace the</span>
<span class="linecomment">;;     call to a function that displays multiple matching candidates</span>
<span class="linecomment">;;     by a call to a corresponding Icicles function that performs</span>
<span class="linecomment">;;     completion.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Customize option `icicle-comint-dynamic-complete-replacements',</span>
<span class="linecomment">;;     adding the mappings that specify which standard functions to</span>
<span class="linecomment">;;     replace with your completion functions (from #1).  Take a look</span>
<span class="linecomment">;;     at the default value of this option to see what I mean.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Use `eval-after-load' to toggle Icicle mode when the vanilla</span>
<span class="linecomment">;;     code for your mode is loaded, to ensure that the original</span>
<span class="linecomment">;;     definitions are picked up.  See the end of `icicles-mode.el'</span>
<span class="linecomment">;;     for an example of this.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you are interested in trying this, take a look at the Icicles</span>
<span class="linecomment">;;  code for, say, `icicle-shell-dynamic-complete-command', comparing</span>
<span class="linecomment">;;  it with the original code for `shell-dynamic-complete-command'.</span>
<span class="linecomment">;;  You will see that the only change is to substitute a call to</span>
<span class="linecomment">;;  `icicle-shell-dynamic-complete-as-command' for a call to</span>
<span class="linecomment">;;  `shell-dynamic-complete-as-command'.  Likewise,</span>
<span class="linecomment">;;  `icicle-shell-dynamic-complete-as-command' is a trivial alteration</span>
<span class="linecomment">;;  of `shell-dynamic-complete-as-command'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  The key is to ultimately call an Icicles completion command, such</span>
<span class="linecomment">;;  as `icicle-comint-dynamic-simple-complete', whenever there are</span>
<span class="linecomment">;;  multiple completion candidates.  This has the effect of using</span>
<span class="linecomment">;;  Icicles minibuffer completion instead of simply displaying the</span>
<span class="linecomment">;;  alternatives in buffer `*Completions*'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Icicles uses this same technique, of substituting Icicles</span>
<span class="linecomment">;;  completion for simple display of alternatives, for all buffer-text</span>
<span class="linecomment">;;  completion that it supports out of the box, even when there is no</span>
<span class="linecomment">;;  relation with Comint mode.</span>
 
<span class="linecomment">;;(@* "Note to Programmers")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note to Programmers</span>
<span class="linecomment">;;  -------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Here are some simple guidelines for using Icicles in Emacs-Lisp</span>
<span class="linecomment">;;  programming:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. *Use it*!  Even if you do not do anything else, include this in</span>
<span class="linecomment">;;     your library:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     (require 'icicles nil t)</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     That has absolutely no consequences if Icicles is not present</span>
<span class="linecomment">;;     in the user's `load-path' (there is no load error).  If Icicles</span>
<span class="linecomment">;;     is present, however, then users can take advantage of each use</span>
<span class="linecomment">;;     you make of `completing-read' and `read-file-name' in your</span>
<span class="linecomment">;;     code.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Use an input-completion read function, such as</span>
<span class="linecomment">;;     `completing-read' or `read-file-name', when you read input!</span>
<span class="linecomment">;;     There is almost never a reason not to use an input-completion</span>
<span class="linecomment">;;     function when reading user input - especially considering that</span>
<span class="linecomment">;;     you need not always provide a REQUIRE-MATCH argument.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     Try also to find an appropriate PREDICATE argument, and a good</span>
<span class="linecomment">;;     set of default values to pass to `completing-read' as its</span>
<span class="linecomment">;;     COLLECTION argument.  Too often, I think, we use an overly</span>
<span class="linecomment">;;     general COLLECTION argument, such as the `obarray', and we do</span>
<span class="linecomment">;;     not provide a (good) PREDICATE.  Using an input-completion</span>
<span class="linecomment">;;     function with an appropriate candidate completion list and</span>
<span class="linecomment">;;     predicate can help users considerably.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;     If you want to also give users a way to customize a (different)</span>
<span class="linecomment">;;     predicate that applies only to the textual candidates that are</span>
<span class="linecomment">;;     displayed in buffer `*Completions*', as opposed to the full</span>
<span class="linecomment">;;     alist-entry candidates that are supplied to `completing-read'</span>
<span class="linecomment">;;     or `read-file-name', then you can define a new user option and</span>
<span class="linecomment">;;     then bind internal variable `icicle-must-pass-predicate' to the</span>
<span class="linecomment">;;     value of that option. See (@&gt; "Global Filters").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. Avoid using a literal-string `interactive' spec (e.g.</span>
<span class="linecomment">;;     (interactive "fFile: ")) that reads input with completion.</span>
<span class="linecomment">;;     Instead, call `completing-read' or `read-file-name' within the</span>
<span class="linecomment">;;     `interactive' spec.  This saves Icicles users of progressive</span>
<span class="linecomment">;;     completion the need to hit `RET' multiple times to pass their</span>
<span class="linecomment">;;     input up through multiple levels of recursive minibuffers to</span>
<span class="linecomment">;;     the top level.  See</span>
<span class="linecomment">;;     (@file :file-name "icicles-doc1.el" :to "Progressive Completion").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. In many cases, it makes sense to define a multi-command, rather</span>
<span class="linecomment">;;     than a simple command.  People can always use a multi-command</span>
<span class="linecomment">;;     as a simple command, but not vice versa.</span>
<span class="linecomment">;;     See (@file :file-name "icicles-doc1.el" :to "Multi-Commands"),</span>
<span class="linecomment">;;     (@&gt; "Defining Icicles Commands (Including Multi-Commands)"),</span>
<span class="linecomment">;;     and (@&gt; "Defining Multi-Commands the Hard Way").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. Consider using `icicle-completing-read-history' instead of</span>
<span class="linecomment">;;     `read-from-minibuffer' or `read-string' for most purposes.</span>
<span class="linecomment">;;     This lets users complete their input against previously entered</span>
<span class="linecomment">;;     input.  Completion is lax, so they can also enter new input.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. You can bind `icicle-sort-comparer' temporarily to any sort</span>
<span class="linecomment">;;     function you need.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7. Function `icicle-next-candidate' is a general framework for</span>
<span class="linecomment">;;     letting users cycle completions of partial input strings.  I</span>
<span class="linecomment">;;     use it to define the cycling behavior for both prefix and</span>
<span class="linecomment">;;     apropos completions.  You can use it to easily define other,</span>
<span class="linecomment">;;     application-specific input matching/completion/cycling</span>
<span class="linecomment">;;     behavior.  Just supply it with a function that takes the</span>
<span class="linecomment">;;     current partial user input (a string) and returns a list of</span>
<span class="linecomment">;;     candidate completions, however those might be defined.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  8. If the potential number of completion candidates is enormous,</span>
<span class="linecomment">;;     then icompletion display in `*Completions*' can be slow.  In</span>
<span class="linecomment">;;     that case, consider turning it off for the duration of the</span>
<span class="linecomment">;;     command, by binding `icicle-incremental-completion-flag' to</span>
<span class="linecomment">;;     `nil'.  An alternative to turning it off is the approach taken</span>
<span class="linecomment">;;     in Icicles (e.g. `icicle-vardoc' and</span>
<span class="linecomment">;;     `icicle-insert-thesaurus-entry'): Just add a reminder to the</span>
<span class="linecomment">;;     doc string to tell users that they can toggle</span>
<span class="linecomment">;;     `icicle-incremental-completion-flag' with `C-#'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  9. Another of my libraries that can help programmers provide</span>
<span class="linecomment">;;     default values is `thingatpt+.el'.  It provides functions for</span>
<span class="linecomment">;;     picking up symbols, sexps, numbers, words, and other sorts of</span>
<span class="linecomment">;;     thing near the text cursor (`point').</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  See Also:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  * (@file :file-name "icicles-doc1.el" :to "Multi-Commands")</span>
<span class="linecomment">;;  * (@&gt; "Defining Icicles Commands (Including Multi-Commands)")</span>
<span class="linecomment">;;  * (@&gt; "Defining Multi-Commands the Hard Way")</span>
<span class="linecomment">;;  * (@&gt; "Defining Multiple-Choice Menus")</span>
<span class="linecomment">;;  * (@&gt; "Global Filters")</span>
<span class="linecomment">;;  * (@&gt; "Specifying Match Functions for Commands")</span>
<span class="linecomment">;;  * (@&gt; "Multi-Completions")</span>
 
<span class="linecomment">;;(@* "La Petite Histoire")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  La Petite Histoire</span>
<span class="linecomment">;;  ------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. This library started life as `elect-mbuf.el', by Hans Koomen.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;    Original posting:</span>
<span class="linecomment">;;    From koomen@cs.rochester.edu Mon Jun 19 19:27:58 1989</span>
<span class="linecomment">;;    To: info-gnu-emacs@prep.ai.mit.edu</span>
<span class="linecomment">;;    Cc: Hans &lt;Koomen@cs.rochester.edu&gt;</span>
<span class="linecomment">;;    Subject: elect-mbuf.el</span>
<span class="linecomment">;;    Date: Tue, 13 Jun 89 15:17:07 -0400</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. I hacked and enhanced the library in various relatively minor</span>
<span class="linecomment">;;  ways over the years, maintaining it as `elect-mbuf.el' - see</span>
<span class="linecomment">;;  details in file `icicles-chg.el'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I did not change the main functionality of the library during this</span>
<span class="linecomment">;;  period: it always cycled the COMPLETE list of (prefix) completion</span>
<span class="linecomment">;;  candidates passed to `completing-read'; it did not update the</span>
<span class="linecomment">;;  candidate list based on the current minibuffer contents.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  So, for instance, if you had `M-x for' in the minibuffer, `down'</span>
<span class="linecomment">;;  would cycle among ALL Emacs commands, not just those that start</span>
<span class="linecomment">;;  with "for".  I used the library this way for fifteen years without</span>
<span class="linecomment">;;  thinking much about this behavior or the code behind it.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  3. In July 2005, Lennart Borgman gave `elect-mbuf.el' a quick try,</span>
<span class="linecomment">;;  and intuitively expected to see behavior along the lines that you</span>
<span class="linecomment">;;  see now for Icicles prefix completion:</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  a. `down' should cycle completions relative to the current input,</span>
<span class="linecomment">;;     not all completions supplied to `completing-read'.</span>
<span class="linecomment">;;  b. If buffer `*Completions*' is displayed, `down' should highlight</span>
<span class="linecomment">;;     the current candidate there.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Good idea Lennart (&lt;lennart.borgman.073@student.lu.se&gt;).  So I</span>
<span class="linecomment">;;  implemented that behavior, and renamed the library "Icicles" (for,</span>
<span class="linecomment">;;  I suppose, "input cycles" or some such - or because it's "cool").</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  4. The code changes I made to implement #3 (completion cycling</span>
<span class="linecomment">;;  relative to current input) made me realize that other completion</span>
<span class="linecomment">;;  matchings could be implemented in a similar way.  Prefix</span>
<span class="linecomment">;;  completion (the completion provided by Emacs) is handy, but it is</span>
<span class="linecomment">;;  also sometimes a bit limited.  The idea of apropos completion</span>
<span class="linecomment">;;  occurred to me, and I implemented that as well.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  5. I extended the library quite a bit more, in terms of</span>
<span class="linecomment">;;  convenience (highlighting, treatment of buffer</span>
<span class="linecomment">;;  `*Completions*',..., but also in terms of functionality.  In</span>
<span class="linecomment">;;  particular, it now treats file names too.  And, because Emacs 21</span>
<span class="linecomment">;;  and later versions use `read-file-name' for `find-file' and so on,</span>
<span class="linecomment">;;  Icicles now treats `read-file-name' the same as `completing-read'.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  6. On another suggestion from LennartBorgman, I made Icicles take</span>
<span class="linecomment">;;  advantage of Delete Selection mode.  And I implemented it as a</span>
<span class="linecomment">;;  minor mode.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  7, 8, 9,...  One thing has led to another, and I've just kept</span>
<span class="linecomment">;;  adding features.  Feature creep, I guess.  But the more I play</span>
<span class="linecomment">;;  with Icicles, the more I imagine new ways it might be made more</span>
<span class="linecomment">;;  useful.</span>
 
<span class="linecomment">;;(@* "Note on Non-`nil' `pop-up-frames' on MS Windows")</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  Note on Non-`nil' `pop-up-frames' on MS Windows</span>
<span class="linecomment">;;  -----------------------------------------------</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  If you use `pop-up-frames' = `t', like I do, you might have</span>
<span class="linecomment">;;  noticed that Emacs completion does not play well with using</span>
<span class="linecomment">;;  separate frames for each buffer.  In particular, it does not play</span>
<span class="linecomment">;;  well with having a separate frame for buffer `*Completions*'.</span>
<span class="linecomment">;;  When you try to complete input using `TAB', a new frame is created</span>
<span class="linecomment">;;  for buffer `*Completions*', and, at least on MS Windows, it is</span>
<span class="linecomment">;;  selected, taking the input focus away from the original frame's</span>
<span class="linecomment">;;  minibuffer!</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  This means that, once the `*Completions*' buffer has been</span>
<span class="linecomment">;;  displayed in a separate frame, you cannot, for instance, cycle</span>
<span class="linecomment">;;  completion candidates, without first reselecting the original</span>
<span class="linecomment">;;  frame manually.  You cannot even use normal completion - you</span>
<span class="linecomment">;;  cannot add text in the minibuffer, or delete text there, because</span>
<span class="linecomment">;;  the minibuffer in the original frame no longer has the input</span>
<span class="linecomment">;;  focus.  Bummer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  In general, Emacs does not play too well with one-buffer-per-frame</span>
<span class="linecomment">;;  (`pop-up-frames' = `t'), and this is a good example of that</span>
<span class="linecomment">;;  general problem.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I reported this Emacs bug.  I've been hoping it will be corrected</span>
<span class="linecomment">;;  since Emacs 21...</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  I do not have this problem of loss of frame input focus in my own</span>
<span class="linecomment">;;  setup, even though I use `pop-up-frames' = `t', because I use my</span>
<span class="linecomment">;;  library `oneonone.el'.  (Try it!)  If you need a solution while</span>
<span class="linecomment">;;  waiting for the Emacs fix, you can try doing something similar to</span>
<span class="linecomment">;;  what I do in `oneonone.el':</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  1. Use dedicated frames for both `*Completions*' and the</span>
<span class="linecomment">;;     minibuffer.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;  2. Display buffer `*Completions*' using a special-display function</span>
<span class="linecomment">;;     that explicitly redirects the input focus from the</span>
<span class="linecomment">;;     `*Completions*' frame back to the minibuffer frame.</span>
 
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; This program is free software; you can redistribute it and/or</span>
<span class="linecomment">;; modify it under the terms of the GNU General Public License as</span>
<span class="linecomment">;; published by the Free Software Foundation; either version 2, or (at</span>
<span class="linecomment">;; your option) any later version.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; This program is distributed in the hope that it will be useful,</span>
<span class="linecomment">;; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="linecomment">;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="linecomment">;; GNU General Public License for more details.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;; You should have received a copy of the GNU General Public License</span>
<span class="linecomment">;; along with this program; see the file COPYING.  If not, write to</span>
<span class="linecomment">;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth</span>
<span class="linecomment">;; Floor, Boston, MA 02110-1301, USA.</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;</span>
<span class="linecomment">;;; Code:</span>

<span class="linecomment">;; You need not load this file.  It contains only documentation.</span>

(provide 'icicles-doc2)

<span class="linecomment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="linecomment">;;; icicles-doc2.el ends here</span></span></pre></div><div class="wrapper close"></div></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="http://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a class="local" href="http://www.emacswiki.org/emacs/Search">Search</a> <a class="local" href="http://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="http://www.emacswiki.org/emacs/HowTo">HowTo</a> <a class="local" href="http://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="http://www.emacswiki.org/emacs/News">News</a> <a class="local" href="http://www.emacswiki.org/emacs/Problems">Problems</a> <a class="local" href="http://www.emacswiki.org/emacs/Suggestions">Suggestions</a> </span><span class="translation bar"><br />  <a class="translation new" rel="nofollow" href="http://www.emacswiki.org/emacs?action=translate;id=icicles-doc2.el;missing=de_es_fr_it_ja_ko_pt_ru_se_zh">Add Translation</a></span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" rel="nofollow" href="http://www.emacswiki.org/emacs?action=edit;id=icicles-doc2.el">Edit this page</a> <a class="history" rel="nofollow" href="http://www.emacswiki.org/emacs?action=history;id=icicles-doc2.el">View other revisions</a> <a class="admin" rel="nofollow" href="http://www.emacswiki.org/emacs?action=admin;id=icicles-doc2.el">Administration</a></span><span class="time"><br /> Last edited 2011-06-03 23:08 UTC by <a class="author" title="from 148.87.67.196" href="http://www.emacswiki.org/emacs/DrewAdams">DrewAdams</a> <a class="diff" rel="nofollow" href="http://www.emacswiki.org/emacs?action=browse;diff=2;id=icicles-doc2.el">(diff)</a></span><div style="float:right; margin-left:1ex;">
<!-- Creative Commons License -->
<a href="http://creativecommons.org/licenses/GPL/2.0/"><img alt="CC-GNU GPL" style="border:none" src="/pics/cc-GPL-a.png" /></a>
<!-- /Creative Commons License -->
</div>

<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <license rdf:resource="http://creativecommons.org/licenses/GPL/2.0/" />
  <dc:type rdf:resource="http://purl.org/dc/dcmitype/Software" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/GPL/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
   <requires rdf:resource="http://web.resource.org/cc/SourceCode" />
</License>
</rdf:RDF>
-->

<p class="legal">
This work is licensed to you under version 2 of the
<a href="http://www.gnu.org/">GNU</a> <a href="/GPL">General Public License</a>.
Alternatively, you may choose to receive this work under any other
license that grants the right to use, copy, modify, and/or distribute
the work, as long as that license imposes the restriction that
derivative works have to grant the same rights and impose the same
restriction. For example, you may choose to receive this work under
the
<a href="http://www.gnu.org/">GNU</a>
<a href="/FDL">Free Documentation License</a>, the
<a href="http://creativecommons.org/">CreativeCommons</a>
<a href="http://creativecommons.org/licenses/sa/1.0/">ShareAlike</a>
License, the XEmacs manual license, or
<a href="/OLD">similar licenses</a>.
</p>
</div>
</body>
</html>
